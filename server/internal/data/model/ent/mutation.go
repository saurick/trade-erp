// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"server/internal/data/model/ent/adminuser"
	"server/internal/data/model/ent/erpattachment"
	"server/internal/data/model/ent/erpbankreceipt"
	"server/internal/data/model/ent/erpbankreceiptclaim"
	"server/internal/data/model/ent/erpdoclink"
	"server/internal/data/model/ent/erpexportsale"
	"server/internal/data/model/ent/erpexportsaleitem"
	"server/internal/data/model/ent/erpinboundnotice"
	"server/internal/data/model/ent/erpinboundnoticeitem"
	"server/internal/data/model/ent/erplocation"
	"server/internal/data/model/ent/erpmodulerecord"
	"server/internal/data/model/ent/erpoutboundorder"
	"server/internal/data/model/ent/erpoutboundorderitem"
	"server/internal/data/model/ent/erppartner"
	"server/internal/data/model/ent/erpproduct"
	"server/internal/data/model/ent/erppurchasecontract"
	"server/internal/data/model/ent/erppurchasecontractitem"
	"server/internal/data/model/ent/erpquotation"
	"server/internal/data/model/ent/erpquotationitem"
	"server/internal/data/model/ent/erpsequence"
	"server/internal/data/model/ent/erpsettlement"
	"server/internal/data/model/ent/erpshipmentdetail"
	"server/internal/data/model/ent/erpshipmentdetailitem"
	"server/internal/data/model/ent/erpstockbalance"
	"server/internal/data/model/ent/erpstocktransaction"
	"server/internal/data/model/ent/erpwarehouse"
	"server/internal/data/model/ent/erpworkflowactionlog"
	"server/internal/data/model/ent/erpworkflowinstance"
	"server/internal/data/model/ent/erpworkflowtask"
	"server/internal/data/model/ent/predicate"
	"server/internal/data/model/ent/user"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdminUser               = "AdminUser"
	TypeERPAttachment           = "ERPAttachment"
	TypeERPBankReceipt          = "ERPBankReceipt"
	TypeERPBankReceiptClaim     = "ERPBankReceiptClaim"
	TypeERPDocLink              = "ERPDocLink"
	TypeERPExportSale           = "ERPExportSale"
	TypeERPExportSaleItem       = "ERPExportSaleItem"
	TypeERPInboundNotice        = "ERPInboundNotice"
	TypeERPInboundNoticeItem    = "ERPInboundNoticeItem"
	TypeERPLocation             = "ERPLocation"
	TypeERPModuleRecord         = "ERPModuleRecord"
	TypeERPOutboundOrder        = "ERPOutboundOrder"
	TypeERPOutboundOrderItem    = "ERPOutboundOrderItem"
	TypeERPPartner              = "ERPPartner"
	TypeERPProduct              = "ERPProduct"
	TypeERPPurchaseContract     = "ERPPurchaseContract"
	TypeERPPurchaseContractItem = "ERPPurchaseContractItem"
	TypeERPQuotation            = "ERPQuotation"
	TypeERPQuotationItem        = "ERPQuotationItem"
	TypeERPSequence             = "ERPSequence"
	TypeERPSettlement           = "ERPSettlement"
	TypeERPShipmentDetail       = "ERPShipmentDetail"
	TypeERPShipmentDetailItem   = "ERPShipmentDetailItem"
	TypeERPStockBalance         = "ERPStockBalance"
	TypeERPStockTransaction     = "ERPStockTransaction"
	TypeERPWarehouse            = "ERPWarehouse"
	TypeERPWorkflowActionLog    = "ERPWorkflowActionLog"
	TypeERPWorkflowInstance     = "ERPWorkflowInstance"
	TypeERPWorkflowTask         = "ERPWorkflowTask"
	TypeUser                    = "User"
)

// AdminUserMutation represents an operation that mutates the AdminUser nodes in the graph.
type AdminUserMutation struct {
	config
	op               Op
	typ              string
	id               *int
	username         *string
	password_hash    *string
	level            *int8
	addlevel         *int8
	menu_permissions *string
	parent_id        *int
	addparent_id     *int
	disabled         *bool
	last_login_at    *time.Time
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*AdminUser, error)
	predicates       []predicate.AdminUser
}

var _ ent.Mutation = (*AdminUserMutation)(nil)

// adminuserOption allows management of the mutation configuration using functional options.
type adminuserOption func(*AdminUserMutation)

// newAdminUserMutation creates new mutation for the AdminUser entity.
func newAdminUserMutation(c config, op Op, opts ...adminuserOption) *AdminUserMutation {
	m := &AdminUserMutation{
		config:        c,
		op:            op,
		typ:           TypeAdminUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminUserID sets the ID field of the mutation.
func withAdminUserID(id int) adminuserOption {
	return func(m *AdminUserMutation) {
		var (
			err   error
			once  sync.Once
			value *AdminUser
		)
		m.oldValue = func(ctx context.Context) (*AdminUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdminUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdminUser sets the old AdminUser of the mutation.
func withAdminUser(node *AdminUser) adminuserOption {
	return func(m *AdminUserMutation) {
		m.oldValue = func(context.Context) (*AdminUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdminUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdminUserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AdminUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *AdminUserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *AdminUserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *AdminUserMutation) ResetUsername() {
	m.username = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *AdminUserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *AdminUserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *AdminUserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetLevel sets the "level" field.
func (m *AdminUserMutation) SetLevel(i int8) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *AdminUserMutation) Level() (r int8, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldLevel(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *AdminUserMutation) AddLevel(i int8) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *AdminUserMutation) AddedLevel() (r int8, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *AdminUserMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetMenuPermissions sets the "menu_permissions" field.
func (m *AdminUserMutation) SetMenuPermissions(s string) {
	m.menu_permissions = &s
}

// MenuPermissions returns the value of the "menu_permissions" field in the mutation.
func (m *AdminUserMutation) MenuPermissions() (r string, exists bool) {
	v := m.menu_permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldMenuPermissions returns the old "menu_permissions" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldMenuPermissions(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenuPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenuPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenuPermissions: %w", err)
	}
	return oldValue.MenuPermissions, nil
}

// ResetMenuPermissions resets all changes to the "menu_permissions" field.
func (m *AdminUserMutation) ResetMenuPermissions() {
	m.menu_permissions = nil
}

// SetParentID sets the "parent_id" field.
func (m *AdminUserMutation) SetParentID(i int) {
	m.parent_id = &i
	m.addparent_id = nil
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *AdminUserMutation) ParentID() (r int, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldParentID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// AddParentID adds i to the "parent_id" field.
func (m *AdminUserMutation) AddParentID(i int) {
	if m.addparent_id != nil {
		*m.addparent_id += i
	} else {
		m.addparent_id = &i
	}
}

// AddedParentID returns the value that was added to the "parent_id" field in this mutation.
func (m *AdminUserMutation) AddedParentID() (r int, exists bool) {
	v := m.addparent_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearParentID clears the value of the "parent_id" field.
func (m *AdminUserMutation) ClearParentID() {
	m.parent_id = nil
	m.addparent_id = nil
	m.clearedFields[adminuser.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *AdminUserMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[adminuser.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *AdminUserMutation) ResetParentID() {
	m.parent_id = nil
	m.addparent_id = nil
	delete(m.clearedFields, adminuser.FieldParentID)
}

// SetDisabled sets the "disabled" field.
func (m *AdminUserMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *AdminUserMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *AdminUserMutation) ResetDisabled() {
	m.disabled = nil
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *AdminUserMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *AdminUserMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldLastLoginAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (m *AdminUserMutation) ClearLastLoginAt() {
	m.last_login_at = nil
	m.clearedFields[adminuser.FieldLastLoginAt] = struct{}{}
}

// LastLoginAtCleared returns if the "last_login_at" field was cleared in this mutation.
func (m *AdminUserMutation) LastLoginAtCleared() bool {
	_, ok := m.clearedFields[adminuser.FieldLastLoginAt]
	return ok
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *AdminUserMutation) ResetLastLoginAt() {
	m.last_login_at = nil
	delete(m.clearedFields, adminuser.FieldLastLoginAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *AdminUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdminUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdminUserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AdminUserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AdminUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AdminUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the AdminUserMutation builder.
func (m *AdminUserMutation) Where(ps ...predicate.AdminUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdminUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdminUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AdminUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdminUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdminUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AdminUser).
func (m *AdminUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminUserMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.username != nil {
		fields = append(fields, adminuser.FieldUsername)
	}
	if m.password_hash != nil {
		fields = append(fields, adminuser.FieldPasswordHash)
	}
	if m.level != nil {
		fields = append(fields, adminuser.FieldLevel)
	}
	if m.menu_permissions != nil {
		fields = append(fields, adminuser.FieldMenuPermissions)
	}
	if m.parent_id != nil {
		fields = append(fields, adminuser.FieldParentID)
	}
	if m.disabled != nil {
		fields = append(fields, adminuser.FieldDisabled)
	}
	if m.last_login_at != nil {
		fields = append(fields, adminuser.FieldLastLoginAt)
	}
	if m.created_at != nil {
		fields = append(fields, adminuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, adminuser.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case adminuser.FieldUsername:
		return m.Username()
	case adminuser.FieldPasswordHash:
		return m.PasswordHash()
	case adminuser.FieldLevel:
		return m.Level()
	case adminuser.FieldMenuPermissions:
		return m.MenuPermissions()
	case adminuser.FieldParentID:
		return m.ParentID()
	case adminuser.FieldDisabled:
		return m.Disabled()
	case adminuser.FieldLastLoginAt:
		return m.LastLoginAt()
	case adminuser.FieldCreatedAt:
		return m.CreatedAt()
	case adminuser.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case adminuser.FieldUsername:
		return m.OldUsername(ctx)
	case adminuser.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case adminuser.FieldLevel:
		return m.OldLevel(ctx)
	case adminuser.FieldMenuPermissions:
		return m.OldMenuPermissions(ctx)
	case adminuser.FieldParentID:
		return m.OldParentID(ctx)
	case adminuser.FieldDisabled:
		return m.OldDisabled(ctx)
	case adminuser.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	case adminuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case adminuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AdminUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case adminuser.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case adminuser.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case adminuser.FieldLevel:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case adminuser.FieldMenuPermissions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenuPermissions(v)
		return nil
	case adminuser.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case adminuser.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case adminuser.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	case adminuser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case adminuser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AdminUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminUserMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, adminuser.FieldLevel)
	}
	if m.addparent_id != nil {
		fields = append(fields, adminuser.FieldParentID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case adminuser.FieldLevel:
		return m.AddedLevel()
	case adminuser.FieldParentID:
		return m.AddedParentID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case adminuser.FieldLevel:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case adminuser.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParentID(v)
		return nil
	}
	return fmt.Errorf("unknown AdminUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(adminuser.FieldParentID) {
		fields = append(fields, adminuser.FieldParentID)
	}
	if m.FieldCleared(adminuser.FieldLastLoginAt) {
		fields = append(fields, adminuser.FieldLastLoginAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminUserMutation) ClearField(name string) error {
	switch name {
	case adminuser.FieldParentID:
		m.ClearParentID()
		return nil
	case adminuser.FieldLastLoginAt:
		m.ClearLastLoginAt()
		return nil
	}
	return fmt.Errorf("unknown AdminUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminUserMutation) ResetField(name string) error {
	switch name {
	case adminuser.FieldUsername:
		m.ResetUsername()
		return nil
	case adminuser.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case adminuser.FieldLevel:
		m.ResetLevel()
		return nil
	case adminuser.FieldMenuPermissions:
		m.ResetMenuPermissions()
		return nil
	case adminuser.FieldParentID:
		m.ResetParentID()
		return nil
	case adminuser.FieldDisabled:
		m.ResetDisabled()
		return nil
	case adminuser.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	case adminuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case adminuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AdminUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminUserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminUserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminUserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AdminUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminUserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AdminUser edge %s", name)
}

// ERPAttachmentMutation represents an operation that mutates the ERPAttachment nodes in the graph.
type ERPAttachmentMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	category                *string
	biz_module              *string
	biz_code                *string
	file_name               *string
	file_url                *string
	mime_type               *string
	file_size               *int64
	addfile_size            *int64
	uploaded_by_admin_id    *int
	adduploaded_by_admin_id *int
	created_at              *time.Time
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*ERPAttachment, error)
	predicates              []predicate.ERPAttachment
}

var _ ent.Mutation = (*ERPAttachmentMutation)(nil)

// erpattachmentOption allows management of the mutation configuration using functional options.
type erpattachmentOption func(*ERPAttachmentMutation)

// newERPAttachmentMutation creates new mutation for the ERPAttachment entity.
func newERPAttachmentMutation(c config, op Op, opts ...erpattachmentOption) *ERPAttachmentMutation {
	m := &ERPAttachmentMutation{
		config:        c,
		op:            op,
		typ:           TypeERPAttachment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withERPAttachmentID sets the ID field of the mutation.
func withERPAttachmentID(id int) erpattachmentOption {
	return func(m *ERPAttachmentMutation) {
		var (
			err   error
			once  sync.Once
			value *ERPAttachment
		)
		m.oldValue = func(ctx context.Context) (*ERPAttachment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ERPAttachment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withERPAttachment sets the old ERPAttachment of the mutation.
func withERPAttachment(node *ERPAttachment) erpattachmentOption {
	return func(m *ERPAttachmentMutation) {
		m.oldValue = func(context.Context) (*ERPAttachment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ERPAttachmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ERPAttachmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ERPAttachmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ERPAttachmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ERPAttachment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCategory sets the "category" field.
func (m *ERPAttachmentMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ERPAttachmentMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the ERPAttachment entity.
// If the ERPAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPAttachmentMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *ERPAttachmentMutation) ResetCategory() {
	m.category = nil
}

// SetBizModule sets the "biz_module" field.
func (m *ERPAttachmentMutation) SetBizModule(s string) {
	m.biz_module = &s
}

// BizModule returns the value of the "biz_module" field in the mutation.
func (m *ERPAttachmentMutation) BizModule() (r string, exists bool) {
	v := m.biz_module
	if v == nil {
		return
	}
	return *v, true
}

// OldBizModule returns the old "biz_module" field's value of the ERPAttachment entity.
// If the ERPAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPAttachmentMutation) OldBizModule(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBizModule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBizModule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBizModule: %w", err)
	}
	return oldValue.BizModule, nil
}

// ResetBizModule resets all changes to the "biz_module" field.
func (m *ERPAttachmentMutation) ResetBizModule() {
	m.biz_module = nil
}

// SetBizCode sets the "biz_code" field.
func (m *ERPAttachmentMutation) SetBizCode(s string) {
	m.biz_code = &s
}

// BizCode returns the value of the "biz_code" field in the mutation.
func (m *ERPAttachmentMutation) BizCode() (r string, exists bool) {
	v := m.biz_code
	if v == nil {
		return
	}
	return *v, true
}

// OldBizCode returns the old "biz_code" field's value of the ERPAttachment entity.
// If the ERPAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPAttachmentMutation) OldBizCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBizCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBizCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBizCode: %w", err)
	}
	return oldValue.BizCode, nil
}

// ResetBizCode resets all changes to the "biz_code" field.
func (m *ERPAttachmentMutation) ResetBizCode() {
	m.biz_code = nil
}

// SetFileName sets the "file_name" field.
func (m *ERPAttachmentMutation) SetFileName(s string) {
	m.file_name = &s
}

// FileName returns the value of the "file_name" field in the mutation.
func (m *ERPAttachmentMutation) FileName() (r string, exists bool) {
	v := m.file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFileName returns the old "file_name" field's value of the ERPAttachment entity.
// If the ERPAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPAttachmentMutation) OldFileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileName: %w", err)
	}
	return oldValue.FileName, nil
}

// ResetFileName resets all changes to the "file_name" field.
func (m *ERPAttachmentMutation) ResetFileName() {
	m.file_name = nil
}

// SetFileURL sets the "file_url" field.
func (m *ERPAttachmentMutation) SetFileURL(s string) {
	m.file_url = &s
}

// FileURL returns the value of the "file_url" field in the mutation.
func (m *ERPAttachmentMutation) FileURL() (r string, exists bool) {
	v := m.file_url
	if v == nil {
		return
	}
	return *v, true
}

// OldFileURL returns the old "file_url" field's value of the ERPAttachment entity.
// If the ERPAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPAttachmentMutation) OldFileURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileURL: %w", err)
	}
	return oldValue.FileURL, nil
}

// ResetFileURL resets all changes to the "file_url" field.
func (m *ERPAttachmentMutation) ResetFileURL() {
	m.file_url = nil
}

// SetMimeType sets the "mime_type" field.
func (m *ERPAttachmentMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *ERPAttachmentMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the ERPAttachment entity.
// If the ERPAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPAttachmentMutation) OldMimeType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ClearMimeType clears the value of the "mime_type" field.
func (m *ERPAttachmentMutation) ClearMimeType() {
	m.mime_type = nil
	m.clearedFields[erpattachment.FieldMimeType] = struct{}{}
}

// MimeTypeCleared returns if the "mime_type" field was cleared in this mutation.
func (m *ERPAttachmentMutation) MimeTypeCleared() bool {
	_, ok := m.clearedFields[erpattachment.FieldMimeType]
	return ok
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *ERPAttachmentMutation) ResetMimeType() {
	m.mime_type = nil
	delete(m.clearedFields, erpattachment.FieldMimeType)
}

// SetFileSize sets the "file_size" field.
func (m *ERPAttachmentMutation) SetFileSize(i int64) {
	m.file_size = &i
	m.addfile_size = nil
}

// FileSize returns the value of the "file_size" field in the mutation.
func (m *ERPAttachmentMutation) FileSize() (r int64, exists bool) {
	v := m.file_size
	if v == nil {
		return
	}
	return *v, true
}

// OldFileSize returns the old "file_size" field's value of the ERPAttachment entity.
// If the ERPAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPAttachmentMutation) OldFileSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileSize: %w", err)
	}
	return oldValue.FileSize, nil
}

// AddFileSize adds i to the "file_size" field.
func (m *ERPAttachmentMutation) AddFileSize(i int64) {
	if m.addfile_size != nil {
		*m.addfile_size += i
	} else {
		m.addfile_size = &i
	}
}

// AddedFileSize returns the value that was added to the "file_size" field in this mutation.
func (m *ERPAttachmentMutation) AddedFileSize() (r int64, exists bool) {
	v := m.addfile_size
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileSize resets all changes to the "file_size" field.
func (m *ERPAttachmentMutation) ResetFileSize() {
	m.file_size = nil
	m.addfile_size = nil
}

// SetUploadedByAdminID sets the "uploaded_by_admin_id" field.
func (m *ERPAttachmentMutation) SetUploadedByAdminID(i int) {
	m.uploaded_by_admin_id = &i
	m.adduploaded_by_admin_id = nil
}

// UploadedByAdminID returns the value of the "uploaded_by_admin_id" field in the mutation.
func (m *ERPAttachmentMutation) UploadedByAdminID() (r int, exists bool) {
	v := m.uploaded_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadedByAdminID returns the old "uploaded_by_admin_id" field's value of the ERPAttachment entity.
// If the ERPAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPAttachmentMutation) OldUploadedByAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadedByAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadedByAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadedByAdminID: %w", err)
	}
	return oldValue.UploadedByAdminID, nil
}

// AddUploadedByAdminID adds i to the "uploaded_by_admin_id" field.
func (m *ERPAttachmentMutation) AddUploadedByAdminID(i int) {
	if m.adduploaded_by_admin_id != nil {
		*m.adduploaded_by_admin_id += i
	} else {
		m.adduploaded_by_admin_id = &i
	}
}

// AddedUploadedByAdminID returns the value that was added to the "uploaded_by_admin_id" field in this mutation.
func (m *ERPAttachmentMutation) AddedUploadedByAdminID() (r int, exists bool) {
	v := m.adduploaded_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUploadedByAdminID clears the value of the "uploaded_by_admin_id" field.
func (m *ERPAttachmentMutation) ClearUploadedByAdminID() {
	m.uploaded_by_admin_id = nil
	m.adduploaded_by_admin_id = nil
	m.clearedFields[erpattachment.FieldUploadedByAdminID] = struct{}{}
}

// UploadedByAdminIDCleared returns if the "uploaded_by_admin_id" field was cleared in this mutation.
func (m *ERPAttachmentMutation) UploadedByAdminIDCleared() bool {
	_, ok := m.clearedFields[erpattachment.FieldUploadedByAdminID]
	return ok
}

// ResetUploadedByAdminID resets all changes to the "uploaded_by_admin_id" field.
func (m *ERPAttachmentMutation) ResetUploadedByAdminID() {
	m.uploaded_by_admin_id = nil
	m.adduploaded_by_admin_id = nil
	delete(m.clearedFields, erpattachment.FieldUploadedByAdminID)
}

// SetCreatedAt sets the "created_at" field.
func (m *ERPAttachmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ERPAttachmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ERPAttachment entity.
// If the ERPAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPAttachmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ERPAttachmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the ERPAttachmentMutation builder.
func (m *ERPAttachmentMutation) Where(ps ...predicate.ERPAttachment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ERPAttachmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ERPAttachmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ERPAttachment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ERPAttachmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ERPAttachmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ERPAttachment).
func (m *ERPAttachmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ERPAttachmentMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.category != nil {
		fields = append(fields, erpattachment.FieldCategory)
	}
	if m.biz_module != nil {
		fields = append(fields, erpattachment.FieldBizModule)
	}
	if m.biz_code != nil {
		fields = append(fields, erpattachment.FieldBizCode)
	}
	if m.file_name != nil {
		fields = append(fields, erpattachment.FieldFileName)
	}
	if m.file_url != nil {
		fields = append(fields, erpattachment.FieldFileURL)
	}
	if m.mime_type != nil {
		fields = append(fields, erpattachment.FieldMimeType)
	}
	if m.file_size != nil {
		fields = append(fields, erpattachment.FieldFileSize)
	}
	if m.uploaded_by_admin_id != nil {
		fields = append(fields, erpattachment.FieldUploadedByAdminID)
	}
	if m.created_at != nil {
		fields = append(fields, erpattachment.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ERPAttachmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case erpattachment.FieldCategory:
		return m.Category()
	case erpattachment.FieldBizModule:
		return m.BizModule()
	case erpattachment.FieldBizCode:
		return m.BizCode()
	case erpattachment.FieldFileName:
		return m.FileName()
	case erpattachment.FieldFileURL:
		return m.FileURL()
	case erpattachment.FieldMimeType:
		return m.MimeType()
	case erpattachment.FieldFileSize:
		return m.FileSize()
	case erpattachment.FieldUploadedByAdminID:
		return m.UploadedByAdminID()
	case erpattachment.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ERPAttachmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case erpattachment.FieldCategory:
		return m.OldCategory(ctx)
	case erpattachment.FieldBizModule:
		return m.OldBizModule(ctx)
	case erpattachment.FieldBizCode:
		return m.OldBizCode(ctx)
	case erpattachment.FieldFileName:
		return m.OldFileName(ctx)
	case erpattachment.FieldFileURL:
		return m.OldFileURL(ctx)
	case erpattachment.FieldMimeType:
		return m.OldMimeType(ctx)
	case erpattachment.FieldFileSize:
		return m.OldFileSize(ctx)
	case erpattachment.FieldUploadedByAdminID:
		return m.OldUploadedByAdminID(ctx)
	case erpattachment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ERPAttachment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPAttachmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case erpattachment.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case erpattachment.FieldBizModule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBizModule(v)
		return nil
	case erpattachment.FieldBizCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBizCode(v)
		return nil
	case erpattachment.FieldFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileName(v)
		return nil
	case erpattachment.FieldFileURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileURL(v)
		return nil
	case erpattachment.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	case erpattachment.FieldFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileSize(v)
		return nil
	case erpattachment.FieldUploadedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadedByAdminID(v)
		return nil
	case erpattachment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ERPAttachment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ERPAttachmentMutation) AddedFields() []string {
	var fields []string
	if m.addfile_size != nil {
		fields = append(fields, erpattachment.FieldFileSize)
	}
	if m.adduploaded_by_admin_id != nil {
		fields = append(fields, erpattachment.FieldUploadedByAdminID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ERPAttachmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case erpattachment.FieldFileSize:
		return m.AddedFileSize()
	case erpattachment.FieldUploadedByAdminID:
		return m.AddedUploadedByAdminID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPAttachmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case erpattachment.FieldFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileSize(v)
		return nil
	case erpattachment.FieldUploadedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUploadedByAdminID(v)
		return nil
	}
	return fmt.Errorf("unknown ERPAttachment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ERPAttachmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(erpattachment.FieldMimeType) {
		fields = append(fields, erpattachment.FieldMimeType)
	}
	if m.FieldCleared(erpattachment.FieldUploadedByAdminID) {
		fields = append(fields, erpattachment.FieldUploadedByAdminID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ERPAttachmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ERPAttachmentMutation) ClearField(name string) error {
	switch name {
	case erpattachment.FieldMimeType:
		m.ClearMimeType()
		return nil
	case erpattachment.FieldUploadedByAdminID:
		m.ClearUploadedByAdminID()
		return nil
	}
	return fmt.Errorf("unknown ERPAttachment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ERPAttachmentMutation) ResetField(name string) error {
	switch name {
	case erpattachment.FieldCategory:
		m.ResetCategory()
		return nil
	case erpattachment.FieldBizModule:
		m.ResetBizModule()
		return nil
	case erpattachment.FieldBizCode:
		m.ResetBizCode()
		return nil
	case erpattachment.FieldFileName:
		m.ResetFileName()
		return nil
	case erpattachment.FieldFileURL:
		m.ResetFileURL()
		return nil
	case erpattachment.FieldMimeType:
		m.ResetMimeType()
		return nil
	case erpattachment.FieldFileSize:
		m.ResetFileSize()
		return nil
	case erpattachment.FieldUploadedByAdminID:
		m.ResetUploadedByAdminID()
		return nil
	case erpattachment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPAttachment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ERPAttachmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ERPAttachmentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ERPAttachmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ERPAttachmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ERPAttachmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ERPAttachmentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ERPAttachmentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ERPAttachment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ERPAttachmentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ERPAttachment edge %s", name)
}

// ERPBankReceiptMutation represents an operation that mutates the ERPBankReceipt nodes in the graph.
type ERPBankReceiptMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	code                   *string
	register_date          *time.Time
	fund_type              *string
	currency               *string
	received_amount        *float64
	addreceived_amount     *float64
	bank_fee               *float64
	addbank_fee            *float64
	net_amount             *float64
	addnet_amount          *float64
	ref_no                 *string
	status                 *string
	created_by_admin_id    *int
	addcreated_by_admin_id *int
	updated_by_admin_id    *int
	addupdated_by_admin_id *int
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*ERPBankReceipt, error)
	predicates             []predicate.ERPBankReceipt
}

var _ ent.Mutation = (*ERPBankReceiptMutation)(nil)

// erpbankreceiptOption allows management of the mutation configuration using functional options.
type erpbankreceiptOption func(*ERPBankReceiptMutation)

// newERPBankReceiptMutation creates new mutation for the ERPBankReceipt entity.
func newERPBankReceiptMutation(c config, op Op, opts ...erpbankreceiptOption) *ERPBankReceiptMutation {
	m := &ERPBankReceiptMutation{
		config:        c,
		op:            op,
		typ:           TypeERPBankReceipt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withERPBankReceiptID sets the ID field of the mutation.
func withERPBankReceiptID(id int) erpbankreceiptOption {
	return func(m *ERPBankReceiptMutation) {
		var (
			err   error
			once  sync.Once
			value *ERPBankReceipt
		)
		m.oldValue = func(ctx context.Context) (*ERPBankReceipt, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ERPBankReceipt.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withERPBankReceipt sets the old ERPBankReceipt of the mutation.
func withERPBankReceipt(node *ERPBankReceipt) erpbankreceiptOption {
	return func(m *ERPBankReceiptMutation) {
		m.oldValue = func(context.Context) (*ERPBankReceipt, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ERPBankReceiptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ERPBankReceiptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ERPBankReceiptMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ERPBankReceiptMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ERPBankReceipt.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *ERPBankReceiptMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ERPBankReceiptMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the ERPBankReceipt entity.
// If the ERPBankReceipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPBankReceiptMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ERPBankReceiptMutation) ResetCode() {
	m.code = nil
}

// SetRegisterDate sets the "register_date" field.
func (m *ERPBankReceiptMutation) SetRegisterDate(t time.Time) {
	m.register_date = &t
}

// RegisterDate returns the value of the "register_date" field in the mutation.
func (m *ERPBankReceiptMutation) RegisterDate() (r time.Time, exists bool) {
	v := m.register_date
	if v == nil {
		return
	}
	return *v, true
}

// OldRegisterDate returns the old "register_date" field's value of the ERPBankReceipt entity.
// If the ERPBankReceipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPBankReceiptMutation) OldRegisterDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegisterDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegisterDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegisterDate: %w", err)
	}
	return oldValue.RegisterDate, nil
}

// ResetRegisterDate resets all changes to the "register_date" field.
func (m *ERPBankReceiptMutation) ResetRegisterDate() {
	m.register_date = nil
}

// SetFundType sets the "fund_type" field.
func (m *ERPBankReceiptMutation) SetFundType(s string) {
	m.fund_type = &s
}

// FundType returns the value of the "fund_type" field in the mutation.
func (m *ERPBankReceiptMutation) FundType() (r string, exists bool) {
	v := m.fund_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFundType returns the old "fund_type" field's value of the ERPBankReceipt entity.
// If the ERPBankReceipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPBankReceiptMutation) OldFundType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFundType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFundType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFundType: %w", err)
	}
	return oldValue.FundType, nil
}

// ResetFundType resets all changes to the "fund_type" field.
func (m *ERPBankReceiptMutation) ResetFundType() {
	m.fund_type = nil
}

// SetCurrency sets the "currency" field.
func (m *ERPBankReceiptMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *ERPBankReceiptMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the ERPBankReceipt entity.
// If the ERPBankReceipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPBankReceiptMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *ERPBankReceiptMutation) ResetCurrency() {
	m.currency = nil
}

// SetReceivedAmount sets the "received_amount" field.
func (m *ERPBankReceiptMutation) SetReceivedAmount(f float64) {
	m.received_amount = &f
	m.addreceived_amount = nil
}

// ReceivedAmount returns the value of the "received_amount" field in the mutation.
func (m *ERPBankReceiptMutation) ReceivedAmount() (r float64, exists bool) {
	v := m.received_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldReceivedAmount returns the old "received_amount" field's value of the ERPBankReceipt entity.
// If the ERPBankReceipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPBankReceiptMutation) OldReceivedAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceivedAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceivedAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceivedAmount: %w", err)
	}
	return oldValue.ReceivedAmount, nil
}

// AddReceivedAmount adds f to the "received_amount" field.
func (m *ERPBankReceiptMutation) AddReceivedAmount(f float64) {
	if m.addreceived_amount != nil {
		*m.addreceived_amount += f
	} else {
		m.addreceived_amount = &f
	}
}

// AddedReceivedAmount returns the value that was added to the "received_amount" field in this mutation.
func (m *ERPBankReceiptMutation) AddedReceivedAmount() (r float64, exists bool) {
	v := m.addreceived_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetReceivedAmount resets all changes to the "received_amount" field.
func (m *ERPBankReceiptMutation) ResetReceivedAmount() {
	m.received_amount = nil
	m.addreceived_amount = nil
}

// SetBankFee sets the "bank_fee" field.
func (m *ERPBankReceiptMutation) SetBankFee(f float64) {
	m.bank_fee = &f
	m.addbank_fee = nil
}

// BankFee returns the value of the "bank_fee" field in the mutation.
func (m *ERPBankReceiptMutation) BankFee() (r float64, exists bool) {
	v := m.bank_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldBankFee returns the old "bank_fee" field's value of the ERPBankReceipt entity.
// If the ERPBankReceipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPBankReceiptMutation) OldBankFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankFee: %w", err)
	}
	return oldValue.BankFee, nil
}

// AddBankFee adds f to the "bank_fee" field.
func (m *ERPBankReceiptMutation) AddBankFee(f float64) {
	if m.addbank_fee != nil {
		*m.addbank_fee += f
	} else {
		m.addbank_fee = &f
	}
}

// AddedBankFee returns the value that was added to the "bank_fee" field in this mutation.
func (m *ERPBankReceiptMutation) AddedBankFee() (r float64, exists bool) {
	v := m.addbank_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetBankFee resets all changes to the "bank_fee" field.
func (m *ERPBankReceiptMutation) ResetBankFee() {
	m.bank_fee = nil
	m.addbank_fee = nil
}

// SetNetAmount sets the "net_amount" field.
func (m *ERPBankReceiptMutation) SetNetAmount(f float64) {
	m.net_amount = &f
	m.addnet_amount = nil
}

// NetAmount returns the value of the "net_amount" field in the mutation.
func (m *ERPBankReceiptMutation) NetAmount() (r float64, exists bool) {
	v := m.net_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldNetAmount returns the old "net_amount" field's value of the ERPBankReceipt entity.
// If the ERPBankReceipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPBankReceiptMutation) OldNetAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNetAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNetAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetAmount: %w", err)
	}
	return oldValue.NetAmount, nil
}

// AddNetAmount adds f to the "net_amount" field.
func (m *ERPBankReceiptMutation) AddNetAmount(f float64) {
	if m.addnet_amount != nil {
		*m.addnet_amount += f
	} else {
		m.addnet_amount = &f
	}
}

// AddedNetAmount returns the value that was added to the "net_amount" field in this mutation.
func (m *ERPBankReceiptMutation) AddedNetAmount() (r float64, exists bool) {
	v := m.addnet_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetNetAmount resets all changes to the "net_amount" field.
func (m *ERPBankReceiptMutation) ResetNetAmount() {
	m.net_amount = nil
	m.addnet_amount = nil
}

// SetRefNo sets the "ref_no" field.
func (m *ERPBankReceiptMutation) SetRefNo(s string) {
	m.ref_no = &s
}

// RefNo returns the value of the "ref_no" field in the mutation.
func (m *ERPBankReceiptMutation) RefNo() (r string, exists bool) {
	v := m.ref_no
	if v == nil {
		return
	}
	return *v, true
}

// OldRefNo returns the old "ref_no" field's value of the ERPBankReceipt entity.
// If the ERPBankReceipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPBankReceiptMutation) OldRefNo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefNo: %w", err)
	}
	return oldValue.RefNo, nil
}

// ClearRefNo clears the value of the "ref_no" field.
func (m *ERPBankReceiptMutation) ClearRefNo() {
	m.ref_no = nil
	m.clearedFields[erpbankreceipt.FieldRefNo] = struct{}{}
}

// RefNoCleared returns if the "ref_no" field was cleared in this mutation.
func (m *ERPBankReceiptMutation) RefNoCleared() bool {
	_, ok := m.clearedFields[erpbankreceipt.FieldRefNo]
	return ok
}

// ResetRefNo resets all changes to the "ref_no" field.
func (m *ERPBankReceiptMutation) ResetRefNo() {
	m.ref_no = nil
	delete(m.clearedFields, erpbankreceipt.FieldRefNo)
}

// SetStatus sets the "status" field.
func (m *ERPBankReceiptMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ERPBankReceiptMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ERPBankReceipt entity.
// If the ERPBankReceipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPBankReceiptMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ERPBankReceiptMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedByAdminID sets the "created_by_admin_id" field.
func (m *ERPBankReceiptMutation) SetCreatedByAdminID(i int) {
	m.created_by_admin_id = &i
	m.addcreated_by_admin_id = nil
}

// CreatedByAdminID returns the value of the "created_by_admin_id" field in the mutation.
func (m *ERPBankReceiptMutation) CreatedByAdminID() (r int, exists bool) {
	v := m.created_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedByAdminID returns the old "created_by_admin_id" field's value of the ERPBankReceipt entity.
// If the ERPBankReceipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPBankReceiptMutation) OldCreatedByAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedByAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedByAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedByAdminID: %w", err)
	}
	return oldValue.CreatedByAdminID, nil
}

// AddCreatedByAdminID adds i to the "created_by_admin_id" field.
func (m *ERPBankReceiptMutation) AddCreatedByAdminID(i int) {
	if m.addcreated_by_admin_id != nil {
		*m.addcreated_by_admin_id += i
	} else {
		m.addcreated_by_admin_id = &i
	}
}

// AddedCreatedByAdminID returns the value that was added to the "created_by_admin_id" field in this mutation.
func (m *ERPBankReceiptMutation) AddedCreatedByAdminID() (r int, exists bool) {
	v := m.addcreated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedByAdminID clears the value of the "created_by_admin_id" field.
func (m *ERPBankReceiptMutation) ClearCreatedByAdminID() {
	m.created_by_admin_id = nil
	m.addcreated_by_admin_id = nil
	m.clearedFields[erpbankreceipt.FieldCreatedByAdminID] = struct{}{}
}

// CreatedByAdminIDCleared returns if the "created_by_admin_id" field was cleared in this mutation.
func (m *ERPBankReceiptMutation) CreatedByAdminIDCleared() bool {
	_, ok := m.clearedFields[erpbankreceipt.FieldCreatedByAdminID]
	return ok
}

// ResetCreatedByAdminID resets all changes to the "created_by_admin_id" field.
func (m *ERPBankReceiptMutation) ResetCreatedByAdminID() {
	m.created_by_admin_id = nil
	m.addcreated_by_admin_id = nil
	delete(m.clearedFields, erpbankreceipt.FieldCreatedByAdminID)
}

// SetUpdatedByAdminID sets the "updated_by_admin_id" field.
func (m *ERPBankReceiptMutation) SetUpdatedByAdminID(i int) {
	m.updated_by_admin_id = &i
	m.addupdated_by_admin_id = nil
}

// UpdatedByAdminID returns the value of the "updated_by_admin_id" field in the mutation.
func (m *ERPBankReceiptMutation) UpdatedByAdminID() (r int, exists bool) {
	v := m.updated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedByAdminID returns the old "updated_by_admin_id" field's value of the ERPBankReceipt entity.
// If the ERPBankReceipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPBankReceiptMutation) OldUpdatedByAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedByAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedByAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedByAdminID: %w", err)
	}
	return oldValue.UpdatedByAdminID, nil
}

// AddUpdatedByAdminID adds i to the "updated_by_admin_id" field.
func (m *ERPBankReceiptMutation) AddUpdatedByAdminID(i int) {
	if m.addupdated_by_admin_id != nil {
		*m.addupdated_by_admin_id += i
	} else {
		m.addupdated_by_admin_id = &i
	}
}

// AddedUpdatedByAdminID returns the value that was added to the "updated_by_admin_id" field in this mutation.
func (m *ERPBankReceiptMutation) AddedUpdatedByAdminID() (r int, exists bool) {
	v := m.addupdated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedByAdminID clears the value of the "updated_by_admin_id" field.
func (m *ERPBankReceiptMutation) ClearUpdatedByAdminID() {
	m.updated_by_admin_id = nil
	m.addupdated_by_admin_id = nil
	m.clearedFields[erpbankreceipt.FieldUpdatedByAdminID] = struct{}{}
}

// UpdatedByAdminIDCleared returns if the "updated_by_admin_id" field was cleared in this mutation.
func (m *ERPBankReceiptMutation) UpdatedByAdminIDCleared() bool {
	_, ok := m.clearedFields[erpbankreceipt.FieldUpdatedByAdminID]
	return ok
}

// ResetUpdatedByAdminID resets all changes to the "updated_by_admin_id" field.
func (m *ERPBankReceiptMutation) ResetUpdatedByAdminID() {
	m.updated_by_admin_id = nil
	m.addupdated_by_admin_id = nil
	delete(m.clearedFields, erpbankreceipt.FieldUpdatedByAdminID)
}

// SetCreatedAt sets the "created_at" field.
func (m *ERPBankReceiptMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ERPBankReceiptMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ERPBankReceipt entity.
// If the ERPBankReceipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPBankReceiptMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ERPBankReceiptMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ERPBankReceiptMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ERPBankReceiptMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ERPBankReceipt entity.
// If the ERPBankReceipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPBankReceiptMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ERPBankReceiptMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ERPBankReceiptMutation builder.
func (m *ERPBankReceiptMutation) Where(ps ...predicate.ERPBankReceipt) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ERPBankReceiptMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ERPBankReceiptMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ERPBankReceipt, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ERPBankReceiptMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ERPBankReceiptMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ERPBankReceipt).
func (m *ERPBankReceiptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ERPBankReceiptMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.code != nil {
		fields = append(fields, erpbankreceipt.FieldCode)
	}
	if m.register_date != nil {
		fields = append(fields, erpbankreceipt.FieldRegisterDate)
	}
	if m.fund_type != nil {
		fields = append(fields, erpbankreceipt.FieldFundType)
	}
	if m.currency != nil {
		fields = append(fields, erpbankreceipt.FieldCurrency)
	}
	if m.received_amount != nil {
		fields = append(fields, erpbankreceipt.FieldReceivedAmount)
	}
	if m.bank_fee != nil {
		fields = append(fields, erpbankreceipt.FieldBankFee)
	}
	if m.net_amount != nil {
		fields = append(fields, erpbankreceipt.FieldNetAmount)
	}
	if m.ref_no != nil {
		fields = append(fields, erpbankreceipt.FieldRefNo)
	}
	if m.status != nil {
		fields = append(fields, erpbankreceipt.FieldStatus)
	}
	if m.created_by_admin_id != nil {
		fields = append(fields, erpbankreceipt.FieldCreatedByAdminID)
	}
	if m.updated_by_admin_id != nil {
		fields = append(fields, erpbankreceipt.FieldUpdatedByAdminID)
	}
	if m.created_at != nil {
		fields = append(fields, erpbankreceipt.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, erpbankreceipt.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ERPBankReceiptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case erpbankreceipt.FieldCode:
		return m.Code()
	case erpbankreceipt.FieldRegisterDate:
		return m.RegisterDate()
	case erpbankreceipt.FieldFundType:
		return m.FundType()
	case erpbankreceipt.FieldCurrency:
		return m.Currency()
	case erpbankreceipt.FieldReceivedAmount:
		return m.ReceivedAmount()
	case erpbankreceipt.FieldBankFee:
		return m.BankFee()
	case erpbankreceipt.FieldNetAmount:
		return m.NetAmount()
	case erpbankreceipt.FieldRefNo:
		return m.RefNo()
	case erpbankreceipt.FieldStatus:
		return m.Status()
	case erpbankreceipt.FieldCreatedByAdminID:
		return m.CreatedByAdminID()
	case erpbankreceipt.FieldUpdatedByAdminID:
		return m.UpdatedByAdminID()
	case erpbankreceipt.FieldCreatedAt:
		return m.CreatedAt()
	case erpbankreceipt.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ERPBankReceiptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case erpbankreceipt.FieldCode:
		return m.OldCode(ctx)
	case erpbankreceipt.FieldRegisterDate:
		return m.OldRegisterDate(ctx)
	case erpbankreceipt.FieldFundType:
		return m.OldFundType(ctx)
	case erpbankreceipt.FieldCurrency:
		return m.OldCurrency(ctx)
	case erpbankreceipt.FieldReceivedAmount:
		return m.OldReceivedAmount(ctx)
	case erpbankreceipt.FieldBankFee:
		return m.OldBankFee(ctx)
	case erpbankreceipt.FieldNetAmount:
		return m.OldNetAmount(ctx)
	case erpbankreceipt.FieldRefNo:
		return m.OldRefNo(ctx)
	case erpbankreceipt.FieldStatus:
		return m.OldStatus(ctx)
	case erpbankreceipt.FieldCreatedByAdminID:
		return m.OldCreatedByAdminID(ctx)
	case erpbankreceipt.FieldUpdatedByAdminID:
		return m.OldUpdatedByAdminID(ctx)
	case erpbankreceipt.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case erpbankreceipt.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ERPBankReceipt field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPBankReceiptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case erpbankreceipt.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case erpbankreceipt.FieldRegisterDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegisterDate(v)
		return nil
	case erpbankreceipt.FieldFundType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFundType(v)
		return nil
	case erpbankreceipt.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case erpbankreceipt.FieldReceivedAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceivedAmount(v)
		return nil
	case erpbankreceipt.FieldBankFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankFee(v)
		return nil
	case erpbankreceipt.FieldNetAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetAmount(v)
		return nil
	case erpbankreceipt.FieldRefNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefNo(v)
		return nil
	case erpbankreceipt.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case erpbankreceipt.FieldCreatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedByAdminID(v)
		return nil
	case erpbankreceipt.FieldUpdatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedByAdminID(v)
		return nil
	case erpbankreceipt.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case erpbankreceipt.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ERPBankReceipt field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ERPBankReceiptMutation) AddedFields() []string {
	var fields []string
	if m.addreceived_amount != nil {
		fields = append(fields, erpbankreceipt.FieldReceivedAmount)
	}
	if m.addbank_fee != nil {
		fields = append(fields, erpbankreceipt.FieldBankFee)
	}
	if m.addnet_amount != nil {
		fields = append(fields, erpbankreceipt.FieldNetAmount)
	}
	if m.addcreated_by_admin_id != nil {
		fields = append(fields, erpbankreceipt.FieldCreatedByAdminID)
	}
	if m.addupdated_by_admin_id != nil {
		fields = append(fields, erpbankreceipt.FieldUpdatedByAdminID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ERPBankReceiptMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case erpbankreceipt.FieldReceivedAmount:
		return m.AddedReceivedAmount()
	case erpbankreceipt.FieldBankFee:
		return m.AddedBankFee()
	case erpbankreceipt.FieldNetAmount:
		return m.AddedNetAmount()
	case erpbankreceipt.FieldCreatedByAdminID:
		return m.AddedCreatedByAdminID()
	case erpbankreceipt.FieldUpdatedByAdminID:
		return m.AddedUpdatedByAdminID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPBankReceiptMutation) AddField(name string, value ent.Value) error {
	switch name {
	case erpbankreceipt.FieldReceivedAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReceivedAmount(v)
		return nil
	case erpbankreceipt.FieldBankFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBankFee(v)
		return nil
	case erpbankreceipt.FieldNetAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNetAmount(v)
		return nil
	case erpbankreceipt.FieldCreatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedByAdminID(v)
		return nil
	case erpbankreceipt.FieldUpdatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedByAdminID(v)
		return nil
	}
	return fmt.Errorf("unknown ERPBankReceipt numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ERPBankReceiptMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(erpbankreceipt.FieldRefNo) {
		fields = append(fields, erpbankreceipt.FieldRefNo)
	}
	if m.FieldCleared(erpbankreceipt.FieldCreatedByAdminID) {
		fields = append(fields, erpbankreceipt.FieldCreatedByAdminID)
	}
	if m.FieldCleared(erpbankreceipt.FieldUpdatedByAdminID) {
		fields = append(fields, erpbankreceipt.FieldUpdatedByAdminID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ERPBankReceiptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ERPBankReceiptMutation) ClearField(name string) error {
	switch name {
	case erpbankreceipt.FieldRefNo:
		m.ClearRefNo()
		return nil
	case erpbankreceipt.FieldCreatedByAdminID:
		m.ClearCreatedByAdminID()
		return nil
	case erpbankreceipt.FieldUpdatedByAdminID:
		m.ClearUpdatedByAdminID()
		return nil
	}
	return fmt.Errorf("unknown ERPBankReceipt nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ERPBankReceiptMutation) ResetField(name string) error {
	switch name {
	case erpbankreceipt.FieldCode:
		m.ResetCode()
		return nil
	case erpbankreceipt.FieldRegisterDate:
		m.ResetRegisterDate()
		return nil
	case erpbankreceipt.FieldFundType:
		m.ResetFundType()
		return nil
	case erpbankreceipt.FieldCurrency:
		m.ResetCurrency()
		return nil
	case erpbankreceipt.FieldReceivedAmount:
		m.ResetReceivedAmount()
		return nil
	case erpbankreceipt.FieldBankFee:
		m.ResetBankFee()
		return nil
	case erpbankreceipt.FieldNetAmount:
		m.ResetNetAmount()
		return nil
	case erpbankreceipt.FieldRefNo:
		m.ResetRefNo()
		return nil
	case erpbankreceipt.FieldStatus:
		m.ResetStatus()
		return nil
	case erpbankreceipt.FieldCreatedByAdminID:
		m.ResetCreatedByAdminID()
		return nil
	case erpbankreceipt.FieldUpdatedByAdminID:
		m.ResetUpdatedByAdminID()
		return nil
	case erpbankreceipt.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case erpbankreceipt.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPBankReceipt field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ERPBankReceiptMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ERPBankReceiptMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ERPBankReceiptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ERPBankReceiptMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ERPBankReceiptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ERPBankReceiptMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ERPBankReceiptMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ERPBankReceipt unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ERPBankReceiptMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ERPBankReceipt edge %s", name)
}

// ERPBankReceiptClaimMutation represents an operation that mutates the ERPBankReceiptClaim nodes in the graph.
type ERPBankReceiptClaimMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	receipt_id               *int
	addreceipt_id            *int
	settlement_id            *int
	addsettlement_id         *int
	claim_type               *string
	claim_amount             *float64
	addclaim_amount          *float64
	confirmed                *bool
	confirmed_at             *time.Time
	claimed_by_admin_id      *int
	addclaimed_by_admin_id   *int
	confirmed_by_admin_id    *int
	addconfirmed_by_admin_id *int
	remark                   *string
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	done                     bool
	oldValue                 func(context.Context) (*ERPBankReceiptClaim, error)
	predicates               []predicate.ERPBankReceiptClaim
}

var _ ent.Mutation = (*ERPBankReceiptClaimMutation)(nil)

// erpbankreceiptclaimOption allows management of the mutation configuration using functional options.
type erpbankreceiptclaimOption func(*ERPBankReceiptClaimMutation)

// newERPBankReceiptClaimMutation creates new mutation for the ERPBankReceiptClaim entity.
func newERPBankReceiptClaimMutation(c config, op Op, opts ...erpbankreceiptclaimOption) *ERPBankReceiptClaimMutation {
	m := &ERPBankReceiptClaimMutation{
		config:        c,
		op:            op,
		typ:           TypeERPBankReceiptClaim,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withERPBankReceiptClaimID sets the ID field of the mutation.
func withERPBankReceiptClaimID(id int) erpbankreceiptclaimOption {
	return func(m *ERPBankReceiptClaimMutation) {
		var (
			err   error
			once  sync.Once
			value *ERPBankReceiptClaim
		)
		m.oldValue = func(ctx context.Context) (*ERPBankReceiptClaim, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ERPBankReceiptClaim.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withERPBankReceiptClaim sets the old ERPBankReceiptClaim of the mutation.
func withERPBankReceiptClaim(node *ERPBankReceiptClaim) erpbankreceiptclaimOption {
	return func(m *ERPBankReceiptClaimMutation) {
		m.oldValue = func(context.Context) (*ERPBankReceiptClaim, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ERPBankReceiptClaimMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ERPBankReceiptClaimMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ERPBankReceiptClaimMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ERPBankReceiptClaimMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ERPBankReceiptClaim.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReceiptID sets the "receipt_id" field.
func (m *ERPBankReceiptClaimMutation) SetReceiptID(i int) {
	m.receipt_id = &i
	m.addreceipt_id = nil
}

// ReceiptID returns the value of the "receipt_id" field in the mutation.
func (m *ERPBankReceiptClaimMutation) ReceiptID() (r int, exists bool) {
	v := m.receipt_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiptID returns the old "receipt_id" field's value of the ERPBankReceiptClaim entity.
// If the ERPBankReceiptClaim object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPBankReceiptClaimMutation) OldReceiptID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiptID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiptID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiptID: %w", err)
	}
	return oldValue.ReceiptID, nil
}

// AddReceiptID adds i to the "receipt_id" field.
func (m *ERPBankReceiptClaimMutation) AddReceiptID(i int) {
	if m.addreceipt_id != nil {
		*m.addreceipt_id += i
	} else {
		m.addreceipt_id = &i
	}
}

// AddedReceiptID returns the value that was added to the "receipt_id" field in this mutation.
func (m *ERPBankReceiptClaimMutation) AddedReceiptID() (r int, exists bool) {
	v := m.addreceipt_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetReceiptID resets all changes to the "receipt_id" field.
func (m *ERPBankReceiptClaimMutation) ResetReceiptID() {
	m.receipt_id = nil
	m.addreceipt_id = nil
}

// SetSettlementID sets the "settlement_id" field.
func (m *ERPBankReceiptClaimMutation) SetSettlementID(i int) {
	m.settlement_id = &i
	m.addsettlement_id = nil
}

// SettlementID returns the value of the "settlement_id" field in the mutation.
func (m *ERPBankReceiptClaimMutation) SettlementID() (r int, exists bool) {
	v := m.settlement_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSettlementID returns the old "settlement_id" field's value of the ERPBankReceiptClaim entity.
// If the ERPBankReceiptClaim object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPBankReceiptClaimMutation) OldSettlementID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettlementID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettlementID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettlementID: %w", err)
	}
	return oldValue.SettlementID, nil
}

// AddSettlementID adds i to the "settlement_id" field.
func (m *ERPBankReceiptClaimMutation) AddSettlementID(i int) {
	if m.addsettlement_id != nil {
		*m.addsettlement_id += i
	} else {
		m.addsettlement_id = &i
	}
}

// AddedSettlementID returns the value that was added to the "settlement_id" field in this mutation.
func (m *ERPBankReceiptClaimMutation) AddedSettlementID() (r int, exists bool) {
	v := m.addsettlement_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearSettlementID clears the value of the "settlement_id" field.
func (m *ERPBankReceiptClaimMutation) ClearSettlementID() {
	m.settlement_id = nil
	m.addsettlement_id = nil
	m.clearedFields[erpbankreceiptclaim.FieldSettlementID] = struct{}{}
}

// SettlementIDCleared returns if the "settlement_id" field was cleared in this mutation.
func (m *ERPBankReceiptClaimMutation) SettlementIDCleared() bool {
	_, ok := m.clearedFields[erpbankreceiptclaim.FieldSettlementID]
	return ok
}

// ResetSettlementID resets all changes to the "settlement_id" field.
func (m *ERPBankReceiptClaimMutation) ResetSettlementID() {
	m.settlement_id = nil
	m.addsettlement_id = nil
	delete(m.clearedFields, erpbankreceiptclaim.FieldSettlementID)
}

// SetClaimType sets the "claim_type" field.
func (m *ERPBankReceiptClaimMutation) SetClaimType(s string) {
	m.claim_type = &s
}

// ClaimType returns the value of the "claim_type" field in the mutation.
func (m *ERPBankReceiptClaimMutation) ClaimType() (r string, exists bool) {
	v := m.claim_type
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimType returns the old "claim_type" field's value of the ERPBankReceiptClaim entity.
// If the ERPBankReceiptClaim object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPBankReceiptClaimMutation) OldClaimType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimType: %w", err)
	}
	return oldValue.ClaimType, nil
}

// ResetClaimType resets all changes to the "claim_type" field.
func (m *ERPBankReceiptClaimMutation) ResetClaimType() {
	m.claim_type = nil
}

// SetClaimAmount sets the "claim_amount" field.
func (m *ERPBankReceiptClaimMutation) SetClaimAmount(f float64) {
	m.claim_amount = &f
	m.addclaim_amount = nil
}

// ClaimAmount returns the value of the "claim_amount" field in the mutation.
func (m *ERPBankReceiptClaimMutation) ClaimAmount() (r float64, exists bool) {
	v := m.claim_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimAmount returns the old "claim_amount" field's value of the ERPBankReceiptClaim entity.
// If the ERPBankReceiptClaim object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPBankReceiptClaimMutation) OldClaimAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimAmount: %w", err)
	}
	return oldValue.ClaimAmount, nil
}

// AddClaimAmount adds f to the "claim_amount" field.
func (m *ERPBankReceiptClaimMutation) AddClaimAmount(f float64) {
	if m.addclaim_amount != nil {
		*m.addclaim_amount += f
	} else {
		m.addclaim_amount = &f
	}
}

// AddedClaimAmount returns the value that was added to the "claim_amount" field in this mutation.
func (m *ERPBankReceiptClaimMutation) AddedClaimAmount() (r float64, exists bool) {
	v := m.addclaim_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetClaimAmount resets all changes to the "claim_amount" field.
func (m *ERPBankReceiptClaimMutation) ResetClaimAmount() {
	m.claim_amount = nil
	m.addclaim_amount = nil
}

// SetConfirmed sets the "confirmed" field.
func (m *ERPBankReceiptClaimMutation) SetConfirmed(b bool) {
	m.confirmed = &b
}

// Confirmed returns the value of the "confirmed" field in the mutation.
func (m *ERPBankReceiptClaimMutation) Confirmed() (r bool, exists bool) {
	v := m.confirmed
	if v == nil {
		return
	}
	return *v, true
}

// OldConfirmed returns the old "confirmed" field's value of the ERPBankReceiptClaim entity.
// If the ERPBankReceiptClaim object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPBankReceiptClaimMutation) OldConfirmed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfirmed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfirmed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfirmed: %w", err)
	}
	return oldValue.Confirmed, nil
}

// ResetConfirmed resets all changes to the "confirmed" field.
func (m *ERPBankReceiptClaimMutation) ResetConfirmed() {
	m.confirmed = nil
}

// SetConfirmedAt sets the "confirmed_at" field.
func (m *ERPBankReceiptClaimMutation) SetConfirmedAt(t time.Time) {
	m.confirmed_at = &t
}

// ConfirmedAt returns the value of the "confirmed_at" field in the mutation.
func (m *ERPBankReceiptClaimMutation) ConfirmedAt() (r time.Time, exists bool) {
	v := m.confirmed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldConfirmedAt returns the old "confirmed_at" field's value of the ERPBankReceiptClaim entity.
// If the ERPBankReceiptClaim object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPBankReceiptClaimMutation) OldConfirmedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfirmedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfirmedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfirmedAt: %w", err)
	}
	return oldValue.ConfirmedAt, nil
}

// ClearConfirmedAt clears the value of the "confirmed_at" field.
func (m *ERPBankReceiptClaimMutation) ClearConfirmedAt() {
	m.confirmed_at = nil
	m.clearedFields[erpbankreceiptclaim.FieldConfirmedAt] = struct{}{}
}

// ConfirmedAtCleared returns if the "confirmed_at" field was cleared in this mutation.
func (m *ERPBankReceiptClaimMutation) ConfirmedAtCleared() bool {
	_, ok := m.clearedFields[erpbankreceiptclaim.FieldConfirmedAt]
	return ok
}

// ResetConfirmedAt resets all changes to the "confirmed_at" field.
func (m *ERPBankReceiptClaimMutation) ResetConfirmedAt() {
	m.confirmed_at = nil
	delete(m.clearedFields, erpbankreceiptclaim.FieldConfirmedAt)
}

// SetClaimedByAdminID sets the "claimed_by_admin_id" field.
func (m *ERPBankReceiptClaimMutation) SetClaimedByAdminID(i int) {
	m.claimed_by_admin_id = &i
	m.addclaimed_by_admin_id = nil
}

// ClaimedByAdminID returns the value of the "claimed_by_admin_id" field in the mutation.
func (m *ERPBankReceiptClaimMutation) ClaimedByAdminID() (r int, exists bool) {
	v := m.claimed_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClaimedByAdminID returns the old "claimed_by_admin_id" field's value of the ERPBankReceiptClaim entity.
// If the ERPBankReceiptClaim object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPBankReceiptClaimMutation) OldClaimedByAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaimedByAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaimedByAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaimedByAdminID: %w", err)
	}
	return oldValue.ClaimedByAdminID, nil
}

// AddClaimedByAdminID adds i to the "claimed_by_admin_id" field.
func (m *ERPBankReceiptClaimMutation) AddClaimedByAdminID(i int) {
	if m.addclaimed_by_admin_id != nil {
		*m.addclaimed_by_admin_id += i
	} else {
		m.addclaimed_by_admin_id = &i
	}
}

// AddedClaimedByAdminID returns the value that was added to the "claimed_by_admin_id" field in this mutation.
func (m *ERPBankReceiptClaimMutation) AddedClaimedByAdminID() (r int, exists bool) {
	v := m.addclaimed_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearClaimedByAdminID clears the value of the "claimed_by_admin_id" field.
func (m *ERPBankReceiptClaimMutation) ClearClaimedByAdminID() {
	m.claimed_by_admin_id = nil
	m.addclaimed_by_admin_id = nil
	m.clearedFields[erpbankreceiptclaim.FieldClaimedByAdminID] = struct{}{}
}

// ClaimedByAdminIDCleared returns if the "claimed_by_admin_id" field was cleared in this mutation.
func (m *ERPBankReceiptClaimMutation) ClaimedByAdminIDCleared() bool {
	_, ok := m.clearedFields[erpbankreceiptclaim.FieldClaimedByAdminID]
	return ok
}

// ResetClaimedByAdminID resets all changes to the "claimed_by_admin_id" field.
func (m *ERPBankReceiptClaimMutation) ResetClaimedByAdminID() {
	m.claimed_by_admin_id = nil
	m.addclaimed_by_admin_id = nil
	delete(m.clearedFields, erpbankreceiptclaim.FieldClaimedByAdminID)
}

// SetConfirmedByAdminID sets the "confirmed_by_admin_id" field.
func (m *ERPBankReceiptClaimMutation) SetConfirmedByAdminID(i int) {
	m.confirmed_by_admin_id = &i
	m.addconfirmed_by_admin_id = nil
}

// ConfirmedByAdminID returns the value of the "confirmed_by_admin_id" field in the mutation.
func (m *ERPBankReceiptClaimMutation) ConfirmedByAdminID() (r int, exists bool) {
	v := m.confirmed_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldConfirmedByAdminID returns the old "confirmed_by_admin_id" field's value of the ERPBankReceiptClaim entity.
// If the ERPBankReceiptClaim object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPBankReceiptClaimMutation) OldConfirmedByAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfirmedByAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfirmedByAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfirmedByAdminID: %w", err)
	}
	return oldValue.ConfirmedByAdminID, nil
}

// AddConfirmedByAdminID adds i to the "confirmed_by_admin_id" field.
func (m *ERPBankReceiptClaimMutation) AddConfirmedByAdminID(i int) {
	if m.addconfirmed_by_admin_id != nil {
		*m.addconfirmed_by_admin_id += i
	} else {
		m.addconfirmed_by_admin_id = &i
	}
}

// AddedConfirmedByAdminID returns the value that was added to the "confirmed_by_admin_id" field in this mutation.
func (m *ERPBankReceiptClaimMutation) AddedConfirmedByAdminID() (r int, exists bool) {
	v := m.addconfirmed_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearConfirmedByAdminID clears the value of the "confirmed_by_admin_id" field.
func (m *ERPBankReceiptClaimMutation) ClearConfirmedByAdminID() {
	m.confirmed_by_admin_id = nil
	m.addconfirmed_by_admin_id = nil
	m.clearedFields[erpbankreceiptclaim.FieldConfirmedByAdminID] = struct{}{}
}

// ConfirmedByAdminIDCleared returns if the "confirmed_by_admin_id" field was cleared in this mutation.
func (m *ERPBankReceiptClaimMutation) ConfirmedByAdminIDCleared() bool {
	_, ok := m.clearedFields[erpbankreceiptclaim.FieldConfirmedByAdminID]
	return ok
}

// ResetConfirmedByAdminID resets all changes to the "confirmed_by_admin_id" field.
func (m *ERPBankReceiptClaimMutation) ResetConfirmedByAdminID() {
	m.confirmed_by_admin_id = nil
	m.addconfirmed_by_admin_id = nil
	delete(m.clearedFields, erpbankreceiptclaim.FieldConfirmedByAdminID)
}

// SetRemark sets the "remark" field.
func (m *ERPBankReceiptClaimMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ERPBankReceiptClaimMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the ERPBankReceiptClaim entity.
// If the ERPBankReceiptClaim object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPBankReceiptClaimMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ERPBankReceiptClaimMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[erpbankreceiptclaim.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ERPBankReceiptClaimMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[erpbankreceiptclaim.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ERPBankReceiptClaimMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, erpbankreceiptclaim.FieldRemark)
}

// SetCreatedAt sets the "created_at" field.
func (m *ERPBankReceiptClaimMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ERPBankReceiptClaimMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ERPBankReceiptClaim entity.
// If the ERPBankReceiptClaim object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPBankReceiptClaimMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ERPBankReceiptClaimMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ERPBankReceiptClaimMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ERPBankReceiptClaimMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ERPBankReceiptClaim entity.
// If the ERPBankReceiptClaim object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPBankReceiptClaimMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ERPBankReceiptClaimMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ERPBankReceiptClaimMutation builder.
func (m *ERPBankReceiptClaimMutation) Where(ps ...predicate.ERPBankReceiptClaim) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ERPBankReceiptClaimMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ERPBankReceiptClaimMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ERPBankReceiptClaim, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ERPBankReceiptClaimMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ERPBankReceiptClaimMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ERPBankReceiptClaim).
func (m *ERPBankReceiptClaimMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ERPBankReceiptClaimMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.receipt_id != nil {
		fields = append(fields, erpbankreceiptclaim.FieldReceiptID)
	}
	if m.settlement_id != nil {
		fields = append(fields, erpbankreceiptclaim.FieldSettlementID)
	}
	if m.claim_type != nil {
		fields = append(fields, erpbankreceiptclaim.FieldClaimType)
	}
	if m.claim_amount != nil {
		fields = append(fields, erpbankreceiptclaim.FieldClaimAmount)
	}
	if m.confirmed != nil {
		fields = append(fields, erpbankreceiptclaim.FieldConfirmed)
	}
	if m.confirmed_at != nil {
		fields = append(fields, erpbankreceiptclaim.FieldConfirmedAt)
	}
	if m.claimed_by_admin_id != nil {
		fields = append(fields, erpbankreceiptclaim.FieldClaimedByAdminID)
	}
	if m.confirmed_by_admin_id != nil {
		fields = append(fields, erpbankreceiptclaim.FieldConfirmedByAdminID)
	}
	if m.remark != nil {
		fields = append(fields, erpbankreceiptclaim.FieldRemark)
	}
	if m.created_at != nil {
		fields = append(fields, erpbankreceiptclaim.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, erpbankreceiptclaim.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ERPBankReceiptClaimMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case erpbankreceiptclaim.FieldReceiptID:
		return m.ReceiptID()
	case erpbankreceiptclaim.FieldSettlementID:
		return m.SettlementID()
	case erpbankreceiptclaim.FieldClaimType:
		return m.ClaimType()
	case erpbankreceiptclaim.FieldClaimAmount:
		return m.ClaimAmount()
	case erpbankreceiptclaim.FieldConfirmed:
		return m.Confirmed()
	case erpbankreceiptclaim.FieldConfirmedAt:
		return m.ConfirmedAt()
	case erpbankreceiptclaim.FieldClaimedByAdminID:
		return m.ClaimedByAdminID()
	case erpbankreceiptclaim.FieldConfirmedByAdminID:
		return m.ConfirmedByAdminID()
	case erpbankreceiptclaim.FieldRemark:
		return m.Remark()
	case erpbankreceiptclaim.FieldCreatedAt:
		return m.CreatedAt()
	case erpbankreceiptclaim.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ERPBankReceiptClaimMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case erpbankreceiptclaim.FieldReceiptID:
		return m.OldReceiptID(ctx)
	case erpbankreceiptclaim.FieldSettlementID:
		return m.OldSettlementID(ctx)
	case erpbankreceiptclaim.FieldClaimType:
		return m.OldClaimType(ctx)
	case erpbankreceiptclaim.FieldClaimAmount:
		return m.OldClaimAmount(ctx)
	case erpbankreceiptclaim.FieldConfirmed:
		return m.OldConfirmed(ctx)
	case erpbankreceiptclaim.FieldConfirmedAt:
		return m.OldConfirmedAt(ctx)
	case erpbankreceiptclaim.FieldClaimedByAdminID:
		return m.OldClaimedByAdminID(ctx)
	case erpbankreceiptclaim.FieldConfirmedByAdminID:
		return m.OldConfirmedByAdminID(ctx)
	case erpbankreceiptclaim.FieldRemark:
		return m.OldRemark(ctx)
	case erpbankreceiptclaim.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case erpbankreceiptclaim.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ERPBankReceiptClaim field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPBankReceiptClaimMutation) SetField(name string, value ent.Value) error {
	switch name {
	case erpbankreceiptclaim.FieldReceiptID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiptID(v)
		return nil
	case erpbankreceiptclaim.FieldSettlementID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettlementID(v)
		return nil
	case erpbankreceiptclaim.FieldClaimType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimType(v)
		return nil
	case erpbankreceiptclaim.FieldClaimAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimAmount(v)
		return nil
	case erpbankreceiptclaim.FieldConfirmed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfirmed(v)
		return nil
	case erpbankreceiptclaim.FieldConfirmedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfirmedAt(v)
		return nil
	case erpbankreceiptclaim.FieldClaimedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaimedByAdminID(v)
		return nil
	case erpbankreceiptclaim.FieldConfirmedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfirmedByAdminID(v)
		return nil
	case erpbankreceiptclaim.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case erpbankreceiptclaim.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case erpbankreceiptclaim.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ERPBankReceiptClaim field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ERPBankReceiptClaimMutation) AddedFields() []string {
	var fields []string
	if m.addreceipt_id != nil {
		fields = append(fields, erpbankreceiptclaim.FieldReceiptID)
	}
	if m.addsettlement_id != nil {
		fields = append(fields, erpbankreceiptclaim.FieldSettlementID)
	}
	if m.addclaim_amount != nil {
		fields = append(fields, erpbankreceiptclaim.FieldClaimAmount)
	}
	if m.addclaimed_by_admin_id != nil {
		fields = append(fields, erpbankreceiptclaim.FieldClaimedByAdminID)
	}
	if m.addconfirmed_by_admin_id != nil {
		fields = append(fields, erpbankreceiptclaim.FieldConfirmedByAdminID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ERPBankReceiptClaimMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case erpbankreceiptclaim.FieldReceiptID:
		return m.AddedReceiptID()
	case erpbankreceiptclaim.FieldSettlementID:
		return m.AddedSettlementID()
	case erpbankreceiptclaim.FieldClaimAmount:
		return m.AddedClaimAmount()
	case erpbankreceiptclaim.FieldClaimedByAdminID:
		return m.AddedClaimedByAdminID()
	case erpbankreceiptclaim.FieldConfirmedByAdminID:
		return m.AddedConfirmedByAdminID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPBankReceiptClaimMutation) AddField(name string, value ent.Value) error {
	switch name {
	case erpbankreceiptclaim.FieldReceiptID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReceiptID(v)
		return nil
	case erpbankreceiptclaim.FieldSettlementID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSettlementID(v)
		return nil
	case erpbankreceiptclaim.FieldClaimAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClaimAmount(v)
		return nil
	case erpbankreceiptclaim.FieldClaimedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClaimedByAdminID(v)
		return nil
	case erpbankreceiptclaim.FieldConfirmedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConfirmedByAdminID(v)
		return nil
	}
	return fmt.Errorf("unknown ERPBankReceiptClaim numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ERPBankReceiptClaimMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(erpbankreceiptclaim.FieldSettlementID) {
		fields = append(fields, erpbankreceiptclaim.FieldSettlementID)
	}
	if m.FieldCleared(erpbankreceiptclaim.FieldConfirmedAt) {
		fields = append(fields, erpbankreceiptclaim.FieldConfirmedAt)
	}
	if m.FieldCleared(erpbankreceiptclaim.FieldClaimedByAdminID) {
		fields = append(fields, erpbankreceiptclaim.FieldClaimedByAdminID)
	}
	if m.FieldCleared(erpbankreceiptclaim.FieldConfirmedByAdminID) {
		fields = append(fields, erpbankreceiptclaim.FieldConfirmedByAdminID)
	}
	if m.FieldCleared(erpbankreceiptclaim.FieldRemark) {
		fields = append(fields, erpbankreceiptclaim.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ERPBankReceiptClaimMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ERPBankReceiptClaimMutation) ClearField(name string) error {
	switch name {
	case erpbankreceiptclaim.FieldSettlementID:
		m.ClearSettlementID()
		return nil
	case erpbankreceiptclaim.FieldConfirmedAt:
		m.ClearConfirmedAt()
		return nil
	case erpbankreceiptclaim.FieldClaimedByAdminID:
		m.ClearClaimedByAdminID()
		return nil
	case erpbankreceiptclaim.FieldConfirmedByAdminID:
		m.ClearConfirmedByAdminID()
		return nil
	case erpbankreceiptclaim.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown ERPBankReceiptClaim nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ERPBankReceiptClaimMutation) ResetField(name string) error {
	switch name {
	case erpbankreceiptclaim.FieldReceiptID:
		m.ResetReceiptID()
		return nil
	case erpbankreceiptclaim.FieldSettlementID:
		m.ResetSettlementID()
		return nil
	case erpbankreceiptclaim.FieldClaimType:
		m.ResetClaimType()
		return nil
	case erpbankreceiptclaim.FieldClaimAmount:
		m.ResetClaimAmount()
		return nil
	case erpbankreceiptclaim.FieldConfirmed:
		m.ResetConfirmed()
		return nil
	case erpbankreceiptclaim.FieldConfirmedAt:
		m.ResetConfirmedAt()
		return nil
	case erpbankreceiptclaim.FieldClaimedByAdminID:
		m.ResetClaimedByAdminID()
		return nil
	case erpbankreceiptclaim.FieldConfirmedByAdminID:
		m.ResetConfirmedByAdminID()
		return nil
	case erpbankreceiptclaim.FieldRemark:
		m.ResetRemark()
		return nil
	case erpbankreceiptclaim.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case erpbankreceiptclaim.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPBankReceiptClaim field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ERPBankReceiptClaimMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ERPBankReceiptClaimMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ERPBankReceiptClaimMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ERPBankReceiptClaimMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ERPBankReceiptClaimMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ERPBankReceiptClaimMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ERPBankReceiptClaimMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ERPBankReceiptClaim unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ERPBankReceiptClaimMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ERPBankReceiptClaim edge %s", name)
}

// ERPDocLinkMutation represents an operation that mutates the ERPDocLink nodes in the graph.
type ERPDocLinkMutation struct {
	config
	op            Op
	typ           string
	id            *int
	from_module   *string
	from_code     *string
	to_module     *string
	to_code       *string
	relation_type *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ERPDocLink, error)
	predicates    []predicate.ERPDocLink
}

var _ ent.Mutation = (*ERPDocLinkMutation)(nil)

// erpdoclinkOption allows management of the mutation configuration using functional options.
type erpdoclinkOption func(*ERPDocLinkMutation)

// newERPDocLinkMutation creates new mutation for the ERPDocLink entity.
func newERPDocLinkMutation(c config, op Op, opts ...erpdoclinkOption) *ERPDocLinkMutation {
	m := &ERPDocLinkMutation{
		config:        c,
		op:            op,
		typ:           TypeERPDocLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withERPDocLinkID sets the ID field of the mutation.
func withERPDocLinkID(id int) erpdoclinkOption {
	return func(m *ERPDocLinkMutation) {
		var (
			err   error
			once  sync.Once
			value *ERPDocLink
		)
		m.oldValue = func(ctx context.Context) (*ERPDocLink, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ERPDocLink.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withERPDocLink sets the old ERPDocLink of the mutation.
func withERPDocLink(node *ERPDocLink) erpdoclinkOption {
	return func(m *ERPDocLinkMutation) {
		m.oldValue = func(context.Context) (*ERPDocLink, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ERPDocLinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ERPDocLinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ERPDocLinkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ERPDocLinkMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ERPDocLink.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFromModule sets the "from_module" field.
func (m *ERPDocLinkMutation) SetFromModule(s string) {
	m.from_module = &s
}

// FromModule returns the value of the "from_module" field in the mutation.
func (m *ERPDocLinkMutation) FromModule() (r string, exists bool) {
	v := m.from_module
	if v == nil {
		return
	}
	return *v, true
}

// OldFromModule returns the old "from_module" field's value of the ERPDocLink entity.
// If the ERPDocLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPDocLinkMutation) OldFromModule(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromModule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromModule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromModule: %w", err)
	}
	return oldValue.FromModule, nil
}

// ResetFromModule resets all changes to the "from_module" field.
func (m *ERPDocLinkMutation) ResetFromModule() {
	m.from_module = nil
}

// SetFromCode sets the "from_code" field.
func (m *ERPDocLinkMutation) SetFromCode(s string) {
	m.from_code = &s
}

// FromCode returns the value of the "from_code" field in the mutation.
func (m *ERPDocLinkMutation) FromCode() (r string, exists bool) {
	v := m.from_code
	if v == nil {
		return
	}
	return *v, true
}

// OldFromCode returns the old "from_code" field's value of the ERPDocLink entity.
// If the ERPDocLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPDocLinkMutation) OldFromCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromCode: %w", err)
	}
	return oldValue.FromCode, nil
}

// ResetFromCode resets all changes to the "from_code" field.
func (m *ERPDocLinkMutation) ResetFromCode() {
	m.from_code = nil
}

// SetToModule sets the "to_module" field.
func (m *ERPDocLinkMutation) SetToModule(s string) {
	m.to_module = &s
}

// ToModule returns the value of the "to_module" field in the mutation.
func (m *ERPDocLinkMutation) ToModule() (r string, exists bool) {
	v := m.to_module
	if v == nil {
		return
	}
	return *v, true
}

// OldToModule returns the old "to_module" field's value of the ERPDocLink entity.
// If the ERPDocLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPDocLinkMutation) OldToModule(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToModule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToModule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToModule: %w", err)
	}
	return oldValue.ToModule, nil
}

// ResetToModule resets all changes to the "to_module" field.
func (m *ERPDocLinkMutation) ResetToModule() {
	m.to_module = nil
}

// SetToCode sets the "to_code" field.
func (m *ERPDocLinkMutation) SetToCode(s string) {
	m.to_code = &s
}

// ToCode returns the value of the "to_code" field in the mutation.
func (m *ERPDocLinkMutation) ToCode() (r string, exists bool) {
	v := m.to_code
	if v == nil {
		return
	}
	return *v, true
}

// OldToCode returns the old "to_code" field's value of the ERPDocLink entity.
// If the ERPDocLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPDocLinkMutation) OldToCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToCode: %w", err)
	}
	return oldValue.ToCode, nil
}

// ResetToCode resets all changes to the "to_code" field.
func (m *ERPDocLinkMutation) ResetToCode() {
	m.to_code = nil
}

// SetRelationType sets the "relation_type" field.
func (m *ERPDocLinkMutation) SetRelationType(s string) {
	m.relation_type = &s
}

// RelationType returns the value of the "relation_type" field in the mutation.
func (m *ERPDocLinkMutation) RelationType() (r string, exists bool) {
	v := m.relation_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationType returns the old "relation_type" field's value of the ERPDocLink entity.
// If the ERPDocLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPDocLinkMutation) OldRelationType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationType: %w", err)
	}
	return oldValue.RelationType, nil
}

// ResetRelationType resets all changes to the "relation_type" field.
func (m *ERPDocLinkMutation) ResetRelationType() {
	m.relation_type = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ERPDocLinkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ERPDocLinkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ERPDocLink entity.
// If the ERPDocLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPDocLinkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ERPDocLinkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the ERPDocLinkMutation builder.
func (m *ERPDocLinkMutation) Where(ps ...predicate.ERPDocLink) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ERPDocLinkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ERPDocLinkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ERPDocLink, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ERPDocLinkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ERPDocLinkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ERPDocLink).
func (m *ERPDocLinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ERPDocLinkMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.from_module != nil {
		fields = append(fields, erpdoclink.FieldFromModule)
	}
	if m.from_code != nil {
		fields = append(fields, erpdoclink.FieldFromCode)
	}
	if m.to_module != nil {
		fields = append(fields, erpdoclink.FieldToModule)
	}
	if m.to_code != nil {
		fields = append(fields, erpdoclink.FieldToCode)
	}
	if m.relation_type != nil {
		fields = append(fields, erpdoclink.FieldRelationType)
	}
	if m.created_at != nil {
		fields = append(fields, erpdoclink.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ERPDocLinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case erpdoclink.FieldFromModule:
		return m.FromModule()
	case erpdoclink.FieldFromCode:
		return m.FromCode()
	case erpdoclink.FieldToModule:
		return m.ToModule()
	case erpdoclink.FieldToCode:
		return m.ToCode()
	case erpdoclink.FieldRelationType:
		return m.RelationType()
	case erpdoclink.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ERPDocLinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case erpdoclink.FieldFromModule:
		return m.OldFromModule(ctx)
	case erpdoclink.FieldFromCode:
		return m.OldFromCode(ctx)
	case erpdoclink.FieldToModule:
		return m.OldToModule(ctx)
	case erpdoclink.FieldToCode:
		return m.OldToCode(ctx)
	case erpdoclink.FieldRelationType:
		return m.OldRelationType(ctx)
	case erpdoclink.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ERPDocLink field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPDocLinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case erpdoclink.FieldFromModule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromModule(v)
		return nil
	case erpdoclink.FieldFromCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromCode(v)
		return nil
	case erpdoclink.FieldToModule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToModule(v)
		return nil
	case erpdoclink.FieldToCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToCode(v)
		return nil
	case erpdoclink.FieldRelationType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationType(v)
		return nil
	case erpdoclink.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ERPDocLink field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ERPDocLinkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ERPDocLinkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPDocLinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ERPDocLink numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ERPDocLinkMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ERPDocLinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ERPDocLinkMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ERPDocLink nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ERPDocLinkMutation) ResetField(name string) error {
	switch name {
	case erpdoclink.FieldFromModule:
		m.ResetFromModule()
		return nil
	case erpdoclink.FieldFromCode:
		m.ResetFromCode()
		return nil
	case erpdoclink.FieldToModule:
		m.ResetToModule()
		return nil
	case erpdoclink.FieldToCode:
		m.ResetToCode()
		return nil
	case erpdoclink.FieldRelationType:
		m.ResetRelationType()
		return nil
	case erpdoclink.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPDocLink field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ERPDocLinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ERPDocLinkMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ERPDocLinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ERPDocLinkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ERPDocLinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ERPDocLinkMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ERPDocLinkMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ERPDocLink unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ERPDocLinkMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ERPDocLink edge %s", name)
}

// ERPExportSaleMutation represents an operation that mutates the ERPExportSale nodes in the graph.
type ERPExportSaleMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	code                   *string
	quotation_id           *int
	addquotation_id        *int
	source_quotation_code  *string
	customer_partner_id    *int
	addcustomer_partner_id *int
	customer_code          *string
	customer_contract_no   *string
	order_no               *string
	order_date             *time.Time
	sign_date              *time.Time
	delivery_date          *time.Time
	transport_type         *string
	payment_method         *string
	price_term             *string
	start_place            *string
	end_place              *string
	order_flow             *string
	total_amount           *float64
	addtotal_amount        *float64
	status                 *string
	remark                 *string
	created_by_admin_id    *int
	addcreated_by_admin_id *int
	updated_by_admin_id    *int
	addupdated_by_admin_id *int
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*ERPExportSale, error)
	predicates             []predicate.ERPExportSale
}

var _ ent.Mutation = (*ERPExportSaleMutation)(nil)

// erpexportsaleOption allows management of the mutation configuration using functional options.
type erpexportsaleOption func(*ERPExportSaleMutation)

// newERPExportSaleMutation creates new mutation for the ERPExportSale entity.
func newERPExportSaleMutation(c config, op Op, opts ...erpexportsaleOption) *ERPExportSaleMutation {
	m := &ERPExportSaleMutation{
		config:        c,
		op:            op,
		typ:           TypeERPExportSale,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withERPExportSaleID sets the ID field of the mutation.
func withERPExportSaleID(id int) erpexportsaleOption {
	return func(m *ERPExportSaleMutation) {
		var (
			err   error
			once  sync.Once
			value *ERPExportSale
		)
		m.oldValue = func(ctx context.Context) (*ERPExportSale, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ERPExportSale.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withERPExportSale sets the old ERPExportSale of the mutation.
func withERPExportSale(node *ERPExportSale) erpexportsaleOption {
	return func(m *ERPExportSaleMutation) {
		m.oldValue = func(context.Context) (*ERPExportSale, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ERPExportSaleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ERPExportSaleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ERPExportSaleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ERPExportSaleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ERPExportSale.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *ERPExportSaleMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ERPExportSaleMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the ERPExportSale entity.
// If the ERPExportSale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ERPExportSaleMutation) ResetCode() {
	m.code = nil
}

// SetQuotationID sets the "quotation_id" field.
func (m *ERPExportSaleMutation) SetQuotationID(i int) {
	m.quotation_id = &i
	m.addquotation_id = nil
}

// QuotationID returns the value of the "quotation_id" field in the mutation.
func (m *ERPExportSaleMutation) QuotationID() (r int, exists bool) {
	v := m.quotation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldQuotationID returns the old "quotation_id" field's value of the ERPExportSale entity.
// If the ERPExportSale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleMutation) OldQuotationID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuotationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuotationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuotationID: %w", err)
	}
	return oldValue.QuotationID, nil
}

// AddQuotationID adds i to the "quotation_id" field.
func (m *ERPExportSaleMutation) AddQuotationID(i int) {
	if m.addquotation_id != nil {
		*m.addquotation_id += i
	} else {
		m.addquotation_id = &i
	}
}

// AddedQuotationID returns the value that was added to the "quotation_id" field in this mutation.
func (m *ERPExportSaleMutation) AddedQuotationID() (r int, exists bool) {
	v := m.addquotation_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearQuotationID clears the value of the "quotation_id" field.
func (m *ERPExportSaleMutation) ClearQuotationID() {
	m.quotation_id = nil
	m.addquotation_id = nil
	m.clearedFields[erpexportsale.FieldQuotationID] = struct{}{}
}

// QuotationIDCleared returns if the "quotation_id" field was cleared in this mutation.
func (m *ERPExportSaleMutation) QuotationIDCleared() bool {
	_, ok := m.clearedFields[erpexportsale.FieldQuotationID]
	return ok
}

// ResetQuotationID resets all changes to the "quotation_id" field.
func (m *ERPExportSaleMutation) ResetQuotationID() {
	m.quotation_id = nil
	m.addquotation_id = nil
	delete(m.clearedFields, erpexportsale.FieldQuotationID)
}

// SetSourceQuotationCode sets the "source_quotation_code" field.
func (m *ERPExportSaleMutation) SetSourceQuotationCode(s string) {
	m.source_quotation_code = &s
}

// SourceQuotationCode returns the value of the "source_quotation_code" field in the mutation.
func (m *ERPExportSaleMutation) SourceQuotationCode() (r string, exists bool) {
	v := m.source_quotation_code
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceQuotationCode returns the old "source_quotation_code" field's value of the ERPExportSale entity.
// If the ERPExportSale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleMutation) OldSourceQuotationCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceQuotationCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceQuotationCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceQuotationCode: %w", err)
	}
	return oldValue.SourceQuotationCode, nil
}

// ClearSourceQuotationCode clears the value of the "source_quotation_code" field.
func (m *ERPExportSaleMutation) ClearSourceQuotationCode() {
	m.source_quotation_code = nil
	m.clearedFields[erpexportsale.FieldSourceQuotationCode] = struct{}{}
}

// SourceQuotationCodeCleared returns if the "source_quotation_code" field was cleared in this mutation.
func (m *ERPExportSaleMutation) SourceQuotationCodeCleared() bool {
	_, ok := m.clearedFields[erpexportsale.FieldSourceQuotationCode]
	return ok
}

// ResetSourceQuotationCode resets all changes to the "source_quotation_code" field.
func (m *ERPExportSaleMutation) ResetSourceQuotationCode() {
	m.source_quotation_code = nil
	delete(m.clearedFields, erpexportsale.FieldSourceQuotationCode)
}

// SetCustomerPartnerID sets the "customer_partner_id" field.
func (m *ERPExportSaleMutation) SetCustomerPartnerID(i int) {
	m.customer_partner_id = &i
	m.addcustomer_partner_id = nil
}

// CustomerPartnerID returns the value of the "customer_partner_id" field in the mutation.
func (m *ERPExportSaleMutation) CustomerPartnerID() (r int, exists bool) {
	v := m.customer_partner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerPartnerID returns the old "customer_partner_id" field's value of the ERPExportSale entity.
// If the ERPExportSale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleMutation) OldCustomerPartnerID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerPartnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerPartnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerPartnerID: %w", err)
	}
	return oldValue.CustomerPartnerID, nil
}

// AddCustomerPartnerID adds i to the "customer_partner_id" field.
func (m *ERPExportSaleMutation) AddCustomerPartnerID(i int) {
	if m.addcustomer_partner_id != nil {
		*m.addcustomer_partner_id += i
	} else {
		m.addcustomer_partner_id = &i
	}
}

// AddedCustomerPartnerID returns the value that was added to the "customer_partner_id" field in this mutation.
func (m *ERPExportSaleMutation) AddedCustomerPartnerID() (r int, exists bool) {
	v := m.addcustomer_partner_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCustomerPartnerID clears the value of the "customer_partner_id" field.
func (m *ERPExportSaleMutation) ClearCustomerPartnerID() {
	m.customer_partner_id = nil
	m.addcustomer_partner_id = nil
	m.clearedFields[erpexportsale.FieldCustomerPartnerID] = struct{}{}
}

// CustomerPartnerIDCleared returns if the "customer_partner_id" field was cleared in this mutation.
func (m *ERPExportSaleMutation) CustomerPartnerIDCleared() bool {
	_, ok := m.clearedFields[erpexportsale.FieldCustomerPartnerID]
	return ok
}

// ResetCustomerPartnerID resets all changes to the "customer_partner_id" field.
func (m *ERPExportSaleMutation) ResetCustomerPartnerID() {
	m.customer_partner_id = nil
	m.addcustomer_partner_id = nil
	delete(m.clearedFields, erpexportsale.FieldCustomerPartnerID)
}

// SetCustomerCode sets the "customer_code" field.
func (m *ERPExportSaleMutation) SetCustomerCode(s string) {
	m.customer_code = &s
}

// CustomerCode returns the value of the "customer_code" field in the mutation.
func (m *ERPExportSaleMutation) CustomerCode() (r string, exists bool) {
	v := m.customer_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerCode returns the old "customer_code" field's value of the ERPExportSale entity.
// If the ERPExportSale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleMutation) OldCustomerCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerCode: %w", err)
	}
	return oldValue.CustomerCode, nil
}

// ClearCustomerCode clears the value of the "customer_code" field.
func (m *ERPExportSaleMutation) ClearCustomerCode() {
	m.customer_code = nil
	m.clearedFields[erpexportsale.FieldCustomerCode] = struct{}{}
}

// CustomerCodeCleared returns if the "customer_code" field was cleared in this mutation.
func (m *ERPExportSaleMutation) CustomerCodeCleared() bool {
	_, ok := m.clearedFields[erpexportsale.FieldCustomerCode]
	return ok
}

// ResetCustomerCode resets all changes to the "customer_code" field.
func (m *ERPExportSaleMutation) ResetCustomerCode() {
	m.customer_code = nil
	delete(m.clearedFields, erpexportsale.FieldCustomerCode)
}

// SetCustomerContractNo sets the "customer_contract_no" field.
func (m *ERPExportSaleMutation) SetCustomerContractNo(s string) {
	m.customer_contract_no = &s
}

// CustomerContractNo returns the value of the "customer_contract_no" field in the mutation.
func (m *ERPExportSaleMutation) CustomerContractNo() (r string, exists bool) {
	v := m.customer_contract_no
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerContractNo returns the old "customer_contract_no" field's value of the ERPExportSale entity.
// If the ERPExportSale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleMutation) OldCustomerContractNo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerContractNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerContractNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerContractNo: %w", err)
	}
	return oldValue.CustomerContractNo, nil
}

// ClearCustomerContractNo clears the value of the "customer_contract_no" field.
func (m *ERPExportSaleMutation) ClearCustomerContractNo() {
	m.customer_contract_no = nil
	m.clearedFields[erpexportsale.FieldCustomerContractNo] = struct{}{}
}

// CustomerContractNoCleared returns if the "customer_contract_no" field was cleared in this mutation.
func (m *ERPExportSaleMutation) CustomerContractNoCleared() bool {
	_, ok := m.clearedFields[erpexportsale.FieldCustomerContractNo]
	return ok
}

// ResetCustomerContractNo resets all changes to the "customer_contract_no" field.
func (m *ERPExportSaleMutation) ResetCustomerContractNo() {
	m.customer_contract_no = nil
	delete(m.clearedFields, erpexportsale.FieldCustomerContractNo)
}

// SetOrderNo sets the "order_no" field.
func (m *ERPExportSaleMutation) SetOrderNo(s string) {
	m.order_no = &s
}

// OrderNo returns the value of the "order_no" field in the mutation.
func (m *ERPExportSaleMutation) OrderNo() (r string, exists bool) {
	v := m.order_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNo returns the old "order_no" field's value of the ERPExportSale entity.
// If the ERPExportSale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleMutation) OldOrderNo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNo: %w", err)
	}
	return oldValue.OrderNo, nil
}

// ClearOrderNo clears the value of the "order_no" field.
func (m *ERPExportSaleMutation) ClearOrderNo() {
	m.order_no = nil
	m.clearedFields[erpexportsale.FieldOrderNo] = struct{}{}
}

// OrderNoCleared returns if the "order_no" field was cleared in this mutation.
func (m *ERPExportSaleMutation) OrderNoCleared() bool {
	_, ok := m.clearedFields[erpexportsale.FieldOrderNo]
	return ok
}

// ResetOrderNo resets all changes to the "order_no" field.
func (m *ERPExportSaleMutation) ResetOrderNo() {
	m.order_no = nil
	delete(m.clearedFields, erpexportsale.FieldOrderNo)
}

// SetOrderDate sets the "order_date" field.
func (m *ERPExportSaleMutation) SetOrderDate(t time.Time) {
	m.order_date = &t
}

// OrderDate returns the value of the "order_date" field in the mutation.
func (m *ERPExportSaleMutation) OrderDate() (r time.Time, exists bool) {
	v := m.order_date
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderDate returns the old "order_date" field's value of the ERPExportSale entity.
// If the ERPExportSale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleMutation) OldOrderDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderDate: %w", err)
	}
	return oldValue.OrderDate, nil
}

// ResetOrderDate resets all changes to the "order_date" field.
func (m *ERPExportSaleMutation) ResetOrderDate() {
	m.order_date = nil
}

// SetSignDate sets the "sign_date" field.
func (m *ERPExportSaleMutation) SetSignDate(t time.Time) {
	m.sign_date = &t
}

// SignDate returns the value of the "sign_date" field in the mutation.
func (m *ERPExportSaleMutation) SignDate() (r time.Time, exists bool) {
	v := m.sign_date
	if v == nil {
		return
	}
	return *v, true
}

// OldSignDate returns the old "sign_date" field's value of the ERPExportSale entity.
// If the ERPExportSale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleMutation) OldSignDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignDate: %w", err)
	}
	return oldValue.SignDate, nil
}

// ResetSignDate resets all changes to the "sign_date" field.
func (m *ERPExportSaleMutation) ResetSignDate() {
	m.sign_date = nil
}

// SetDeliveryDate sets the "delivery_date" field.
func (m *ERPExportSaleMutation) SetDeliveryDate(t time.Time) {
	m.delivery_date = &t
}

// DeliveryDate returns the value of the "delivery_date" field in the mutation.
func (m *ERPExportSaleMutation) DeliveryDate() (r time.Time, exists bool) {
	v := m.delivery_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryDate returns the old "delivery_date" field's value of the ERPExportSale entity.
// If the ERPExportSale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleMutation) OldDeliveryDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryDate: %w", err)
	}
	return oldValue.DeliveryDate, nil
}

// ResetDeliveryDate resets all changes to the "delivery_date" field.
func (m *ERPExportSaleMutation) ResetDeliveryDate() {
	m.delivery_date = nil
}

// SetTransportType sets the "transport_type" field.
func (m *ERPExportSaleMutation) SetTransportType(s string) {
	m.transport_type = &s
}

// TransportType returns the value of the "transport_type" field in the mutation.
func (m *ERPExportSaleMutation) TransportType() (r string, exists bool) {
	v := m.transport_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTransportType returns the old "transport_type" field's value of the ERPExportSale entity.
// If the ERPExportSale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleMutation) OldTransportType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransportType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransportType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransportType: %w", err)
	}
	return oldValue.TransportType, nil
}

// ClearTransportType clears the value of the "transport_type" field.
func (m *ERPExportSaleMutation) ClearTransportType() {
	m.transport_type = nil
	m.clearedFields[erpexportsale.FieldTransportType] = struct{}{}
}

// TransportTypeCleared returns if the "transport_type" field was cleared in this mutation.
func (m *ERPExportSaleMutation) TransportTypeCleared() bool {
	_, ok := m.clearedFields[erpexportsale.FieldTransportType]
	return ok
}

// ResetTransportType resets all changes to the "transport_type" field.
func (m *ERPExportSaleMutation) ResetTransportType() {
	m.transport_type = nil
	delete(m.clearedFields, erpexportsale.FieldTransportType)
}

// SetPaymentMethod sets the "payment_method" field.
func (m *ERPExportSaleMutation) SetPaymentMethod(s string) {
	m.payment_method = &s
}

// PaymentMethod returns the value of the "payment_method" field in the mutation.
func (m *ERPExportSaleMutation) PaymentMethod() (r string, exists bool) {
	v := m.payment_method
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentMethod returns the old "payment_method" field's value of the ERPExportSale entity.
// If the ERPExportSale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleMutation) OldPaymentMethod(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentMethod: %w", err)
	}
	return oldValue.PaymentMethod, nil
}

// ClearPaymentMethod clears the value of the "payment_method" field.
func (m *ERPExportSaleMutation) ClearPaymentMethod() {
	m.payment_method = nil
	m.clearedFields[erpexportsale.FieldPaymentMethod] = struct{}{}
}

// PaymentMethodCleared returns if the "payment_method" field was cleared in this mutation.
func (m *ERPExportSaleMutation) PaymentMethodCleared() bool {
	_, ok := m.clearedFields[erpexportsale.FieldPaymentMethod]
	return ok
}

// ResetPaymentMethod resets all changes to the "payment_method" field.
func (m *ERPExportSaleMutation) ResetPaymentMethod() {
	m.payment_method = nil
	delete(m.clearedFields, erpexportsale.FieldPaymentMethod)
}

// SetPriceTerm sets the "price_term" field.
func (m *ERPExportSaleMutation) SetPriceTerm(s string) {
	m.price_term = &s
}

// PriceTerm returns the value of the "price_term" field in the mutation.
func (m *ERPExportSaleMutation) PriceTerm() (r string, exists bool) {
	v := m.price_term
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceTerm returns the old "price_term" field's value of the ERPExportSale entity.
// If the ERPExportSale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleMutation) OldPriceTerm(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriceTerm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriceTerm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceTerm: %w", err)
	}
	return oldValue.PriceTerm, nil
}

// ClearPriceTerm clears the value of the "price_term" field.
func (m *ERPExportSaleMutation) ClearPriceTerm() {
	m.price_term = nil
	m.clearedFields[erpexportsale.FieldPriceTerm] = struct{}{}
}

// PriceTermCleared returns if the "price_term" field was cleared in this mutation.
func (m *ERPExportSaleMutation) PriceTermCleared() bool {
	_, ok := m.clearedFields[erpexportsale.FieldPriceTerm]
	return ok
}

// ResetPriceTerm resets all changes to the "price_term" field.
func (m *ERPExportSaleMutation) ResetPriceTerm() {
	m.price_term = nil
	delete(m.clearedFields, erpexportsale.FieldPriceTerm)
}

// SetStartPlace sets the "start_place" field.
func (m *ERPExportSaleMutation) SetStartPlace(s string) {
	m.start_place = &s
}

// StartPlace returns the value of the "start_place" field in the mutation.
func (m *ERPExportSaleMutation) StartPlace() (r string, exists bool) {
	v := m.start_place
	if v == nil {
		return
	}
	return *v, true
}

// OldStartPlace returns the old "start_place" field's value of the ERPExportSale entity.
// If the ERPExportSale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleMutation) OldStartPlace(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartPlace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartPlace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartPlace: %w", err)
	}
	return oldValue.StartPlace, nil
}

// ClearStartPlace clears the value of the "start_place" field.
func (m *ERPExportSaleMutation) ClearStartPlace() {
	m.start_place = nil
	m.clearedFields[erpexportsale.FieldStartPlace] = struct{}{}
}

// StartPlaceCleared returns if the "start_place" field was cleared in this mutation.
func (m *ERPExportSaleMutation) StartPlaceCleared() bool {
	_, ok := m.clearedFields[erpexportsale.FieldStartPlace]
	return ok
}

// ResetStartPlace resets all changes to the "start_place" field.
func (m *ERPExportSaleMutation) ResetStartPlace() {
	m.start_place = nil
	delete(m.clearedFields, erpexportsale.FieldStartPlace)
}

// SetEndPlace sets the "end_place" field.
func (m *ERPExportSaleMutation) SetEndPlace(s string) {
	m.end_place = &s
}

// EndPlace returns the value of the "end_place" field in the mutation.
func (m *ERPExportSaleMutation) EndPlace() (r string, exists bool) {
	v := m.end_place
	if v == nil {
		return
	}
	return *v, true
}

// OldEndPlace returns the old "end_place" field's value of the ERPExportSale entity.
// If the ERPExportSale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleMutation) OldEndPlace(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndPlace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndPlace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndPlace: %w", err)
	}
	return oldValue.EndPlace, nil
}

// ClearEndPlace clears the value of the "end_place" field.
func (m *ERPExportSaleMutation) ClearEndPlace() {
	m.end_place = nil
	m.clearedFields[erpexportsale.FieldEndPlace] = struct{}{}
}

// EndPlaceCleared returns if the "end_place" field was cleared in this mutation.
func (m *ERPExportSaleMutation) EndPlaceCleared() bool {
	_, ok := m.clearedFields[erpexportsale.FieldEndPlace]
	return ok
}

// ResetEndPlace resets all changes to the "end_place" field.
func (m *ERPExportSaleMutation) ResetEndPlace() {
	m.end_place = nil
	delete(m.clearedFields, erpexportsale.FieldEndPlace)
}

// SetOrderFlow sets the "order_flow" field.
func (m *ERPExportSaleMutation) SetOrderFlow(s string) {
	m.order_flow = &s
}

// OrderFlow returns the value of the "order_flow" field in the mutation.
func (m *ERPExportSaleMutation) OrderFlow() (r string, exists bool) {
	v := m.order_flow
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderFlow returns the old "order_flow" field's value of the ERPExportSale entity.
// If the ERPExportSale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleMutation) OldOrderFlow(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderFlow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderFlow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderFlow: %w", err)
	}
	return oldValue.OrderFlow, nil
}

// ClearOrderFlow clears the value of the "order_flow" field.
func (m *ERPExportSaleMutation) ClearOrderFlow() {
	m.order_flow = nil
	m.clearedFields[erpexportsale.FieldOrderFlow] = struct{}{}
}

// OrderFlowCleared returns if the "order_flow" field was cleared in this mutation.
func (m *ERPExportSaleMutation) OrderFlowCleared() bool {
	_, ok := m.clearedFields[erpexportsale.FieldOrderFlow]
	return ok
}

// ResetOrderFlow resets all changes to the "order_flow" field.
func (m *ERPExportSaleMutation) ResetOrderFlow() {
	m.order_flow = nil
	delete(m.clearedFields, erpexportsale.FieldOrderFlow)
}

// SetTotalAmount sets the "total_amount" field.
func (m *ERPExportSaleMutation) SetTotalAmount(f float64) {
	m.total_amount = &f
	m.addtotal_amount = nil
}

// TotalAmount returns the value of the "total_amount" field in the mutation.
func (m *ERPExportSaleMutation) TotalAmount() (r float64, exists bool) {
	v := m.total_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAmount returns the old "total_amount" field's value of the ERPExportSale entity.
// If the ERPExportSale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleMutation) OldTotalAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAmount: %w", err)
	}
	return oldValue.TotalAmount, nil
}

// AddTotalAmount adds f to the "total_amount" field.
func (m *ERPExportSaleMutation) AddTotalAmount(f float64) {
	if m.addtotal_amount != nil {
		*m.addtotal_amount += f
	} else {
		m.addtotal_amount = &f
	}
}

// AddedTotalAmount returns the value that was added to the "total_amount" field in this mutation.
func (m *ERPExportSaleMutation) AddedTotalAmount() (r float64, exists bool) {
	v := m.addtotal_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalAmount resets all changes to the "total_amount" field.
func (m *ERPExportSaleMutation) ResetTotalAmount() {
	m.total_amount = nil
	m.addtotal_amount = nil
}

// SetStatus sets the "status" field.
func (m *ERPExportSaleMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ERPExportSaleMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ERPExportSale entity.
// If the ERPExportSale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ERPExportSaleMutation) ResetStatus() {
	m.status = nil
}

// SetRemark sets the "remark" field.
func (m *ERPExportSaleMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ERPExportSaleMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the ERPExportSale entity.
// If the ERPExportSale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ERPExportSaleMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[erpexportsale.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ERPExportSaleMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[erpexportsale.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ERPExportSaleMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, erpexportsale.FieldRemark)
}

// SetCreatedByAdminID sets the "created_by_admin_id" field.
func (m *ERPExportSaleMutation) SetCreatedByAdminID(i int) {
	m.created_by_admin_id = &i
	m.addcreated_by_admin_id = nil
}

// CreatedByAdminID returns the value of the "created_by_admin_id" field in the mutation.
func (m *ERPExportSaleMutation) CreatedByAdminID() (r int, exists bool) {
	v := m.created_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedByAdminID returns the old "created_by_admin_id" field's value of the ERPExportSale entity.
// If the ERPExportSale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleMutation) OldCreatedByAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedByAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedByAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedByAdminID: %w", err)
	}
	return oldValue.CreatedByAdminID, nil
}

// AddCreatedByAdminID adds i to the "created_by_admin_id" field.
func (m *ERPExportSaleMutation) AddCreatedByAdminID(i int) {
	if m.addcreated_by_admin_id != nil {
		*m.addcreated_by_admin_id += i
	} else {
		m.addcreated_by_admin_id = &i
	}
}

// AddedCreatedByAdminID returns the value that was added to the "created_by_admin_id" field in this mutation.
func (m *ERPExportSaleMutation) AddedCreatedByAdminID() (r int, exists bool) {
	v := m.addcreated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedByAdminID clears the value of the "created_by_admin_id" field.
func (m *ERPExportSaleMutation) ClearCreatedByAdminID() {
	m.created_by_admin_id = nil
	m.addcreated_by_admin_id = nil
	m.clearedFields[erpexportsale.FieldCreatedByAdminID] = struct{}{}
}

// CreatedByAdminIDCleared returns if the "created_by_admin_id" field was cleared in this mutation.
func (m *ERPExportSaleMutation) CreatedByAdminIDCleared() bool {
	_, ok := m.clearedFields[erpexportsale.FieldCreatedByAdminID]
	return ok
}

// ResetCreatedByAdminID resets all changes to the "created_by_admin_id" field.
func (m *ERPExportSaleMutation) ResetCreatedByAdminID() {
	m.created_by_admin_id = nil
	m.addcreated_by_admin_id = nil
	delete(m.clearedFields, erpexportsale.FieldCreatedByAdminID)
}

// SetUpdatedByAdminID sets the "updated_by_admin_id" field.
func (m *ERPExportSaleMutation) SetUpdatedByAdminID(i int) {
	m.updated_by_admin_id = &i
	m.addupdated_by_admin_id = nil
}

// UpdatedByAdminID returns the value of the "updated_by_admin_id" field in the mutation.
func (m *ERPExportSaleMutation) UpdatedByAdminID() (r int, exists bool) {
	v := m.updated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedByAdminID returns the old "updated_by_admin_id" field's value of the ERPExportSale entity.
// If the ERPExportSale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleMutation) OldUpdatedByAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedByAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedByAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedByAdminID: %w", err)
	}
	return oldValue.UpdatedByAdminID, nil
}

// AddUpdatedByAdminID adds i to the "updated_by_admin_id" field.
func (m *ERPExportSaleMutation) AddUpdatedByAdminID(i int) {
	if m.addupdated_by_admin_id != nil {
		*m.addupdated_by_admin_id += i
	} else {
		m.addupdated_by_admin_id = &i
	}
}

// AddedUpdatedByAdminID returns the value that was added to the "updated_by_admin_id" field in this mutation.
func (m *ERPExportSaleMutation) AddedUpdatedByAdminID() (r int, exists bool) {
	v := m.addupdated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedByAdminID clears the value of the "updated_by_admin_id" field.
func (m *ERPExportSaleMutation) ClearUpdatedByAdminID() {
	m.updated_by_admin_id = nil
	m.addupdated_by_admin_id = nil
	m.clearedFields[erpexportsale.FieldUpdatedByAdminID] = struct{}{}
}

// UpdatedByAdminIDCleared returns if the "updated_by_admin_id" field was cleared in this mutation.
func (m *ERPExportSaleMutation) UpdatedByAdminIDCleared() bool {
	_, ok := m.clearedFields[erpexportsale.FieldUpdatedByAdminID]
	return ok
}

// ResetUpdatedByAdminID resets all changes to the "updated_by_admin_id" field.
func (m *ERPExportSaleMutation) ResetUpdatedByAdminID() {
	m.updated_by_admin_id = nil
	m.addupdated_by_admin_id = nil
	delete(m.clearedFields, erpexportsale.FieldUpdatedByAdminID)
}

// SetCreatedAt sets the "created_at" field.
func (m *ERPExportSaleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ERPExportSaleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ERPExportSale entity.
// If the ERPExportSale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ERPExportSaleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ERPExportSaleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ERPExportSaleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ERPExportSale entity.
// If the ERPExportSale object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ERPExportSaleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ERPExportSaleMutation builder.
func (m *ERPExportSaleMutation) Where(ps ...predicate.ERPExportSale) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ERPExportSaleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ERPExportSaleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ERPExportSale, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ERPExportSaleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ERPExportSaleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ERPExportSale).
func (m *ERPExportSaleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ERPExportSaleMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.code != nil {
		fields = append(fields, erpexportsale.FieldCode)
	}
	if m.quotation_id != nil {
		fields = append(fields, erpexportsale.FieldQuotationID)
	}
	if m.source_quotation_code != nil {
		fields = append(fields, erpexportsale.FieldSourceQuotationCode)
	}
	if m.customer_partner_id != nil {
		fields = append(fields, erpexportsale.FieldCustomerPartnerID)
	}
	if m.customer_code != nil {
		fields = append(fields, erpexportsale.FieldCustomerCode)
	}
	if m.customer_contract_no != nil {
		fields = append(fields, erpexportsale.FieldCustomerContractNo)
	}
	if m.order_no != nil {
		fields = append(fields, erpexportsale.FieldOrderNo)
	}
	if m.order_date != nil {
		fields = append(fields, erpexportsale.FieldOrderDate)
	}
	if m.sign_date != nil {
		fields = append(fields, erpexportsale.FieldSignDate)
	}
	if m.delivery_date != nil {
		fields = append(fields, erpexportsale.FieldDeliveryDate)
	}
	if m.transport_type != nil {
		fields = append(fields, erpexportsale.FieldTransportType)
	}
	if m.payment_method != nil {
		fields = append(fields, erpexportsale.FieldPaymentMethod)
	}
	if m.price_term != nil {
		fields = append(fields, erpexportsale.FieldPriceTerm)
	}
	if m.start_place != nil {
		fields = append(fields, erpexportsale.FieldStartPlace)
	}
	if m.end_place != nil {
		fields = append(fields, erpexportsale.FieldEndPlace)
	}
	if m.order_flow != nil {
		fields = append(fields, erpexportsale.FieldOrderFlow)
	}
	if m.total_amount != nil {
		fields = append(fields, erpexportsale.FieldTotalAmount)
	}
	if m.status != nil {
		fields = append(fields, erpexportsale.FieldStatus)
	}
	if m.remark != nil {
		fields = append(fields, erpexportsale.FieldRemark)
	}
	if m.created_by_admin_id != nil {
		fields = append(fields, erpexportsale.FieldCreatedByAdminID)
	}
	if m.updated_by_admin_id != nil {
		fields = append(fields, erpexportsale.FieldUpdatedByAdminID)
	}
	if m.created_at != nil {
		fields = append(fields, erpexportsale.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, erpexportsale.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ERPExportSaleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case erpexportsale.FieldCode:
		return m.Code()
	case erpexportsale.FieldQuotationID:
		return m.QuotationID()
	case erpexportsale.FieldSourceQuotationCode:
		return m.SourceQuotationCode()
	case erpexportsale.FieldCustomerPartnerID:
		return m.CustomerPartnerID()
	case erpexportsale.FieldCustomerCode:
		return m.CustomerCode()
	case erpexportsale.FieldCustomerContractNo:
		return m.CustomerContractNo()
	case erpexportsale.FieldOrderNo:
		return m.OrderNo()
	case erpexportsale.FieldOrderDate:
		return m.OrderDate()
	case erpexportsale.FieldSignDate:
		return m.SignDate()
	case erpexportsale.FieldDeliveryDate:
		return m.DeliveryDate()
	case erpexportsale.FieldTransportType:
		return m.TransportType()
	case erpexportsale.FieldPaymentMethod:
		return m.PaymentMethod()
	case erpexportsale.FieldPriceTerm:
		return m.PriceTerm()
	case erpexportsale.FieldStartPlace:
		return m.StartPlace()
	case erpexportsale.FieldEndPlace:
		return m.EndPlace()
	case erpexportsale.FieldOrderFlow:
		return m.OrderFlow()
	case erpexportsale.FieldTotalAmount:
		return m.TotalAmount()
	case erpexportsale.FieldStatus:
		return m.Status()
	case erpexportsale.FieldRemark:
		return m.Remark()
	case erpexportsale.FieldCreatedByAdminID:
		return m.CreatedByAdminID()
	case erpexportsale.FieldUpdatedByAdminID:
		return m.UpdatedByAdminID()
	case erpexportsale.FieldCreatedAt:
		return m.CreatedAt()
	case erpexportsale.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ERPExportSaleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case erpexportsale.FieldCode:
		return m.OldCode(ctx)
	case erpexportsale.FieldQuotationID:
		return m.OldQuotationID(ctx)
	case erpexportsale.FieldSourceQuotationCode:
		return m.OldSourceQuotationCode(ctx)
	case erpexportsale.FieldCustomerPartnerID:
		return m.OldCustomerPartnerID(ctx)
	case erpexportsale.FieldCustomerCode:
		return m.OldCustomerCode(ctx)
	case erpexportsale.FieldCustomerContractNo:
		return m.OldCustomerContractNo(ctx)
	case erpexportsale.FieldOrderNo:
		return m.OldOrderNo(ctx)
	case erpexportsale.FieldOrderDate:
		return m.OldOrderDate(ctx)
	case erpexportsale.FieldSignDate:
		return m.OldSignDate(ctx)
	case erpexportsale.FieldDeliveryDate:
		return m.OldDeliveryDate(ctx)
	case erpexportsale.FieldTransportType:
		return m.OldTransportType(ctx)
	case erpexportsale.FieldPaymentMethod:
		return m.OldPaymentMethod(ctx)
	case erpexportsale.FieldPriceTerm:
		return m.OldPriceTerm(ctx)
	case erpexportsale.FieldStartPlace:
		return m.OldStartPlace(ctx)
	case erpexportsale.FieldEndPlace:
		return m.OldEndPlace(ctx)
	case erpexportsale.FieldOrderFlow:
		return m.OldOrderFlow(ctx)
	case erpexportsale.FieldTotalAmount:
		return m.OldTotalAmount(ctx)
	case erpexportsale.FieldStatus:
		return m.OldStatus(ctx)
	case erpexportsale.FieldRemark:
		return m.OldRemark(ctx)
	case erpexportsale.FieldCreatedByAdminID:
		return m.OldCreatedByAdminID(ctx)
	case erpexportsale.FieldUpdatedByAdminID:
		return m.OldUpdatedByAdminID(ctx)
	case erpexportsale.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case erpexportsale.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ERPExportSale field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPExportSaleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case erpexportsale.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case erpexportsale.FieldQuotationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuotationID(v)
		return nil
	case erpexportsale.FieldSourceQuotationCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceQuotationCode(v)
		return nil
	case erpexportsale.FieldCustomerPartnerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerPartnerID(v)
		return nil
	case erpexportsale.FieldCustomerCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerCode(v)
		return nil
	case erpexportsale.FieldCustomerContractNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerContractNo(v)
		return nil
	case erpexportsale.FieldOrderNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNo(v)
		return nil
	case erpexportsale.FieldOrderDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderDate(v)
		return nil
	case erpexportsale.FieldSignDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignDate(v)
		return nil
	case erpexportsale.FieldDeliveryDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryDate(v)
		return nil
	case erpexportsale.FieldTransportType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransportType(v)
		return nil
	case erpexportsale.FieldPaymentMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentMethod(v)
		return nil
	case erpexportsale.FieldPriceTerm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceTerm(v)
		return nil
	case erpexportsale.FieldStartPlace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartPlace(v)
		return nil
	case erpexportsale.FieldEndPlace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndPlace(v)
		return nil
	case erpexportsale.FieldOrderFlow:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderFlow(v)
		return nil
	case erpexportsale.FieldTotalAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAmount(v)
		return nil
	case erpexportsale.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case erpexportsale.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case erpexportsale.FieldCreatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedByAdminID(v)
		return nil
	case erpexportsale.FieldUpdatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedByAdminID(v)
		return nil
	case erpexportsale.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case erpexportsale.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ERPExportSale field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ERPExportSaleMutation) AddedFields() []string {
	var fields []string
	if m.addquotation_id != nil {
		fields = append(fields, erpexportsale.FieldQuotationID)
	}
	if m.addcustomer_partner_id != nil {
		fields = append(fields, erpexportsale.FieldCustomerPartnerID)
	}
	if m.addtotal_amount != nil {
		fields = append(fields, erpexportsale.FieldTotalAmount)
	}
	if m.addcreated_by_admin_id != nil {
		fields = append(fields, erpexportsale.FieldCreatedByAdminID)
	}
	if m.addupdated_by_admin_id != nil {
		fields = append(fields, erpexportsale.FieldUpdatedByAdminID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ERPExportSaleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case erpexportsale.FieldQuotationID:
		return m.AddedQuotationID()
	case erpexportsale.FieldCustomerPartnerID:
		return m.AddedCustomerPartnerID()
	case erpexportsale.FieldTotalAmount:
		return m.AddedTotalAmount()
	case erpexportsale.FieldCreatedByAdminID:
		return m.AddedCreatedByAdminID()
	case erpexportsale.FieldUpdatedByAdminID:
		return m.AddedUpdatedByAdminID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPExportSaleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case erpexportsale.FieldQuotationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuotationID(v)
		return nil
	case erpexportsale.FieldCustomerPartnerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCustomerPartnerID(v)
		return nil
	case erpexportsale.FieldTotalAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalAmount(v)
		return nil
	case erpexportsale.FieldCreatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedByAdminID(v)
		return nil
	case erpexportsale.FieldUpdatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedByAdminID(v)
		return nil
	}
	return fmt.Errorf("unknown ERPExportSale numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ERPExportSaleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(erpexportsale.FieldQuotationID) {
		fields = append(fields, erpexportsale.FieldQuotationID)
	}
	if m.FieldCleared(erpexportsale.FieldSourceQuotationCode) {
		fields = append(fields, erpexportsale.FieldSourceQuotationCode)
	}
	if m.FieldCleared(erpexportsale.FieldCustomerPartnerID) {
		fields = append(fields, erpexportsale.FieldCustomerPartnerID)
	}
	if m.FieldCleared(erpexportsale.FieldCustomerCode) {
		fields = append(fields, erpexportsale.FieldCustomerCode)
	}
	if m.FieldCleared(erpexportsale.FieldCustomerContractNo) {
		fields = append(fields, erpexportsale.FieldCustomerContractNo)
	}
	if m.FieldCleared(erpexportsale.FieldOrderNo) {
		fields = append(fields, erpexportsale.FieldOrderNo)
	}
	if m.FieldCleared(erpexportsale.FieldTransportType) {
		fields = append(fields, erpexportsale.FieldTransportType)
	}
	if m.FieldCleared(erpexportsale.FieldPaymentMethod) {
		fields = append(fields, erpexportsale.FieldPaymentMethod)
	}
	if m.FieldCleared(erpexportsale.FieldPriceTerm) {
		fields = append(fields, erpexportsale.FieldPriceTerm)
	}
	if m.FieldCleared(erpexportsale.FieldStartPlace) {
		fields = append(fields, erpexportsale.FieldStartPlace)
	}
	if m.FieldCleared(erpexportsale.FieldEndPlace) {
		fields = append(fields, erpexportsale.FieldEndPlace)
	}
	if m.FieldCleared(erpexportsale.FieldOrderFlow) {
		fields = append(fields, erpexportsale.FieldOrderFlow)
	}
	if m.FieldCleared(erpexportsale.FieldRemark) {
		fields = append(fields, erpexportsale.FieldRemark)
	}
	if m.FieldCleared(erpexportsale.FieldCreatedByAdminID) {
		fields = append(fields, erpexportsale.FieldCreatedByAdminID)
	}
	if m.FieldCleared(erpexportsale.FieldUpdatedByAdminID) {
		fields = append(fields, erpexportsale.FieldUpdatedByAdminID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ERPExportSaleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ERPExportSaleMutation) ClearField(name string) error {
	switch name {
	case erpexportsale.FieldQuotationID:
		m.ClearQuotationID()
		return nil
	case erpexportsale.FieldSourceQuotationCode:
		m.ClearSourceQuotationCode()
		return nil
	case erpexportsale.FieldCustomerPartnerID:
		m.ClearCustomerPartnerID()
		return nil
	case erpexportsale.FieldCustomerCode:
		m.ClearCustomerCode()
		return nil
	case erpexportsale.FieldCustomerContractNo:
		m.ClearCustomerContractNo()
		return nil
	case erpexportsale.FieldOrderNo:
		m.ClearOrderNo()
		return nil
	case erpexportsale.FieldTransportType:
		m.ClearTransportType()
		return nil
	case erpexportsale.FieldPaymentMethod:
		m.ClearPaymentMethod()
		return nil
	case erpexportsale.FieldPriceTerm:
		m.ClearPriceTerm()
		return nil
	case erpexportsale.FieldStartPlace:
		m.ClearStartPlace()
		return nil
	case erpexportsale.FieldEndPlace:
		m.ClearEndPlace()
		return nil
	case erpexportsale.FieldOrderFlow:
		m.ClearOrderFlow()
		return nil
	case erpexportsale.FieldRemark:
		m.ClearRemark()
		return nil
	case erpexportsale.FieldCreatedByAdminID:
		m.ClearCreatedByAdminID()
		return nil
	case erpexportsale.FieldUpdatedByAdminID:
		m.ClearUpdatedByAdminID()
		return nil
	}
	return fmt.Errorf("unknown ERPExportSale nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ERPExportSaleMutation) ResetField(name string) error {
	switch name {
	case erpexportsale.FieldCode:
		m.ResetCode()
		return nil
	case erpexportsale.FieldQuotationID:
		m.ResetQuotationID()
		return nil
	case erpexportsale.FieldSourceQuotationCode:
		m.ResetSourceQuotationCode()
		return nil
	case erpexportsale.FieldCustomerPartnerID:
		m.ResetCustomerPartnerID()
		return nil
	case erpexportsale.FieldCustomerCode:
		m.ResetCustomerCode()
		return nil
	case erpexportsale.FieldCustomerContractNo:
		m.ResetCustomerContractNo()
		return nil
	case erpexportsale.FieldOrderNo:
		m.ResetOrderNo()
		return nil
	case erpexportsale.FieldOrderDate:
		m.ResetOrderDate()
		return nil
	case erpexportsale.FieldSignDate:
		m.ResetSignDate()
		return nil
	case erpexportsale.FieldDeliveryDate:
		m.ResetDeliveryDate()
		return nil
	case erpexportsale.FieldTransportType:
		m.ResetTransportType()
		return nil
	case erpexportsale.FieldPaymentMethod:
		m.ResetPaymentMethod()
		return nil
	case erpexportsale.FieldPriceTerm:
		m.ResetPriceTerm()
		return nil
	case erpexportsale.FieldStartPlace:
		m.ResetStartPlace()
		return nil
	case erpexportsale.FieldEndPlace:
		m.ResetEndPlace()
		return nil
	case erpexportsale.FieldOrderFlow:
		m.ResetOrderFlow()
		return nil
	case erpexportsale.FieldTotalAmount:
		m.ResetTotalAmount()
		return nil
	case erpexportsale.FieldStatus:
		m.ResetStatus()
		return nil
	case erpexportsale.FieldRemark:
		m.ResetRemark()
		return nil
	case erpexportsale.FieldCreatedByAdminID:
		m.ResetCreatedByAdminID()
		return nil
	case erpexportsale.FieldUpdatedByAdminID:
		m.ResetUpdatedByAdminID()
		return nil
	case erpexportsale.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case erpexportsale.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPExportSale field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ERPExportSaleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ERPExportSaleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ERPExportSaleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ERPExportSaleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ERPExportSaleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ERPExportSaleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ERPExportSaleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ERPExportSale unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ERPExportSaleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ERPExportSale edge %s", name)
}

// ERPExportSaleItemMutation represents an operation that mutates the ERPExportSaleItem nodes in the graph.
type ERPExportSaleItemMutation struct {
	config
	op                Op
	typ               string
	id                *int
	export_sale_id    *int
	addexport_sale_id *int
	line_no           *int
	addline_no        *int
	product_id        *int
	addproduct_id     *int
	product_code      *string
	product_name      *string
	cn_desc           *string
	en_desc           *string
	quantity          *float64
	addquantity       *float64
	unit_price        *float64
	addunit_price     *float64
	total_price       *float64
	addtotal_price    *float64
	pack_detail       *string
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*ERPExportSaleItem, error)
	predicates        []predicate.ERPExportSaleItem
}

var _ ent.Mutation = (*ERPExportSaleItemMutation)(nil)

// erpexportsaleitemOption allows management of the mutation configuration using functional options.
type erpexportsaleitemOption func(*ERPExportSaleItemMutation)

// newERPExportSaleItemMutation creates new mutation for the ERPExportSaleItem entity.
func newERPExportSaleItemMutation(c config, op Op, opts ...erpexportsaleitemOption) *ERPExportSaleItemMutation {
	m := &ERPExportSaleItemMutation{
		config:        c,
		op:            op,
		typ:           TypeERPExportSaleItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withERPExportSaleItemID sets the ID field of the mutation.
func withERPExportSaleItemID(id int) erpexportsaleitemOption {
	return func(m *ERPExportSaleItemMutation) {
		var (
			err   error
			once  sync.Once
			value *ERPExportSaleItem
		)
		m.oldValue = func(ctx context.Context) (*ERPExportSaleItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ERPExportSaleItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withERPExportSaleItem sets the old ERPExportSaleItem of the mutation.
func withERPExportSaleItem(node *ERPExportSaleItem) erpexportsaleitemOption {
	return func(m *ERPExportSaleItemMutation) {
		m.oldValue = func(context.Context) (*ERPExportSaleItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ERPExportSaleItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ERPExportSaleItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ERPExportSaleItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ERPExportSaleItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ERPExportSaleItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExportSaleID sets the "export_sale_id" field.
func (m *ERPExportSaleItemMutation) SetExportSaleID(i int) {
	m.export_sale_id = &i
	m.addexport_sale_id = nil
}

// ExportSaleID returns the value of the "export_sale_id" field in the mutation.
func (m *ERPExportSaleItemMutation) ExportSaleID() (r int, exists bool) {
	v := m.export_sale_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExportSaleID returns the old "export_sale_id" field's value of the ERPExportSaleItem entity.
// If the ERPExportSaleItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleItemMutation) OldExportSaleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExportSaleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExportSaleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExportSaleID: %w", err)
	}
	return oldValue.ExportSaleID, nil
}

// AddExportSaleID adds i to the "export_sale_id" field.
func (m *ERPExportSaleItemMutation) AddExportSaleID(i int) {
	if m.addexport_sale_id != nil {
		*m.addexport_sale_id += i
	} else {
		m.addexport_sale_id = &i
	}
}

// AddedExportSaleID returns the value that was added to the "export_sale_id" field in this mutation.
func (m *ERPExportSaleItemMutation) AddedExportSaleID() (r int, exists bool) {
	v := m.addexport_sale_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetExportSaleID resets all changes to the "export_sale_id" field.
func (m *ERPExportSaleItemMutation) ResetExportSaleID() {
	m.export_sale_id = nil
	m.addexport_sale_id = nil
}

// SetLineNo sets the "line_no" field.
func (m *ERPExportSaleItemMutation) SetLineNo(i int) {
	m.line_no = &i
	m.addline_no = nil
}

// LineNo returns the value of the "line_no" field in the mutation.
func (m *ERPExportSaleItemMutation) LineNo() (r int, exists bool) {
	v := m.line_no
	if v == nil {
		return
	}
	return *v, true
}

// OldLineNo returns the old "line_no" field's value of the ERPExportSaleItem entity.
// If the ERPExportSaleItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleItemMutation) OldLineNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLineNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLineNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLineNo: %w", err)
	}
	return oldValue.LineNo, nil
}

// AddLineNo adds i to the "line_no" field.
func (m *ERPExportSaleItemMutation) AddLineNo(i int) {
	if m.addline_no != nil {
		*m.addline_no += i
	} else {
		m.addline_no = &i
	}
}

// AddedLineNo returns the value that was added to the "line_no" field in this mutation.
func (m *ERPExportSaleItemMutation) AddedLineNo() (r int, exists bool) {
	v := m.addline_no
	if v == nil {
		return
	}
	return *v, true
}

// ResetLineNo resets all changes to the "line_no" field.
func (m *ERPExportSaleItemMutation) ResetLineNo() {
	m.line_no = nil
	m.addline_no = nil
}

// SetProductID sets the "product_id" field.
func (m *ERPExportSaleItemMutation) SetProductID(i int) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ERPExportSaleItemMutation) ProductID() (r int, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the ERPExportSaleItem entity.
// If the ERPExportSaleItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleItemMutation) OldProductID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *ERPExportSaleItemMutation) AddProductID(i int) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *ERPExportSaleItemMutation) AddedProductID() (r int, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductID clears the value of the "product_id" field.
func (m *ERPExportSaleItemMutation) ClearProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	m.clearedFields[erpexportsaleitem.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *ERPExportSaleItemMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[erpexportsaleitem.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ERPExportSaleItemMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	delete(m.clearedFields, erpexportsaleitem.FieldProductID)
}

// SetProductCode sets the "product_code" field.
func (m *ERPExportSaleItemMutation) SetProductCode(s string) {
	m.product_code = &s
}

// ProductCode returns the value of the "product_code" field in the mutation.
func (m *ERPExportSaleItemMutation) ProductCode() (r string, exists bool) {
	v := m.product_code
	if v == nil {
		return
	}
	return *v, true
}

// OldProductCode returns the old "product_code" field's value of the ERPExportSaleItem entity.
// If the ERPExportSaleItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleItemMutation) OldProductCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductCode: %w", err)
	}
	return oldValue.ProductCode, nil
}

// ClearProductCode clears the value of the "product_code" field.
func (m *ERPExportSaleItemMutation) ClearProductCode() {
	m.product_code = nil
	m.clearedFields[erpexportsaleitem.FieldProductCode] = struct{}{}
}

// ProductCodeCleared returns if the "product_code" field was cleared in this mutation.
func (m *ERPExportSaleItemMutation) ProductCodeCleared() bool {
	_, ok := m.clearedFields[erpexportsaleitem.FieldProductCode]
	return ok
}

// ResetProductCode resets all changes to the "product_code" field.
func (m *ERPExportSaleItemMutation) ResetProductCode() {
	m.product_code = nil
	delete(m.clearedFields, erpexportsaleitem.FieldProductCode)
}

// SetProductName sets the "product_name" field.
func (m *ERPExportSaleItemMutation) SetProductName(s string) {
	m.product_name = &s
}

// ProductName returns the value of the "product_name" field in the mutation.
func (m *ERPExportSaleItemMutation) ProductName() (r string, exists bool) {
	v := m.product_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProductName returns the old "product_name" field's value of the ERPExportSaleItem entity.
// If the ERPExportSaleItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleItemMutation) OldProductName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductName: %w", err)
	}
	return oldValue.ProductName, nil
}

// ClearProductName clears the value of the "product_name" field.
func (m *ERPExportSaleItemMutation) ClearProductName() {
	m.product_name = nil
	m.clearedFields[erpexportsaleitem.FieldProductName] = struct{}{}
}

// ProductNameCleared returns if the "product_name" field was cleared in this mutation.
func (m *ERPExportSaleItemMutation) ProductNameCleared() bool {
	_, ok := m.clearedFields[erpexportsaleitem.FieldProductName]
	return ok
}

// ResetProductName resets all changes to the "product_name" field.
func (m *ERPExportSaleItemMutation) ResetProductName() {
	m.product_name = nil
	delete(m.clearedFields, erpexportsaleitem.FieldProductName)
}

// SetCnDesc sets the "cn_desc" field.
func (m *ERPExportSaleItemMutation) SetCnDesc(s string) {
	m.cn_desc = &s
}

// CnDesc returns the value of the "cn_desc" field in the mutation.
func (m *ERPExportSaleItemMutation) CnDesc() (r string, exists bool) {
	v := m.cn_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldCnDesc returns the old "cn_desc" field's value of the ERPExportSaleItem entity.
// If the ERPExportSaleItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleItemMutation) OldCnDesc(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCnDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCnDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCnDesc: %w", err)
	}
	return oldValue.CnDesc, nil
}

// ClearCnDesc clears the value of the "cn_desc" field.
func (m *ERPExportSaleItemMutation) ClearCnDesc() {
	m.cn_desc = nil
	m.clearedFields[erpexportsaleitem.FieldCnDesc] = struct{}{}
}

// CnDescCleared returns if the "cn_desc" field was cleared in this mutation.
func (m *ERPExportSaleItemMutation) CnDescCleared() bool {
	_, ok := m.clearedFields[erpexportsaleitem.FieldCnDesc]
	return ok
}

// ResetCnDesc resets all changes to the "cn_desc" field.
func (m *ERPExportSaleItemMutation) ResetCnDesc() {
	m.cn_desc = nil
	delete(m.clearedFields, erpexportsaleitem.FieldCnDesc)
}

// SetEnDesc sets the "en_desc" field.
func (m *ERPExportSaleItemMutation) SetEnDesc(s string) {
	m.en_desc = &s
}

// EnDesc returns the value of the "en_desc" field in the mutation.
func (m *ERPExportSaleItemMutation) EnDesc() (r string, exists bool) {
	v := m.en_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldEnDesc returns the old "en_desc" field's value of the ERPExportSaleItem entity.
// If the ERPExportSaleItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleItemMutation) OldEnDesc(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnDesc: %w", err)
	}
	return oldValue.EnDesc, nil
}

// ClearEnDesc clears the value of the "en_desc" field.
func (m *ERPExportSaleItemMutation) ClearEnDesc() {
	m.en_desc = nil
	m.clearedFields[erpexportsaleitem.FieldEnDesc] = struct{}{}
}

// EnDescCleared returns if the "en_desc" field was cleared in this mutation.
func (m *ERPExportSaleItemMutation) EnDescCleared() bool {
	_, ok := m.clearedFields[erpexportsaleitem.FieldEnDesc]
	return ok
}

// ResetEnDesc resets all changes to the "en_desc" field.
func (m *ERPExportSaleItemMutation) ResetEnDesc() {
	m.en_desc = nil
	delete(m.clearedFields, erpexportsaleitem.FieldEnDesc)
}

// SetQuantity sets the "quantity" field.
func (m *ERPExportSaleItemMutation) SetQuantity(f float64) {
	m.quantity = &f
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *ERPExportSaleItemMutation) Quantity() (r float64, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the ERPExportSaleItem entity.
// If the ERPExportSaleItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleItemMutation) OldQuantity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds f to the "quantity" field.
func (m *ERPExportSaleItemMutation) AddQuantity(f float64) {
	if m.addquantity != nil {
		*m.addquantity += f
	} else {
		m.addquantity = &f
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *ERPExportSaleItemMutation) AddedQuantity() (r float64, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *ERPExportSaleItemMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetUnitPrice sets the "unit_price" field.
func (m *ERPExportSaleItemMutation) SetUnitPrice(f float64) {
	m.unit_price = &f
	m.addunit_price = nil
}

// UnitPrice returns the value of the "unit_price" field in the mutation.
func (m *ERPExportSaleItemMutation) UnitPrice() (r float64, exists bool) {
	v := m.unit_price
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitPrice returns the old "unit_price" field's value of the ERPExportSaleItem entity.
// If the ERPExportSaleItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleItemMutation) OldUnitPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitPrice: %w", err)
	}
	return oldValue.UnitPrice, nil
}

// AddUnitPrice adds f to the "unit_price" field.
func (m *ERPExportSaleItemMutation) AddUnitPrice(f float64) {
	if m.addunit_price != nil {
		*m.addunit_price += f
	} else {
		m.addunit_price = &f
	}
}

// AddedUnitPrice returns the value that was added to the "unit_price" field in this mutation.
func (m *ERPExportSaleItemMutation) AddedUnitPrice() (r float64, exists bool) {
	v := m.addunit_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnitPrice resets all changes to the "unit_price" field.
func (m *ERPExportSaleItemMutation) ResetUnitPrice() {
	m.unit_price = nil
	m.addunit_price = nil
}

// SetTotalPrice sets the "total_price" field.
func (m *ERPExportSaleItemMutation) SetTotalPrice(f float64) {
	m.total_price = &f
	m.addtotal_price = nil
}

// TotalPrice returns the value of the "total_price" field in the mutation.
func (m *ERPExportSaleItemMutation) TotalPrice() (r float64, exists bool) {
	v := m.total_price
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalPrice returns the old "total_price" field's value of the ERPExportSaleItem entity.
// If the ERPExportSaleItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleItemMutation) OldTotalPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalPrice: %w", err)
	}
	return oldValue.TotalPrice, nil
}

// AddTotalPrice adds f to the "total_price" field.
func (m *ERPExportSaleItemMutation) AddTotalPrice(f float64) {
	if m.addtotal_price != nil {
		*m.addtotal_price += f
	} else {
		m.addtotal_price = &f
	}
}

// AddedTotalPrice returns the value that was added to the "total_price" field in this mutation.
func (m *ERPExportSaleItemMutation) AddedTotalPrice() (r float64, exists bool) {
	v := m.addtotal_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalPrice resets all changes to the "total_price" field.
func (m *ERPExportSaleItemMutation) ResetTotalPrice() {
	m.total_price = nil
	m.addtotal_price = nil
}

// SetPackDetail sets the "pack_detail" field.
func (m *ERPExportSaleItemMutation) SetPackDetail(s string) {
	m.pack_detail = &s
}

// PackDetail returns the value of the "pack_detail" field in the mutation.
func (m *ERPExportSaleItemMutation) PackDetail() (r string, exists bool) {
	v := m.pack_detail
	if v == nil {
		return
	}
	return *v, true
}

// OldPackDetail returns the old "pack_detail" field's value of the ERPExportSaleItem entity.
// If the ERPExportSaleItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleItemMutation) OldPackDetail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackDetail: %w", err)
	}
	return oldValue.PackDetail, nil
}

// ClearPackDetail clears the value of the "pack_detail" field.
func (m *ERPExportSaleItemMutation) ClearPackDetail() {
	m.pack_detail = nil
	m.clearedFields[erpexportsaleitem.FieldPackDetail] = struct{}{}
}

// PackDetailCleared returns if the "pack_detail" field was cleared in this mutation.
func (m *ERPExportSaleItemMutation) PackDetailCleared() bool {
	_, ok := m.clearedFields[erpexportsaleitem.FieldPackDetail]
	return ok
}

// ResetPackDetail resets all changes to the "pack_detail" field.
func (m *ERPExportSaleItemMutation) ResetPackDetail() {
	m.pack_detail = nil
	delete(m.clearedFields, erpexportsaleitem.FieldPackDetail)
}

// SetCreatedAt sets the "created_at" field.
func (m *ERPExportSaleItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ERPExportSaleItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ERPExportSaleItem entity.
// If the ERPExportSaleItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ERPExportSaleItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ERPExportSaleItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ERPExportSaleItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ERPExportSaleItem entity.
// If the ERPExportSaleItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPExportSaleItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ERPExportSaleItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ERPExportSaleItemMutation builder.
func (m *ERPExportSaleItemMutation) Where(ps ...predicate.ERPExportSaleItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ERPExportSaleItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ERPExportSaleItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ERPExportSaleItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ERPExportSaleItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ERPExportSaleItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ERPExportSaleItem).
func (m *ERPExportSaleItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ERPExportSaleItemMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.export_sale_id != nil {
		fields = append(fields, erpexportsaleitem.FieldExportSaleID)
	}
	if m.line_no != nil {
		fields = append(fields, erpexportsaleitem.FieldLineNo)
	}
	if m.product_id != nil {
		fields = append(fields, erpexportsaleitem.FieldProductID)
	}
	if m.product_code != nil {
		fields = append(fields, erpexportsaleitem.FieldProductCode)
	}
	if m.product_name != nil {
		fields = append(fields, erpexportsaleitem.FieldProductName)
	}
	if m.cn_desc != nil {
		fields = append(fields, erpexportsaleitem.FieldCnDesc)
	}
	if m.en_desc != nil {
		fields = append(fields, erpexportsaleitem.FieldEnDesc)
	}
	if m.quantity != nil {
		fields = append(fields, erpexportsaleitem.FieldQuantity)
	}
	if m.unit_price != nil {
		fields = append(fields, erpexportsaleitem.FieldUnitPrice)
	}
	if m.total_price != nil {
		fields = append(fields, erpexportsaleitem.FieldTotalPrice)
	}
	if m.pack_detail != nil {
		fields = append(fields, erpexportsaleitem.FieldPackDetail)
	}
	if m.created_at != nil {
		fields = append(fields, erpexportsaleitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, erpexportsaleitem.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ERPExportSaleItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case erpexportsaleitem.FieldExportSaleID:
		return m.ExportSaleID()
	case erpexportsaleitem.FieldLineNo:
		return m.LineNo()
	case erpexportsaleitem.FieldProductID:
		return m.ProductID()
	case erpexportsaleitem.FieldProductCode:
		return m.ProductCode()
	case erpexportsaleitem.FieldProductName:
		return m.ProductName()
	case erpexportsaleitem.FieldCnDesc:
		return m.CnDesc()
	case erpexportsaleitem.FieldEnDesc:
		return m.EnDesc()
	case erpexportsaleitem.FieldQuantity:
		return m.Quantity()
	case erpexportsaleitem.FieldUnitPrice:
		return m.UnitPrice()
	case erpexportsaleitem.FieldTotalPrice:
		return m.TotalPrice()
	case erpexportsaleitem.FieldPackDetail:
		return m.PackDetail()
	case erpexportsaleitem.FieldCreatedAt:
		return m.CreatedAt()
	case erpexportsaleitem.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ERPExportSaleItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case erpexportsaleitem.FieldExportSaleID:
		return m.OldExportSaleID(ctx)
	case erpexportsaleitem.FieldLineNo:
		return m.OldLineNo(ctx)
	case erpexportsaleitem.FieldProductID:
		return m.OldProductID(ctx)
	case erpexportsaleitem.FieldProductCode:
		return m.OldProductCode(ctx)
	case erpexportsaleitem.FieldProductName:
		return m.OldProductName(ctx)
	case erpexportsaleitem.FieldCnDesc:
		return m.OldCnDesc(ctx)
	case erpexportsaleitem.FieldEnDesc:
		return m.OldEnDesc(ctx)
	case erpexportsaleitem.FieldQuantity:
		return m.OldQuantity(ctx)
	case erpexportsaleitem.FieldUnitPrice:
		return m.OldUnitPrice(ctx)
	case erpexportsaleitem.FieldTotalPrice:
		return m.OldTotalPrice(ctx)
	case erpexportsaleitem.FieldPackDetail:
		return m.OldPackDetail(ctx)
	case erpexportsaleitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case erpexportsaleitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ERPExportSaleItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPExportSaleItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case erpexportsaleitem.FieldExportSaleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExportSaleID(v)
		return nil
	case erpexportsaleitem.FieldLineNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLineNo(v)
		return nil
	case erpexportsaleitem.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case erpexportsaleitem.FieldProductCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductCode(v)
		return nil
	case erpexportsaleitem.FieldProductName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductName(v)
		return nil
	case erpexportsaleitem.FieldCnDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCnDesc(v)
		return nil
	case erpexportsaleitem.FieldEnDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnDesc(v)
		return nil
	case erpexportsaleitem.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case erpexportsaleitem.FieldUnitPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitPrice(v)
		return nil
	case erpexportsaleitem.FieldTotalPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalPrice(v)
		return nil
	case erpexportsaleitem.FieldPackDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackDetail(v)
		return nil
	case erpexportsaleitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case erpexportsaleitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ERPExportSaleItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ERPExportSaleItemMutation) AddedFields() []string {
	var fields []string
	if m.addexport_sale_id != nil {
		fields = append(fields, erpexportsaleitem.FieldExportSaleID)
	}
	if m.addline_no != nil {
		fields = append(fields, erpexportsaleitem.FieldLineNo)
	}
	if m.addproduct_id != nil {
		fields = append(fields, erpexportsaleitem.FieldProductID)
	}
	if m.addquantity != nil {
		fields = append(fields, erpexportsaleitem.FieldQuantity)
	}
	if m.addunit_price != nil {
		fields = append(fields, erpexportsaleitem.FieldUnitPrice)
	}
	if m.addtotal_price != nil {
		fields = append(fields, erpexportsaleitem.FieldTotalPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ERPExportSaleItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case erpexportsaleitem.FieldExportSaleID:
		return m.AddedExportSaleID()
	case erpexportsaleitem.FieldLineNo:
		return m.AddedLineNo()
	case erpexportsaleitem.FieldProductID:
		return m.AddedProductID()
	case erpexportsaleitem.FieldQuantity:
		return m.AddedQuantity()
	case erpexportsaleitem.FieldUnitPrice:
		return m.AddedUnitPrice()
	case erpexportsaleitem.FieldTotalPrice:
		return m.AddedTotalPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPExportSaleItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case erpexportsaleitem.FieldExportSaleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExportSaleID(v)
		return nil
	case erpexportsaleitem.FieldLineNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLineNo(v)
		return nil
	case erpexportsaleitem.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case erpexportsaleitem.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case erpexportsaleitem.FieldUnitPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitPrice(v)
		return nil
	case erpexportsaleitem.FieldTotalPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalPrice(v)
		return nil
	}
	return fmt.Errorf("unknown ERPExportSaleItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ERPExportSaleItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(erpexportsaleitem.FieldProductID) {
		fields = append(fields, erpexportsaleitem.FieldProductID)
	}
	if m.FieldCleared(erpexportsaleitem.FieldProductCode) {
		fields = append(fields, erpexportsaleitem.FieldProductCode)
	}
	if m.FieldCleared(erpexportsaleitem.FieldProductName) {
		fields = append(fields, erpexportsaleitem.FieldProductName)
	}
	if m.FieldCleared(erpexportsaleitem.FieldCnDesc) {
		fields = append(fields, erpexportsaleitem.FieldCnDesc)
	}
	if m.FieldCleared(erpexportsaleitem.FieldEnDesc) {
		fields = append(fields, erpexportsaleitem.FieldEnDesc)
	}
	if m.FieldCleared(erpexportsaleitem.FieldPackDetail) {
		fields = append(fields, erpexportsaleitem.FieldPackDetail)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ERPExportSaleItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ERPExportSaleItemMutation) ClearField(name string) error {
	switch name {
	case erpexportsaleitem.FieldProductID:
		m.ClearProductID()
		return nil
	case erpexportsaleitem.FieldProductCode:
		m.ClearProductCode()
		return nil
	case erpexportsaleitem.FieldProductName:
		m.ClearProductName()
		return nil
	case erpexportsaleitem.FieldCnDesc:
		m.ClearCnDesc()
		return nil
	case erpexportsaleitem.FieldEnDesc:
		m.ClearEnDesc()
		return nil
	case erpexportsaleitem.FieldPackDetail:
		m.ClearPackDetail()
		return nil
	}
	return fmt.Errorf("unknown ERPExportSaleItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ERPExportSaleItemMutation) ResetField(name string) error {
	switch name {
	case erpexportsaleitem.FieldExportSaleID:
		m.ResetExportSaleID()
		return nil
	case erpexportsaleitem.FieldLineNo:
		m.ResetLineNo()
		return nil
	case erpexportsaleitem.FieldProductID:
		m.ResetProductID()
		return nil
	case erpexportsaleitem.FieldProductCode:
		m.ResetProductCode()
		return nil
	case erpexportsaleitem.FieldProductName:
		m.ResetProductName()
		return nil
	case erpexportsaleitem.FieldCnDesc:
		m.ResetCnDesc()
		return nil
	case erpexportsaleitem.FieldEnDesc:
		m.ResetEnDesc()
		return nil
	case erpexportsaleitem.FieldQuantity:
		m.ResetQuantity()
		return nil
	case erpexportsaleitem.FieldUnitPrice:
		m.ResetUnitPrice()
		return nil
	case erpexportsaleitem.FieldTotalPrice:
		m.ResetTotalPrice()
		return nil
	case erpexportsaleitem.FieldPackDetail:
		m.ResetPackDetail()
		return nil
	case erpexportsaleitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case erpexportsaleitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPExportSaleItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ERPExportSaleItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ERPExportSaleItemMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ERPExportSaleItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ERPExportSaleItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ERPExportSaleItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ERPExportSaleItemMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ERPExportSaleItemMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ERPExportSaleItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ERPExportSaleItemMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ERPExportSaleItem edge %s", name)
}

// ERPInboundNoticeMutation represents an operation that mutates the ERPInboundNotice nodes in the graph.
type ERPInboundNoticeMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	code                    *string
	purchase_contract_id    *int
	addpurchase_contract_id *int
	source_purchase_code    *string
	entry_no                *string
	warehouse_id            *int
	addwarehouse_id         *int
	location_id             *int
	addlocation_id          *int
	qc_status               *string
	inbound_status          *string
	allow_inbound_at        *time.Time
	remark                  *string
	created_by_admin_id     *int
	addcreated_by_admin_id  *int
	updated_by_admin_id     *int
	addupdated_by_admin_id  *int
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*ERPInboundNotice, error)
	predicates              []predicate.ERPInboundNotice
}

var _ ent.Mutation = (*ERPInboundNoticeMutation)(nil)

// erpinboundnoticeOption allows management of the mutation configuration using functional options.
type erpinboundnoticeOption func(*ERPInboundNoticeMutation)

// newERPInboundNoticeMutation creates new mutation for the ERPInboundNotice entity.
func newERPInboundNoticeMutation(c config, op Op, opts ...erpinboundnoticeOption) *ERPInboundNoticeMutation {
	m := &ERPInboundNoticeMutation{
		config:        c,
		op:            op,
		typ:           TypeERPInboundNotice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withERPInboundNoticeID sets the ID field of the mutation.
func withERPInboundNoticeID(id int) erpinboundnoticeOption {
	return func(m *ERPInboundNoticeMutation) {
		var (
			err   error
			once  sync.Once
			value *ERPInboundNotice
		)
		m.oldValue = func(ctx context.Context) (*ERPInboundNotice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ERPInboundNotice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withERPInboundNotice sets the old ERPInboundNotice of the mutation.
func withERPInboundNotice(node *ERPInboundNotice) erpinboundnoticeOption {
	return func(m *ERPInboundNoticeMutation) {
		m.oldValue = func(context.Context) (*ERPInboundNotice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ERPInboundNoticeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ERPInboundNoticeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ERPInboundNoticeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ERPInboundNoticeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ERPInboundNotice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *ERPInboundNoticeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ERPInboundNoticeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the ERPInboundNotice entity.
// If the ERPInboundNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPInboundNoticeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ERPInboundNoticeMutation) ResetCode() {
	m.code = nil
}

// SetPurchaseContractID sets the "purchase_contract_id" field.
func (m *ERPInboundNoticeMutation) SetPurchaseContractID(i int) {
	m.purchase_contract_id = &i
	m.addpurchase_contract_id = nil
}

// PurchaseContractID returns the value of the "purchase_contract_id" field in the mutation.
func (m *ERPInboundNoticeMutation) PurchaseContractID() (r int, exists bool) {
	v := m.purchase_contract_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchaseContractID returns the old "purchase_contract_id" field's value of the ERPInboundNotice entity.
// If the ERPInboundNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPInboundNoticeMutation) OldPurchaseContractID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchaseContractID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchaseContractID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchaseContractID: %w", err)
	}
	return oldValue.PurchaseContractID, nil
}

// AddPurchaseContractID adds i to the "purchase_contract_id" field.
func (m *ERPInboundNoticeMutation) AddPurchaseContractID(i int) {
	if m.addpurchase_contract_id != nil {
		*m.addpurchase_contract_id += i
	} else {
		m.addpurchase_contract_id = &i
	}
}

// AddedPurchaseContractID returns the value that was added to the "purchase_contract_id" field in this mutation.
func (m *ERPInboundNoticeMutation) AddedPurchaseContractID() (r int, exists bool) {
	v := m.addpurchase_contract_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPurchaseContractID clears the value of the "purchase_contract_id" field.
func (m *ERPInboundNoticeMutation) ClearPurchaseContractID() {
	m.purchase_contract_id = nil
	m.addpurchase_contract_id = nil
	m.clearedFields[erpinboundnotice.FieldPurchaseContractID] = struct{}{}
}

// PurchaseContractIDCleared returns if the "purchase_contract_id" field was cleared in this mutation.
func (m *ERPInboundNoticeMutation) PurchaseContractIDCleared() bool {
	_, ok := m.clearedFields[erpinboundnotice.FieldPurchaseContractID]
	return ok
}

// ResetPurchaseContractID resets all changes to the "purchase_contract_id" field.
func (m *ERPInboundNoticeMutation) ResetPurchaseContractID() {
	m.purchase_contract_id = nil
	m.addpurchase_contract_id = nil
	delete(m.clearedFields, erpinboundnotice.FieldPurchaseContractID)
}

// SetSourcePurchaseCode sets the "source_purchase_code" field.
func (m *ERPInboundNoticeMutation) SetSourcePurchaseCode(s string) {
	m.source_purchase_code = &s
}

// SourcePurchaseCode returns the value of the "source_purchase_code" field in the mutation.
func (m *ERPInboundNoticeMutation) SourcePurchaseCode() (r string, exists bool) {
	v := m.source_purchase_code
	if v == nil {
		return
	}
	return *v, true
}

// OldSourcePurchaseCode returns the old "source_purchase_code" field's value of the ERPInboundNotice entity.
// If the ERPInboundNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPInboundNoticeMutation) OldSourcePurchaseCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourcePurchaseCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourcePurchaseCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourcePurchaseCode: %w", err)
	}
	return oldValue.SourcePurchaseCode, nil
}

// ClearSourcePurchaseCode clears the value of the "source_purchase_code" field.
func (m *ERPInboundNoticeMutation) ClearSourcePurchaseCode() {
	m.source_purchase_code = nil
	m.clearedFields[erpinboundnotice.FieldSourcePurchaseCode] = struct{}{}
}

// SourcePurchaseCodeCleared returns if the "source_purchase_code" field was cleared in this mutation.
func (m *ERPInboundNoticeMutation) SourcePurchaseCodeCleared() bool {
	_, ok := m.clearedFields[erpinboundnotice.FieldSourcePurchaseCode]
	return ok
}

// ResetSourcePurchaseCode resets all changes to the "source_purchase_code" field.
func (m *ERPInboundNoticeMutation) ResetSourcePurchaseCode() {
	m.source_purchase_code = nil
	delete(m.clearedFields, erpinboundnotice.FieldSourcePurchaseCode)
}

// SetEntryNo sets the "entry_no" field.
func (m *ERPInboundNoticeMutation) SetEntryNo(s string) {
	m.entry_no = &s
}

// EntryNo returns the value of the "entry_no" field in the mutation.
func (m *ERPInboundNoticeMutation) EntryNo() (r string, exists bool) {
	v := m.entry_no
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryNo returns the old "entry_no" field's value of the ERPInboundNotice entity.
// If the ERPInboundNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPInboundNoticeMutation) OldEntryNo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryNo: %w", err)
	}
	return oldValue.EntryNo, nil
}

// ClearEntryNo clears the value of the "entry_no" field.
func (m *ERPInboundNoticeMutation) ClearEntryNo() {
	m.entry_no = nil
	m.clearedFields[erpinboundnotice.FieldEntryNo] = struct{}{}
}

// EntryNoCleared returns if the "entry_no" field was cleared in this mutation.
func (m *ERPInboundNoticeMutation) EntryNoCleared() bool {
	_, ok := m.clearedFields[erpinboundnotice.FieldEntryNo]
	return ok
}

// ResetEntryNo resets all changes to the "entry_no" field.
func (m *ERPInboundNoticeMutation) ResetEntryNo() {
	m.entry_no = nil
	delete(m.clearedFields, erpinboundnotice.FieldEntryNo)
}

// SetWarehouseID sets the "warehouse_id" field.
func (m *ERPInboundNoticeMutation) SetWarehouseID(i int) {
	m.warehouse_id = &i
	m.addwarehouse_id = nil
}

// WarehouseID returns the value of the "warehouse_id" field in the mutation.
func (m *ERPInboundNoticeMutation) WarehouseID() (r int, exists bool) {
	v := m.warehouse_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWarehouseID returns the old "warehouse_id" field's value of the ERPInboundNotice entity.
// If the ERPInboundNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPInboundNoticeMutation) OldWarehouseID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWarehouseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWarehouseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWarehouseID: %w", err)
	}
	return oldValue.WarehouseID, nil
}

// AddWarehouseID adds i to the "warehouse_id" field.
func (m *ERPInboundNoticeMutation) AddWarehouseID(i int) {
	if m.addwarehouse_id != nil {
		*m.addwarehouse_id += i
	} else {
		m.addwarehouse_id = &i
	}
}

// AddedWarehouseID returns the value that was added to the "warehouse_id" field in this mutation.
func (m *ERPInboundNoticeMutation) AddedWarehouseID() (r int, exists bool) {
	v := m.addwarehouse_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearWarehouseID clears the value of the "warehouse_id" field.
func (m *ERPInboundNoticeMutation) ClearWarehouseID() {
	m.warehouse_id = nil
	m.addwarehouse_id = nil
	m.clearedFields[erpinboundnotice.FieldWarehouseID] = struct{}{}
}

// WarehouseIDCleared returns if the "warehouse_id" field was cleared in this mutation.
func (m *ERPInboundNoticeMutation) WarehouseIDCleared() bool {
	_, ok := m.clearedFields[erpinboundnotice.FieldWarehouseID]
	return ok
}

// ResetWarehouseID resets all changes to the "warehouse_id" field.
func (m *ERPInboundNoticeMutation) ResetWarehouseID() {
	m.warehouse_id = nil
	m.addwarehouse_id = nil
	delete(m.clearedFields, erpinboundnotice.FieldWarehouseID)
}

// SetLocationID sets the "location_id" field.
func (m *ERPInboundNoticeMutation) SetLocationID(i int) {
	m.location_id = &i
	m.addlocation_id = nil
}

// LocationID returns the value of the "location_id" field in the mutation.
func (m *ERPInboundNoticeMutation) LocationID() (r int, exists bool) {
	v := m.location_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationID returns the old "location_id" field's value of the ERPInboundNotice entity.
// If the ERPInboundNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPInboundNoticeMutation) OldLocationID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationID: %w", err)
	}
	return oldValue.LocationID, nil
}

// AddLocationID adds i to the "location_id" field.
func (m *ERPInboundNoticeMutation) AddLocationID(i int) {
	if m.addlocation_id != nil {
		*m.addlocation_id += i
	} else {
		m.addlocation_id = &i
	}
}

// AddedLocationID returns the value that was added to the "location_id" field in this mutation.
func (m *ERPInboundNoticeMutation) AddedLocationID() (r int, exists bool) {
	v := m.addlocation_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearLocationID clears the value of the "location_id" field.
func (m *ERPInboundNoticeMutation) ClearLocationID() {
	m.location_id = nil
	m.addlocation_id = nil
	m.clearedFields[erpinboundnotice.FieldLocationID] = struct{}{}
}

// LocationIDCleared returns if the "location_id" field was cleared in this mutation.
func (m *ERPInboundNoticeMutation) LocationIDCleared() bool {
	_, ok := m.clearedFields[erpinboundnotice.FieldLocationID]
	return ok
}

// ResetLocationID resets all changes to the "location_id" field.
func (m *ERPInboundNoticeMutation) ResetLocationID() {
	m.location_id = nil
	m.addlocation_id = nil
	delete(m.clearedFields, erpinboundnotice.FieldLocationID)
}

// SetQcStatus sets the "qc_status" field.
func (m *ERPInboundNoticeMutation) SetQcStatus(s string) {
	m.qc_status = &s
}

// QcStatus returns the value of the "qc_status" field in the mutation.
func (m *ERPInboundNoticeMutation) QcStatus() (r string, exists bool) {
	v := m.qc_status
	if v == nil {
		return
	}
	return *v, true
}

// OldQcStatus returns the old "qc_status" field's value of the ERPInboundNotice entity.
// If the ERPInboundNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPInboundNoticeMutation) OldQcStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQcStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQcStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQcStatus: %w", err)
	}
	return oldValue.QcStatus, nil
}

// ResetQcStatus resets all changes to the "qc_status" field.
func (m *ERPInboundNoticeMutation) ResetQcStatus() {
	m.qc_status = nil
}

// SetInboundStatus sets the "inbound_status" field.
func (m *ERPInboundNoticeMutation) SetInboundStatus(s string) {
	m.inbound_status = &s
}

// InboundStatus returns the value of the "inbound_status" field in the mutation.
func (m *ERPInboundNoticeMutation) InboundStatus() (r string, exists bool) {
	v := m.inbound_status
	if v == nil {
		return
	}
	return *v, true
}

// OldInboundStatus returns the old "inbound_status" field's value of the ERPInboundNotice entity.
// If the ERPInboundNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPInboundNoticeMutation) OldInboundStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInboundStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInboundStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInboundStatus: %w", err)
	}
	return oldValue.InboundStatus, nil
}

// ResetInboundStatus resets all changes to the "inbound_status" field.
func (m *ERPInboundNoticeMutation) ResetInboundStatus() {
	m.inbound_status = nil
}

// SetAllowInboundAt sets the "allow_inbound_at" field.
func (m *ERPInboundNoticeMutation) SetAllowInboundAt(t time.Time) {
	m.allow_inbound_at = &t
}

// AllowInboundAt returns the value of the "allow_inbound_at" field in the mutation.
func (m *ERPInboundNoticeMutation) AllowInboundAt() (r time.Time, exists bool) {
	v := m.allow_inbound_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowInboundAt returns the old "allow_inbound_at" field's value of the ERPInboundNotice entity.
// If the ERPInboundNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPInboundNoticeMutation) OldAllowInboundAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowInboundAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowInboundAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowInboundAt: %w", err)
	}
	return oldValue.AllowInboundAt, nil
}

// ClearAllowInboundAt clears the value of the "allow_inbound_at" field.
func (m *ERPInboundNoticeMutation) ClearAllowInboundAt() {
	m.allow_inbound_at = nil
	m.clearedFields[erpinboundnotice.FieldAllowInboundAt] = struct{}{}
}

// AllowInboundAtCleared returns if the "allow_inbound_at" field was cleared in this mutation.
func (m *ERPInboundNoticeMutation) AllowInboundAtCleared() bool {
	_, ok := m.clearedFields[erpinboundnotice.FieldAllowInboundAt]
	return ok
}

// ResetAllowInboundAt resets all changes to the "allow_inbound_at" field.
func (m *ERPInboundNoticeMutation) ResetAllowInboundAt() {
	m.allow_inbound_at = nil
	delete(m.clearedFields, erpinboundnotice.FieldAllowInboundAt)
}

// SetRemark sets the "remark" field.
func (m *ERPInboundNoticeMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ERPInboundNoticeMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the ERPInboundNotice entity.
// If the ERPInboundNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPInboundNoticeMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ERPInboundNoticeMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[erpinboundnotice.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ERPInboundNoticeMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[erpinboundnotice.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ERPInboundNoticeMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, erpinboundnotice.FieldRemark)
}

// SetCreatedByAdminID sets the "created_by_admin_id" field.
func (m *ERPInboundNoticeMutation) SetCreatedByAdminID(i int) {
	m.created_by_admin_id = &i
	m.addcreated_by_admin_id = nil
}

// CreatedByAdminID returns the value of the "created_by_admin_id" field in the mutation.
func (m *ERPInboundNoticeMutation) CreatedByAdminID() (r int, exists bool) {
	v := m.created_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedByAdminID returns the old "created_by_admin_id" field's value of the ERPInboundNotice entity.
// If the ERPInboundNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPInboundNoticeMutation) OldCreatedByAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedByAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedByAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedByAdminID: %w", err)
	}
	return oldValue.CreatedByAdminID, nil
}

// AddCreatedByAdminID adds i to the "created_by_admin_id" field.
func (m *ERPInboundNoticeMutation) AddCreatedByAdminID(i int) {
	if m.addcreated_by_admin_id != nil {
		*m.addcreated_by_admin_id += i
	} else {
		m.addcreated_by_admin_id = &i
	}
}

// AddedCreatedByAdminID returns the value that was added to the "created_by_admin_id" field in this mutation.
func (m *ERPInboundNoticeMutation) AddedCreatedByAdminID() (r int, exists bool) {
	v := m.addcreated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedByAdminID clears the value of the "created_by_admin_id" field.
func (m *ERPInboundNoticeMutation) ClearCreatedByAdminID() {
	m.created_by_admin_id = nil
	m.addcreated_by_admin_id = nil
	m.clearedFields[erpinboundnotice.FieldCreatedByAdminID] = struct{}{}
}

// CreatedByAdminIDCleared returns if the "created_by_admin_id" field was cleared in this mutation.
func (m *ERPInboundNoticeMutation) CreatedByAdminIDCleared() bool {
	_, ok := m.clearedFields[erpinboundnotice.FieldCreatedByAdminID]
	return ok
}

// ResetCreatedByAdminID resets all changes to the "created_by_admin_id" field.
func (m *ERPInboundNoticeMutation) ResetCreatedByAdminID() {
	m.created_by_admin_id = nil
	m.addcreated_by_admin_id = nil
	delete(m.clearedFields, erpinboundnotice.FieldCreatedByAdminID)
}

// SetUpdatedByAdminID sets the "updated_by_admin_id" field.
func (m *ERPInboundNoticeMutation) SetUpdatedByAdminID(i int) {
	m.updated_by_admin_id = &i
	m.addupdated_by_admin_id = nil
}

// UpdatedByAdminID returns the value of the "updated_by_admin_id" field in the mutation.
func (m *ERPInboundNoticeMutation) UpdatedByAdminID() (r int, exists bool) {
	v := m.updated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedByAdminID returns the old "updated_by_admin_id" field's value of the ERPInboundNotice entity.
// If the ERPInboundNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPInboundNoticeMutation) OldUpdatedByAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedByAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedByAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedByAdminID: %w", err)
	}
	return oldValue.UpdatedByAdminID, nil
}

// AddUpdatedByAdminID adds i to the "updated_by_admin_id" field.
func (m *ERPInboundNoticeMutation) AddUpdatedByAdminID(i int) {
	if m.addupdated_by_admin_id != nil {
		*m.addupdated_by_admin_id += i
	} else {
		m.addupdated_by_admin_id = &i
	}
}

// AddedUpdatedByAdminID returns the value that was added to the "updated_by_admin_id" field in this mutation.
func (m *ERPInboundNoticeMutation) AddedUpdatedByAdminID() (r int, exists bool) {
	v := m.addupdated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedByAdminID clears the value of the "updated_by_admin_id" field.
func (m *ERPInboundNoticeMutation) ClearUpdatedByAdminID() {
	m.updated_by_admin_id = nil
	m.addupdated_by_admin_id = nil
	m.clearedFields[erpinboundnotice.FieldUpdatedByAdminID] = struct{}{}
}

// UpdatedByAdminIDCleared returns if the "updated_by_admin_id" field was cleared in this mutation.
func (m *ERPInboundNoticeMutation) UpdatedByAdminIDCleared() bool {
	_, ok := m.clearedFields[erpinboundnotice.FieldUpdatedByAdminID]
	return ok
}

// ResetUpdatedByAdminID resets all changes to the "updated_by_admin_id" field.
func (m *ERPInboundNoticeMutation) ResetUpdatedByAdminID() {
	m.updated_by_admin_id = nil
	m.addupdated_by_admin_id = nil
	delete(m.clearedFields, erpinboundnotice.FieldUpdatedByAdminID)
}

// SetCreatedAt sets the "created_at" field.
func (m *ERPInboundNoticeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ERPInboundNoticeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ERPInboundNotice entity.
// If the ERPInboundNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPInboundNoticeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ERPInboundNoticeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ERPInboundNoticeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ERPInboundNoticeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ERPInboundNotice entity.
// If the ERPInboundNotice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPInboundNoticeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ERPInboundNoticeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ERPInboundNoticeMutation builder.
func (m *ERPInboundNoticeMutation) Where(ps ...predicate.ERPInboundNotice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ERPInboundNoticeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ERPInboundNoticeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ERPInboundNotice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ERPInboundNoticeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ERPInboundNoticeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ERPInboundNotice).
func (m *ERPInboundNoticeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ERPInboundNoticeMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.code != nil {
		fields = append(fields, erpinboundnotice.FieldCode)
	}
	if m.purchase_contract_id != nil {
		fields = append(fields, erpinboundnotice.FieldPurchaseContractID)
	}
	if m.source_purchase_code != nil {
		fields = append(fields, erpinboundnotice.FieldSourcePurchaseCode)
	}
	if m.entry_no != nil {
		fields = append(fields, erpinboundnotice.FieldEntryNo)
	}
	if m.warehouse_id != nil {
		fields = append(fields, erpinboundnotice.FieldWarehouseID)
	}
	if m.location_id != nil {
		fields = append(fields, erpinboundnotice.FieldLocationID)
	}
	if m.qc_status != nil {
		fields = append(fields, erpinboundnotice.FieldQcStatus)
	}
	if m.inbound_status != nil {
		fields = append(fields, erpinboundnotice.FieldInboundStatus)
	}
	if m.allow_inbound_at != nil {
		fields = append(fields, erpinboundnotice.FieldAllowInboundAt)
	}
	if m.remark != nil {
		fields = append(fields, erpinboundnotice.FieldRemark)
	}
	if m.created_by_admin_id != nil {
		fields = append(fields, erpinboundnotice.FieldCreatedByAdminID)
	}
	if m.updated_by_admin_id != nil {
		fields = append(fields, erpinboundnotice.FieldUpdatedByAdminID)
	}
	if m.created_at != nil {
		fields = append(fields, erpinboundnotice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, erpinboundnotice.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ERPInboundNoticeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case erpinboundnotice.FieldCode:
		return m.Code()
	case erpinboundnotice.FieldPurchaseContractID:
		return m.PurchaseContractID()
	case erpinboundnotice.FieldSourcePurchaseCode:
		return m.SourcePurchaseCode()
	case erpinboundnotice.FieldEntryNo:
		return m.EntryNo()
	case erpinboundnotice.FieldWarehouseID:
		return m.WarehouseID()
	case erpinboundnotice.FieldLocationID:
		return m.LocationID()
	case erpinboundnotice.FieldQcStatus:
		return m.QcStatus()
	case erpinboundnotice.FieldInboundStatus:
		return m.InboundStatus()
	case erpinboundnotice.FieldAllowInboundAt:
		return m.AllowInboundAt()
	case erpinboundnotice.FieldRemark:
		return m.Remark()
	case erpinboundnotice.FieldCreatedByAdminID:
		return m.CreatedByAdminID()
	case erpinboundnotice.FieldUpdatedByAdminID:
		return m.UpdatedByAdminID()
	case erpinboundnotice.FieldCreatedAt:
		return m.CreatedAt()
	case erpinboundnotice.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ERPInboundNoticeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case erpinboundnotice.FieldCode:
		return m.OldCode(ctx)
	case erpinboundnotice.FieldPurchaseContractID:
		return m.OldPurchaseContractID(ctx)
	case erpinboundnotice.FieldSourcePurchaseCode:
		return m.OldSourcePurchaseCode(ctx)
	case erpinboundnotice.FieldEntryNo:
		return m.OldEntryNo(ctx)
	case erpinboundnotice.FieldWarehouseID:
		return m.OldWarehouseID(ctx)
	case erpinboundnotice.FieldLocationID:
		return m.OldLocationID(ctx)
	case erpinboundnotice.FieldQcStatus:
		return m.OldQcStatus(ctx)
	case erpinboundnotice.FieldInboundStatus:
		return m.OldInboundStatus(ctx)
	case erpinboundnotice.FieldAllowInboundAt:
		return m.OldAllowInboundAt(ctx)
	case erpinboundnotice.FieldRemark:
		return m.OldRemark(ctx)
	case erpinboundnotice.FieldCreatedByAdminID:
		return m.OldCreatedByAdminID(ctx)
	case erpinboundnotice.FieldUpdatedByAdminID:
		return m.OldUpdatedByAdminID(ctx)
	case erpinboundnotice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case erpinboundnotice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ERPInboundNotice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPInboundNoticeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case erpinboundnotice.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case erpinboundnotice.FieldPurchaseContractID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchaseContractID(v)
		return nil
	case erpinboundnotice.FieldSourcePurchaseCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourcePurchaseCode(v)
		return nil
	case erpinboundnotice.FieldEntryNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryNo(v)
		return nil
	case erpinboundnotice.FieldWarehouseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWarehouseID(v)
		return nil
	case erpinboundnotice.FieldLocationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationID(v)
		return nil
	case erpinboundnotice.FieldQcStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQcStatus(v)
		return nil
	case erpinboundnotice.FieldInboundStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInboundStatus(v)
		return nil
	case erpinboundnotice.FieldAllowInboundAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowInboundAt(v)
		return nil
	case erpinboundnotice.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case erpinboundnotice.FieldCreatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedByAdminID(v)
		return nil
	case erpinboundnotice.FieldUpdatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedByAdminID(v)
		return nil
	case erpinboundnotice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case erpinboundnotice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ERPInboundNotice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ERPInboundNoticeMutation) AddedFields() []string {
	var fields []string
	if m.addpurchase_contract_id != nil {
		fields = append(fields, erpinboundnotice.FieldPurchaseContractID)
	}
	if m.addwarehouse_id != nil {
		fields = append(fields, erpinboundnotice.FieldWarehouseID)
	}
	if m.addlocation_id != nil {
		fields = append(fields, erpinboundnotice.FieldLocationID)
	}
	if m.addcreated_by_admin_id != nil {
		fields = append(fields, erpinboundnotice.FieldCreatedByAdminID)
	}
	if m.addupdated_by_admin_id != nil {
		fields = append(fields, erpinboundnotice.FieldUpdatedByAdminID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ERPInboundNoticeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case erpinboundnotice.FieldPurchaseContractID:
		return m.AddedPurchaseContractID()
	case erpinboundnotice.FieldWarehouseID:
		return m.AddedWarehouseID()
	case erpinboundnotice.FieldLocationID:
		return m.AddedLocationID()
	case erpinboundnotice.FieldCreatedByAdminID:
		return m.AddedCreatedByAdminID()
	case erpinboundnotice.FieldUpdatedByAdminID:
		return m.AddedUpdatedByAdminID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPInboundNoticeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case erpinboundnotice.FieldPurchaseContractID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPurchaseContractID(v)
		return nil
	case erpinboundnotice.FieldWarehouseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWarehouseID(v)
		return nil
	case erpinboundnotice.FieldLocationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLocationID(v)
		return nil
	case erpinboundnotice.FieldCreatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedByAdminID(v)
		return nil
	case erpinboundnotice.FieldUpdatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedByAdminID(v)
		return nil
	}
	return fmt.Errorf("unknown ERPInboundNotice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ERPInboundNoticeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(erpinboundnotice.FieldPurchaseContractID) {
		fields = append(fields, erpinboundnotice.FieldPurchaseContractID)
	}
	if m.FieldCleared(erpinboundnotice.FieldSourcePurchaseCode) {
		fields = append(fields, erpinboundnotice.FieldSourcePurchaseCode)
	}
	if m.FieldCleared(erpinboundnotice.FieldEntryNo) {
		fields = append(fields, erpinboundnotice.FieldEntryNo)
	}
	if m.FieldCleared(erpinboundnotice.FieldWarehouseID) {
		fields = append(fields, erpinboundnotice.FieldWarehouseID)
	}
	if m.FieldCleared(erpinboundnotice.FieldLocationID) {
		fields = append(fields, erpinboundnotice.FieldLocationID)
	}
	if m.FieldCleared(erpinboundnotice.FieldAllowInboundAt) {
		fields = append(fields, erpinboundnotice.FieldAllowInboundAt)
	}
	if m.FieldCleared(erpinboundnotice.FieldRemark) {
		fields = append(fields, erpinboundnotice.FieldRemark)
	}
	if m.FieldCleared(erpinboundnotice.FieldCreatedByAdminID) {
		fields = append(fields, erpinboundnotice.FieldCreatedByAdminID)
	}
	if m.FieldCleared(erpinboundnotice.FieldUpdatedByAdminID) {
		fields = append(fields, erpinboundnotice.FieldUpdatedByAdminID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ERPInboundNoticeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ERPInboundNoticeMutation) ClearField(name string) error {
	switch name {
	case erpinboundnotice.FieldPurchaseContractID:
		m.ClearPurchaseContractID()
		return nil
	case erpinboundnotice.FieldSourcePurchaseCode:
		m.ClearSourcePurchaseCode()
		return nil
	case erpinboundnotice.FieldEntryNo:
		m.ClearEntryNo()
		return nil
	case erpinboundnotice.FieldWarehouseID:
		m.ClearWarehouseID()
		return nil
	case erpinboundnotice.FieldLocationID:
		m.ClearLocationID()
		return nil
	case erpinboundnotice.FieldAllowInboundAt:
		m.ClearAllowInboundAt()
		return nil
	case erpinboundnotice.FieldRemark:
		m.ClearRemark()
		return nil
	case erpinboundnotice.FieldCreatedByAdminID:
		m.ClearCreatedByAdminID()
		return nil
	case erpinboundnotice.FieldUpdatedByAdminID:
		m.ClearUpdatedByAdminID()
		return nil
	}
	return fmt.Errorf("unknown ERPInboundNotice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ERPInboundNoticeMutation) ResetField(name string) error {
	switch name {
	case erpinboundnotice.FieldCode:
		m.ResetCode()
		return nil
	case erpinboundnotice.FieldPurchaseContractID:
		m.ResetPurchaseContractID()
		return nil
	case erpinboundnotice.FieldSourcePurchaseCode:
		m.ResetSourcePurchaseCode()
		return nil
	case erpinboundnotice.FieldEntryNo:
		m.ResetEntryNo()
		return nil
	case erpinboundnotice.FieldWarehouseID:
		m.ResetWarehouseID()
		return nil
	case erpinboundnotice.FieldLocationID:
		m.ResetLocationID()
		return nil
	case erpinboundnotice.FieldQcStatus:
		m.ResetQcStatus()
		return nil
	case erpinboundnotice.FieldInboundStatus:
		m.ResetInboundStatus()
		return nil
	case erpinboundnotice.FieldAllowInboundAt:
		m.ResetAllowInboundAt()
		return nil
	case erpinboundnotice.FieldRemark:
		m.ResetRemark()
		return nil
	case erpinboundnotice.FieldCreatedByAdminID:
		m.ResetCreatedByAdminID()
		return nil
	case erpinboundnotice.FieldUpdatedByAdminID:
		m.ResetUpdatedByAdminID()
		return nil
	case erpinboundnotice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case erpinboundnotice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPInboundNotice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ERPInboundNoticeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ERPInboundNoticeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ERPInboundNoticeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ERPInboundNoticeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ERPInboundNoticeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ERPInboundNoticeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ERPInboundNoticeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ERPInboundNotice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ERPInboundNoticeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ERPInboundNotice edge %s", name)
}

// ERPInboundNoticeItemMutation represents an operation that mutates the ERPInboundNoticeItem nodes in the graph.
type ERPInboundNoticeItemMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	inbound_notice_id       *int
	addinbound_notice_id    *int
	line_no                 *int
	addline_no              *int
	product_id              *int
	addproduct_id           *int
	product_code            *string
	product_name            *string
	lot_no                  *string
	quantity                *float64
	addquantity             *float64
	passed_qty              *float64
	addpassed_qty           *float64
	rejected_qty            *float64
	addrejected_qty         *float64
	report_attachment_id    *int
	addreport_attachment_id *int
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*ERPInboundNoticeItem, error)
	predicates              []predicate.ERPInboundNoticeItem
}

var _ ent.Mutation = (*ERPInboundNoticeItemMutation)(nil)

// erpinboundnoticeitemOption allows management of the mutation configuration using functional options.
type erpinboundnoticeitemOption func(*ERPInboundNoticeItemMutation)

// newERPInboundNoticeItemMutation creates new mutation for the ERPInboundNoticeItem entity.
func newERPInboundNoticeItemMutation(c config, op Op, opts ...erpinboundnoticeitemOption) *ERPInboundNoticeItemMutation {
	m := &ERPInboundNoticeItemMutation{
		config:        c,
		op:            op,
		typ:           TypeERPInboundNoticeItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withERPInboundNoticeItemID sets the ID field of the mutation.
func withERPInboundNoticeItemID(id int) erpinboundnoticeitemOption {
	return func(m *ERPInboundNoticeItemMutation) {
		var (
			err   error
			once  sync.Once
			value *ERPInboundNoticeItem
		)
		m.oldValue = func(ctx context.Context) (*ERPInboundNoticeItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ERPInboundNoticeItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withERPInboundNoticeItem sets the old ERPInboundNoticeItem of the mutation.
func withERPInboundNoticeItem(node *ERPInboundNoticeItem) erpinboundnoticeitemOption {
	return func(m *ERPInboundNoticeItemMutation) {
		m.oldValue = func(context.Context) (*ERPInboundNoticeItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ERPInboundNoticeItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ERPInboundNoticeItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ERPInboundNoticeItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ERPInboundNoticeItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ERPInboundNoticeItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInboundNoticeID sets the "inbound_notice_id" field.
func (m *ERPInboundNoticeItemMutation) SetInboundNoticeID(i int) {
	m.inbound_notice_id = &i
	m.addinbound_notice_id = nil
}

// InboundNoticeID returns the value of the "inbound_notice_id" field in the mutation.
func (m *ERPInboundNoticeItemMutation) InboundNoticeID() (r int, exists bool) {
	v := m.inbound_notice_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInboundNoticeID returns the old "inbound_notice_id" field's value of the ERPInboundNoticeItem entity.
// If the ERPInboundNoticeItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPInboundNoticeItemMutation) OldInboundNoticeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInboundNoticeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInboundNoticeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInboundNoticeID: %w", err)
	}
	return oldValue.InboundNoticeID, nil
}

// AddInboundNoticeID adds i to the "inbound_notice_id" field.
func (m *ERPInboundNoticeItemMutation) AddInboundNoticeID(i int) {
	if m.addinbound_notice_id != nil {
		*m.addinbound_notice_id += i
	} else {
		m.addinbound_notice_id = &i
	}
}

// AddedInboundNoticeID returns the value that was added to the "inbound_notice_id" field in this mutation.
func (m *ERPInboundNoticeItemMutation) AddedInboundNoticeID() (r int, exists bool) {
	v := m.addinbound_notice_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetInboundNoticeID resets all changes to the "inbound_notice_id" field.
func (m *ERPInboundNoticeItemMutation) ResetInboundNoticeID() {
	m.inbound_notice_id = nil
	m.addinbound_notice_id = nil
}

// SetLineNo sets the "line_no" field.
func (m *ERPInboundNoticeItemMutation) SetLineNo(i int) {
	m.line_no = &i
	m.addline_no = nil
}

// LineNo returns the value of the "line_no" field in the mutation.
func (m *ERPInboundNoticeItemMutation) LineNo() (r int, exists bool) {
	v := m.line_no
	if v == nil {
		return
	}
	return *v, true
}

// OldLineNo returns the old "line_no" field's value of the ERPInboundNoticeItem entity.
// If the ERPInboundNoticeItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPInboundNoticeItemMutation) OldLineNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLineNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLineNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLineNo: %w", err)
	}
	return oldValue.LineNo, nil
}

// AddLineNo adds i to the "line_no" field.
func (m *ERPInboundNoticeItemMutation) AddLineNo(i int) {
	if m.addline_no != nil {
		*m.addline_no += i
	} else {
		m.addline_no = &i
	}
}

// AddedLineNo returns the value that was added to the "line_no" field in this mutation.
func (m *ERPInboundNoticeItemMutation) AddedLineNo() (r int, exists bool) {
	v := m.addline_no
	if v == nil {
		return
	}
	return *v, true
}

// ResetLineNo resets all changes to the "line_no" field.
func (m *ERPInboundNoticeItemMutation) ResetLineNo() {
	m.line_no = nil
	m.addline_no = nil
}

// SetProductID sets the "product_id" field.
func (m *ERPInboundNoticeItemMutation) SetProductID(i int) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ERPInboundNoticeItemMutation) ProductID() (r int, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the ERPInboundNoticeItem entity.
// If the ERPInboundNoticeItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPInboundNoticeItemMutation) OldProductID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *ERPInboundNoticeItemMutation) AddProductID(i int) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *ERPInboundNoticeItemMutation) AddedProductID() (r int, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductID clears the value of the "product_id" field.
func (m *ERPInboundNoticeItemMutation) ClearProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	m.clearedFields[erpinboundnoticeitem.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *ERPInboundNoticeItemMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[erpinboundnoticeitem.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ERPInboundNoticeItemMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	delete(m.clearedFields, erpinboundnoticeitem.FieldProductID)
}

// SetProductCode sets the "product_code" field.
func (m *ERPInboundNoticeItemMutation) SetProductCode(s string) {
	m.product_code = &s
}

// ProductCode returns the value of the "product_code" field in the mutation.
func (m *ERPInboundNoticeItemMutation) ProductCode() (r string, exists bool) {
	v := m.product_code
	if v == nil {
		return
	}
	return *v, true
}

// OldProductCode returns the old "product_code" field's value of the ERPInboundNoticeItem entity.
// If the ERPInboundNoticeItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPInboundNoticeItemMutation) OldProductCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductCode: %w", err)
	}
	return oldValue.ProductCode, nil
}

// ClearProductCode clears the value of the "product_code" field.
func (m *ERPInboundNoticeItemMutation) ClearProductCode() {
	m.product_code = nil
	m.clearedFields[erpinboundnoticeitem.FieldProductCode] = struct{}{}
}

// ProductCodeCleared returns if the "product_code" field was cleared in this mutation.
func (m *ERPInboundNoticeItemMutation) ProductCodeCleared() bool {
	_, ok := m.clearedFields[erpinboundnoticeitem.FieldProductCode]
	return ok
}

// ResetProductCode resets all changes to the "product_code" field.
func (m *ERPInboundNoticeItemMutation) ResetProductCode() {
	m.product_code = nil
	delete(m.clearedFields, erpinboundnoticeitem.FieldProductCode)
}

// SetProductName sets the "product_name" field.
func (m *ERPInboundNoticeItemMutation) SetProductName(s string) {
	m.product_name = &s
}

// ProductName returns the value of the "product_name" field in the mutation.
func (m *ERPInboundNoticeItemMutation) ProductName() (r string, exists bool) {
	v := m.product_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProductName returns the old "product_name" field's value of the ERPInboundNoticeItem entity.
// If the ERPInboundNoticeItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPInboundNoticeItemMutation) OldProductName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductName: %w", err)
	}
	return oldValue.ProductName, nil
}

// ClearProductName clears the value of the "product_name" field.
func (m *ERPInboundNoticeItemMutation) ClearProductName() {
	m.product_name = nil
	m.clearedFields[erpinboundnoticeitem.FieldProductName] = struct{}{}
}

// ProductNameCleared returns if the "product_name" field was cleared in this mutation.
func (m *ERPInboundNoticeItemMutation) ProductNameCleared() bool {
	_, ok := m.clearedFields[erpinboundnoticeitem.FieldProductName]
	return ok
}

// ResetProductName resets all changes to the "product_name" field.
func (m *ERPInboundNoticeItemMutation) ResetProductName() {
	m.product_name = nil
	delete(m.clearedFields, erpinboundnoticeitem.FieldProductName)
}

// SetLotNo sets the "lot_no" field.
func (m *ERPInboundNoticeItemMutation) SetLotNo(s string) {
	m.lot_no = &s
}

// LotNo returns the value of the "lot_no" field in the mutation.
func (m *ERPInboundNoticeItemMutation) LotNo() (r string, exists bool) {
	v := m.lot_no
	if v == nil {
		return
	}
	return *v, true
}

// OldLotNo returns the old "lot_no" field's value of the ERPInboundNoticeItem entity.
// If the ERPInboundNoticeItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPInboundNoticeItemMutation) OldLotNo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLotNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLotNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLotNo: %w", err)
	}
	return oldValue.LotNo, nil
}

// ClearLotNo clears the value of the "lot_no" field.
func (m *ERPInboundNoticeItemMutation) ClearLotNo() {
	m.lot_no = nil
	m.clearedFields[erpinboundnoticeitem.FieldLotNo] = struct{}{}
}

// LotNoCleared returns if the "lot_no" field was cleared in this mutation.
func (m *ERPInboundNoticeItemMutation) LotNoCleared() bool {
	_, ok := m.clearedFields[erpinboundnoticeitem.FieldLotNo]
	return ok
}

// ResetLotNo resets all changes to the "lot_no" field.
func (m *ERPInboundNoticeItemMutation) ResetLotNo() {
	m.lot_no = nil
	delete(m.clearedFields, erpinboundnoticeitem.FieldLotNo)
}

// SetQuantity sets the "quantity" field.
func (m *ERPInboundNoticeItemMutation) SetQuantity(f float64) {
	m.quantity = &f
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *ERPInboundNoticeItemMutation) Quantity() (r float64, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the ERPInboundNoticeItem entity.
// If the ERPInboundNoticeItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPInboundNoticeItemMutation) OldQuantity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds f to the "quantity" field.
func (m *ERPInboundNoticeItemMutation) AddQuantity(f float64) {
	if m.addquantity != nil {
		*m.addquantity += f
	} else {
		m.addquantity = &f
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *ERPInboundNoticeItemMutation) AddedQuantity() (r float64, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *ERPInboundNoticeItemMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetPassedQty sets the "passed_qty" field.
func (m *ERPInboundNoticeItemMutation) SetPassedQty(f float64) {
	m.passed_qty = &f
	m.addpassed_qty = nil
}

// PassedQty returns the value of the "passed_qty" field in the mutation.
func (m *ERPInboundNoticeItemMutation) PassedQty() (r float64, exists bool) {
	v := m.passed_qty
	if v == nil {
		return
	}
	return *v, true
}

// OldPassedQty returns the old "passed_qty" field's value of the ERPInboundNoticeItem entity.
// If the ERPInboundNoticeItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPInboundNoticeItemMutation) OldPassedQty(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassedQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassedQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassedQty: %w", err)
	}
	return oldValue.PassedQty, nil
}

// AddPassedQty adds f to the "passed_qty" field.
func (m *ERPInboundNoticeItemMutation) AddPassedQty(f float64) {
	if m.addpassed_qty != nil {
		*m.addpassed_qty += f
	} else {
		m.addpassed_qty = &f
	}
}

// AddedPassedQty returns the value that was added to the "passed_qty" field in this mutation.
func (m *ERPInboundNoticeItemMutation) AddedPassedQty() (r float64, exists bool) {
	v := m.addpassed_qty
	if v == nil {
		return
	}
	return *v, true
}

// ResetPassedQty resets all changes to the "passed_qty" field.
func (m *ERPInboundNoticeItemMutation) ResetPassedQty() {
	m.passed_qty = nil
	m.addpassed_qty = nil
}

// SetRejectedQty sets the "rejected_qty" field.
func (m *ERPInboundNoticeItemMutation) SetRejectedQty(f float64) {
	m.rejected_qty = &f
	m.addrejected_qty = nil
}

// RejectedQty returns the value of the "rejected_qty" field in the mutation.
func (m *ERPInboundNoticeItemMutation) RejectedQty() (r float64, exists bool) {
	v := m.rejected_qty
	if v == nil {
		return
	}
	return *v, true
}

// OldRejectedQty returns the old "rejected_qty" field's value of the ERPInboundNoticeItem entity.
// If the ERPInboundNoticeItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPInboundNoticeItemMutation) OldRejectedQty(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRejectedQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRejectedQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRejectedQty: %w", err)
	}
	return oldValue.RejectedQty, nil
}

// AddRejectedQty adds f to the "rejected_qty" field.
func (m *ERPInboundNoticeItemMutation) AddRejectedQty(f float64) {
	if m.addrejected_qty != nil {
		*m.addrejected_qty += f
	} else {
		m.addrejected_qty = &f
	}
}

// AddedRejectedQty returns the value that was added to the "rejected_qty" field in this mutation.
func (m *ERPInboundNoticeItemMutation) AddedRejectedQty() (r float64, exists bool) {
	v := m.addrejected_qty
	if v == nil {
		return
	}
	return *v, true
}

// ResetRejectedQty resets all changes to the "rejected_qty" field.
func (m *ERPInboundNoticeItemMutation) ResetRejectedQty() {
	m.rejected_qty = nil
	m.addrejected_qty = nil
}

// SetReportAttachmentID sets the "report_attachment_id" field.
func (m *ERPInboundNoticeItemMutation) SetReportAttachmentID(i int) {
	m.report_attachment_id = &i
	m.addreport_attachment_id = nil
}

// ReportAttachmentID returns the value of the "report_attachment_id" field in the mutation.
func (m *ERPInboundNoticeItemMutation) ReportAttachmentID() (r int, exists bool) {
	v := m.report_attachment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReportAttachmentID returns the old "report_attachment_id" field's value of the ERPInboundNoticeItem entity.
// If the ERPInboundNoticeItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPInboundNoticeItemMutation) OldReportAttachmentID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportAttachmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportAttachmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportAttachmentID: %w", err)
	}
	return oldValue.ReportAttachmentID, nil
}

// AddReportAttachmentID adds i to the "report_attachment_id" field.
func (m *ERPInboundNoticeItemMutation) AddReportAttachmentID(i int) {
	if m.addreport_attachment_id != nil {
		*m.addreport_attachment_id += i
	} else {
		m.addreport_attachment_id = &i
	}
}

// AddedReportAttachmentID returns the value that was added to the "report_attachment_id" field in this mutation.
func (m *ERPInboundNoticeItemMutation) AddedReportAttachmentID() (r int, exists bool) {
	v := m.addreport_attachment_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearReportAttachmentID clears the value of the "report_attachment_id" field.
func (m *ERPInboundNoticeItemMutation) ClearReportAttachmentID() {
	m.report_attachment_id = nil
	m.addreport_attachment_id = nil
	m.clearedFields[erpinboundnoticeitem.FieldReportAttachmentID] = struct{}{}
}

// ReportAttachmentIDCleared returns if the "report_attachment_id" field was cleared in this mutation.
func (m *ERPInboundNoticeItemMutation) ReportAttachmentIDCleared() bool {
	_, ok := m.clearedFields[erpinboundnoticeitem.FieldReportAttachmentID]
	return ok
}

// ResetReportAttachmentID resets all changes to the "report_attachment_id" field.
func (m *ERPInboundNoticeItemMutation) ResetReportAttachmentID() {
	m.report_attachment_id = nil
	m.addreport_attachment_id = nil
	delete(m.clearedFields, erpinboundnoticeitem.FieldReportAttachmentID)
}

// SetCreatedAt sets the "created_at" field.
func (m *ERPInboundNoticeItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ERPInboundNoticeItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ERPInboundNoticeItem entity.
// If the ERPInboundNoticeItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPInboundNoticeItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ERPInboundNoticeItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ERPInboundNoticeItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ERPInboundNoticeItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ERPInboundNoticeItem entity.
// If the ERPInboundNoticeItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPInboundNoticeItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ERPInboundNoticeItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ERPInboundNoticeItemMutation builder.
func (m *ERPInboundNoticeItemMutation) Where(ps ...predicate.ERPInboundNoticeItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ERPInboundNoticeItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ERPInboundNoticeItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ERPInboundNoticeItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ERPInboundNoticeItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ERPInboundNoticeItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ERPInboundNoticeItem).
func (m *ERPInboundNoticeItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ERPInboundNoticeItemMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.inbound_notice_id != nil {
		fields = append(fields, erpinboundnoticeitem.FieldInboundNoticeID)
	}
	if m.line_no != nil {
		fields = append(fields, erpinboundnoticeitem.FieldLineNo)
	}
	if m.product_id != nil {
		fields = append(fields, erpinboundnoticeitem.FieldProductID)
	}
	if m.product_code != nil {
		fields = append(fields, erpinboundnoticeitem.FieldProductCode)
	}
	if m.product_name != nil {
		fields = append(fields, erpinboundnoticeitem.FieldProductName)
	}
	if m.lot_no != nil {
		fields = append(fields, erpinboundnoticeitem.FieldLotNo)
	}
	if m.quantity != nil {
		fields = append(fields, erpinboundnoticeitem.FieldQuantity)
	}
	if m.passed_qty != nil {
		fields = append(fields, erpinboundnoticeitem.FieldPassedQty)
	}
	if m.rejected_qty != nil {
		fields = append(fields, erpinboundnoticeitem.FieldRejectedQty)
	}
	if m.report_attachment_id != nil {
		fields = append(fields, erpinboundnoticeitem.FieldReportAttachmentID)
	}
	if m.created_at != nil {
		fields = append(fields, erpinboundnoticeitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, erpinboundnoticeitem.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ERPInboundNoticeItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case erpinboundnoticeitem.FieldInboundNoticeID:
		return m.InboundNoticeID()
	case erpinboundnoticeitem.FieldLineNo:
		return m.LineNo()
	case erpinboundnoticeitem.FieldProductID:
		return m.ProductID()
	case erpinboundnoticeitem.FieldProductCode:
		return m.ProductCode()
	case erpinboundnoticeitem.FieldProductName:
		return m.ProductName()
	case erpinboundnoticeitem.FieldLotNo:
		return m.LotNo()
	case erpinboundnoticeitem.FieldQuantity:
		return m.Quantity()
	case erpinboundnoticeitem.FieldPassedQty:
		return m.PassedQty()
	case erpinboundnoticeitem.FieldRejectedQty:
		return m.RejectedQty()
	case erpinboundnoticeitem.FieldReportAttachmentID:
		return m.ReportAttachmentID()
	case erpinboundnoticeitem.FieldCreatedAt:
		return m.CreatedAt()
	case erpinboundnoticeitem.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ERPInboundNoticeItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case erpinboundnoticeitem.FieldInboundNoticeID:
		return m.OldInboundNoticeID(ctx)
	case erpinboundnoticeitem.FieldLineNo:
		return m.OldLineNo(ctx)
	case erpinboundnoticeitem.FieldProductID:
		return m.OldProductID(ctx)
	case erpinboundnoticeitem.FieldProductCode:
		return m.OldProductCode(ctx)
	case erpinboundnoticeitem.FieldProductName:
		return m.OldProductName(ctx)
	case erpinboundnoticeitem.FieldLotNo:
		return m.OldLotNo(ctx)
	case erpinboundnoticeitem.FieldQuantity:
		return m.OldQuantity(ctx)
	case erpinboundnoticeitem.FieldPassedQty:
		return m.OldPassedQty(ctx)
	case erpinboundnoticeitem.FieldRejectedQty:
		return m.OldRejectedQty(ctx)
	case erpinboundnoticeitem.FieldReportAttachmentID:
		return m.OldReportAttachmentID(ctx)
	case erpinboundnoticeitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case erpinboundnoticeitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ERPInboundNoticeItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPInboundNoticeItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case erpinboundnoticeitem.FieldInboundNoticeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInboundNoticeID(v)
		return nil
	case erpinboundnoticeitem.FieldLineNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLineNo(v)
		return nil
	case erpinboundnoticeitem.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case erpinboundnoticeitem.FieldProductCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductCode(v)
		return nil
	case erpinboundnoticeitem.FieldProductName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductName(v)
		return nil
	case erpinboundnoticeitem.FieldLotNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLotNo(v)
		return nil
	case erpinboundnoticeitem.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case erpinboundnoticeitem.FieldPassedQty:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassedQty(v)
		return nil
	case erpinboundnoticeitem.FieldRejectedQty:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRejectedQty(v)
		return nil
	case erpinboundnoticeitem.FieldReportAttachmentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportAttachmentID(v)
		return nil
	case erpinboundnoticeitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case erpinboundnoticeitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ERPInboundNoticeItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ERPInboundNoticeItemMutation) AddedFields() []string {
	var fields []string
	if m.addinbound_notice_id != nil {
		fields = append(fields, erpinboundnoticeitem.FieldInboundNoticeID)
	}
	if m.addline_no != nil {
		fields = append(fields, erpinboundnoticeitem.FieldLineNo)
	}
	if m.addproduct_id != nil {
		fields = append(fields, erpinboundnoticeitem.FieldProductID)
	}
	if m.addquantity != nil {
		fields = append(fields, erpinboundnoticeitem.FieldQuantity)
	}
	if m.addpassed_qty != nil {
		fields = append(fields, erpinboundnoticeitem.FieldPassedQty)
	}
	if m.addrejected_qty != nil {
		fields = append(fields, erpinboundnoticeitem.FieldRejectedQty)
	}
	if m.addreport_attachment_id != nil {
		fields = append(fields, erpinboundnoticeitem.FieldReportAttachmentID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ERPInboundNoticeItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case erpinboundnoticeitem.FieldInboundNoticeID:
		return m.AddedInboundNoticeID()
	case erpinboundnoticeitem.FieldLineNo:
		return m.AddedLineNo()
	case erpinboundnoticeitem.FieldProductID:
		return m.AddedProductID()
	case erpinboundnoticeitem.FieldQuantity:
		return m.AddedQuantity()
	case erpinboundnoticeitem.FieldPassedQty:
		return m.AddedPassedQty()
	case erpinboundnoticeitem.FieldRejectedQty:
		return m.AddedRejectedQty()
	case erpinboundnoticeitem.FieldReportAttachmentID:
		return m.AddedReportAttachmentID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPInboundNoticeItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case erpinboundnoticeitem.FieldInboundNoticeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInboundNoticeID(v)
		return nil
	case erpinboundnoticeitem.FieldLineNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLineNo(v)
		return nil
	case erpinboundnoticeitem.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case erpinboundnoticeitem.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case erpinboundnoticeitem.FieldPassedQty:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPassedQty(v)
		return nil
	case erpinboundnoticeitem.FieldRejectedQty:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRejectedQty(v)
		return nil
	case erpinboundnoticeitem.FieldReportAttachmentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReportAttachmentID(v)
		return nil
	}
	return fmt.Errorf("unknown ERPInboundNoticeItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ERPInboundNoticeItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(erpinboundnoticeitem.FieldProductID) {
		fields = append(fields, erpinboundnoticeitem.FieldProductID)
	}
	if m.FieldCleared(erpinboundnoticeitem.FieldProductCode) {
		fields = append(fields, erpinboundnoticeitem.FieldProductCode)
	}
	if m.FieldCleared(erpinboundnoticeitem.FieldProductName) {
		fields = append(fields, erpinboundnoticeitem.FieldProductName)
	}
	if m.FieldCleared(erpinboundnoticeitem.FieldLotNo) {
		fields = append(fields, erpinboundnoticeitem.FieldLotNo)
	}
	if m.FieldCleared(erpinboundnoticeitem.FieldReportAttachmentID) {
		fields = append(fields, erpinboundnoticeitem.FieldReportAttachmentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ERPInboundNoticeItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ERPInboundNoticeItemMutation) ClearField(name string) error {
	switch name {
	case erpinboundnoticeitem.FieldProductID:
		m.ClearProductID()
		return nil
	case erpinboundnoticeitem.FieldProductCode:
		m.ClearProductCode()
		return nil
	case erpinboundnoticeitem.FieldProductName:
		m.ClearProductName()
		return nil
	case erpinboundnoticeitem.FieldLotNo:
		m.ClearLotNo()
		return nil
	case erpinboundnoticeitem.FieldReportAttachmentID:
		m.ClearReportAttachmentID()
		return nil
	}
	return fmt.Errorf("unknown ERPInboundNoticeItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ERPInboundNoticeItemMutation) ResetField(name string) error {
	switch name {
	case erpinboundnoticeitem.FieldInboundNoticeID:
		m.ResetInboundNoticeID()
		return nil
	case erpinboundnoticeitem.FieldLineNo:
		m.ResetLineNo()
		return nil
	case erpinboundnoticeitem.FieldProductID:
		m.ResetProductID()
		return nil
	case erpinboundnoticeitem.FieldProductCode:
		m.ResetProductCode()
		return nil
	case erpinboundnoticeitem.FieldProductName:
		m.ResetProductName()
		return nil
	case erpinboundnoticeitem.FieldLotNo:
		m.ResetLotNo()
		return nil
	case erpinboundnoticeitem.FieldQuantity:
		m.ResetQuantity()
		return nil
	case erpinboundnoticeitem.FieldPassedQty:
		m.ResetPassedQty()
		return nil
	case erpinboundnoticeitem.FieldRejectedQty:
		m.ResetRejectedQty()
		return nil
	case erpinboundnoticeitem.FieldReportAttachmentID:
		m.ResetReportAttachmentID()
		return nil
	case erpinboundnoticeitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case erpinboundnoticeitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPInboundNoticeItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ERPInboundNoticeItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ERPInboundNoticeItemMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ERPInboundNoticeItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ERPInboundNoticeItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ERPInboundNoticeItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ERPInboundNoticeItemMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ERPInboundNoticeItemMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ERPInboundNoticeItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ERPInboundNoticeItemMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ERPInboundNoticeItem edge %s", name)
}

// ERPLocationMutation represents an operation that mutates the ERPLocation nodes in the graph.
type ERPLocationMutation struct {
	config
	op              Op
	typ             string
	id              *int
	warehouse_id    *int
	addwarehouse_id *int
	code            *string
	name            *string
	disabled        *bool
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*ERPLocation, error)
	predicates      []predicate.ERPLocation
}

var _ ent.Mutation = (*ERPLocationMutation)(nil)

// erplocationOption allows management of the mutation configuration using functional options.
type erplocationOption func(*ERPLocationMutation)

// newERPLocationMutation creates new mutation for the ERPLocation entity.
func newERPLocationMutation(c config, op Op, opts ...erplocationOption) *ERPLocationMutation {
	m := &ERPLocationMutation{
		config:        c,
		op:            op,
		typ:           TypeERPLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withERPLocationID sets the ID field of the mutation.
func withERPLocationID(id int) erplocationOption {
	return func(m *ERPLocationMutation) {
		var (
			err   error
			once  sync.Once
			value *ERPLocation
		)
		m.oldValue = func(ctx context.Context) (*ERPLocation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ERPLocation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withERPLocation sets the old ERPLocation of the mutation.
func withERPLocation(node *ERPLocation) erplocationOption {
	return func(m *ERPLocationMutation) {
		m.oldValue = func(context.Context) (*ERPLocation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ERPLocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ERPLocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ERPLocationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ERPLocationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ERPLocation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWarehouseID sets the "warehouse_id" field.
func (m *ERPLocationMutation) SetWarehouseID(i int) {
	m.warehouse_id = &i
	m.addwarehouse_id = nil
}

// WarehouseID returns the value of the "warehouse_id" field in the mutation.
func (m *ERPLocationMutation) WarehouseID() (r int, exists bool) {
	v := m.warehouse_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWarehouseID returns the old "warehouse_id" field's value of the ERPLocation entity.
// If the ERPLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPLocationMutation) OldWarehouseID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWarehouseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWarehouseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWarehouseID: %w", err)
	}
	return oldValue.WarehouseID, nil
}

// AddWarehouseID adds i to the "warehouse_id" field.
func (m *ERPLocationMutation) AddWarehouseID(i int) {
	if m.addwarehouse_id != nil {
		*m.addwarehouse_id += i
	} else {
		m.addwarehouse_id = &i
	}
}

// AddedWarehouseID returns the value that was added to the "warehouse_id" field in this mutation.
func (m *ERPLocationMutation) AddedWarehouseID() (r int, exists bool) {
	v := m.addwarehouse_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetWarehouseID resets all changes to the "warehouse_id" field.
func (m *ERPLocationMutation) ResetWarehouseID() {
	m.warehouse_id = nil
	m.addwarehouse_id = nil
}

// SetCode sets the "code" field.
func (m *ERPLocationMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ERPLocationMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the ERPLocation entity.
// If the ERPLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPLocationMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ERPLocationMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *ERPLocationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ERPLocationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ERPLocation entity.
// If the ERPLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPLocationMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ERPLocationMutation) ClearName() {
	m.name = nil
	m.clearedFields[erplocation.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ERPLocationMutation) NameCleared() bool {
	_, ok := m.clearedFields[erplocation.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ERPLocationMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, erplocation.FieldName)
}

// SetDisabled sets the "disabled" field.
func (m *ERPLocationMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *ERPLocationMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the ERPLocation entity.
// If the ERPLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPLocationMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *ERPLocationMutation) ResetDisabled() {
	m.disabled = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ERPLocationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ERPLocationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ERPLocation entity.
// If the ERPLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPLocationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ERPLocationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ERPLocationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ERPLocationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ERPLocation entity.
// If the ERPLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPLocationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ERPLocationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ERPLocationMutation builder.
func (m *ERPLocationMutation) Where(ps ...predicate.ERPLocation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ERPLocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ERPLocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ERPLocation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ERPLocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ERPLocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ERPLocation).
func (m *ERPLocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ERPLocationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.warehouse_id != nil {
		fields = append(fields, erplocation.FieldWarehouseID)
	}
	if m.code != nil {
		fields = append(fields, erplocation.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, erplocation.FieldName)
	}
	if m.disabled != nil {
		fields = append(fields, erplocation.FieldDisabled)
	}
	if m.created_at != nil {
		fields = append(fields, erplocation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, erplocation.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ERPLocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case erplocation.FieldWarehouseID:
		return m.WarehouseID()
	case erplocation.FieldCode:
		return m.Code()
	case erplocation.FieldName:
		return m.Name()
	case erplocation.FieldDisabled:
		return m.Disabled()
	case erplocation.FieldCreatedAt:
		return m.CreatedAt()
	case erplocation.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ERPLocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case erplocation.FieldWarehouseID:
		return m.OldWarehouseID(ctx)
	case erplocation.FieldCode:
		return m.OldCode(ctx)
	case erplocation.FieldName:
		return m.OldName(ctx)
	case erplocation.FieldDisabled:
		return m.OldDisabled(ctx)
	case erplocation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case erplocation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ERPLocation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPLocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case erplocation.FieldWarehouseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWarehouseID(v)
		return nil
	case erplocation.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case erplocation.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case erplocation.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case erplocation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case erplocation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ERPLocation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ERPLocationMutation) AddedFields() []string {
	var fields []string
	if m.addwarehouse_id != nil {
		fields = append(fields, erplocation.FieldWarehouseID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ERPLocationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case erplocation.FieldWarehouseID:
		return m.AddedWarehouseID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPLocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case erplocation.FieldWarehouseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWarehouseID(v)
		return nil
	}
	return fmt.Errorf("unknown ERPLocation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ERPLocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(erplocation.FieldName) {
		fields = append(fields, erplocation.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ERPLocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ERPLocationMutation) ClearField(name string) error {
	switch name {
	case erplocation.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown ERPLocation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ERPLocationMutation) ResetField(name string) error {
	switch name {
	case erplocation.FieldWarehouseID:
		m.ResetWarehouseID()
		return nil
	case erplocation.FieldCode:
		m.ResetCode()
		return nil
	case erplocation.FieldName:
		m.ResetName()
		return nil
	case erplocation.FieldDisabled:
		m.ResetDisabled()
		return nil
	case erplocation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case erplocation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPLocation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ERPLocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ERPLocationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ERPLocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ERPLocationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ERPLocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ERPLocationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ERPLocationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ERPLocation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ERPLocationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ERPLocation edge %s", name)
}

// ERPModuleRecordMutation represents an operation that mutates the ERPModuleRecord nodes in the graph.
type ERPModuleRecordMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	module_key             *string
	code                   *string
	box                    *string
	payload                *string
	created_by_admin_id    *int
	addcreated_by_admin_id *int
	updated_by_admin_id    *int
	addupdated_by_admin_id *int
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*ERPModuleRecord, error)
	predicates             []predicate.ERPModuleRecord
}

var _ ent.Mutation = (*ERPModuleRecordMutation)(nil)

// erpmodulerecordOption allows management of the mutation configuration using functional options.
type erpmodulerecordOption func(*ERPModuleRecordMutation)

// newERPModuleRecordMutation creates new mutation for the ERPModuleRecord entity.
func newERPModuleRecordMutation(c config, op Op, opts ...erpmodulerecordOption) *ERPModuleRecordMutation {
	m := &ERPModuleRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeERPModuleRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withERPModuleRecordID sets the ID field of the mutation.
func withERPModuleRecordID(id int) erpmodulerecordOption {
	return func(m *ERPModuleRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *ERPModuleRecord
		)
		m.oldValue = func(ctx context.Context) (*ERPModuleRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ERPModuleRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withERPModuleRecord sets the old ERPModuleRecord of the mutation.
func withERPModuleRecord(node *ERPModuleRecord) erpmodulerecordOption {
	return func(m *ERPModuleRecordMutation) {
		m.oldValue = func(context.Context) (*ERPModuleRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ERPModuleRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ERPModuleRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ERPModuleRecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ERPModuleRecordMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ERPModuleRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetModuleKey sets the "module_key" field.
func (m *ERPModuleRecordMutation) SetModuleKey(s string) {
	m.module_key = &s
}

// ModuleKey returns the value of the "module_key" field in the mutation.
func (m *ERPModuleRecordMutation) ModuleKey() (r string, exists bool) {
	v := m.module_key
	if v == nil {
		return
	}
	return *v, true
}

// OldModuleKey returns the old "module_key" field's value of the ERPModuleRecord entity.
// If the ERPModuleRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPModuleRecordMutation) OldModuleKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModuleKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModuleKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModuleKey: %w", err)
	}
	return oldValue.ModuleKey, nil
}

// ResetModuleKey resets all changes to the "module_key" field.
func (m *ERPModuleRecordMutation) ResetModuleKey() {
	m.module_key = nil
}

// SetCode sets the "code" field.
func (m *ERPModuleRecordMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ERPModuleRecordMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the ERPModuleRecord entity.
// If the ERPModuleRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPModuleRecordMutation) OldCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *ERPModuleRecordMutation) ClearCode() {
	m.code = nil
	m.clearedFields[erpmodulerecord.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *ERPModuleRecordMutation) CodeCleared() bool {
	_, ok := m.clearedFields[erpmodulerecord.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *ERPModuleRecordMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, erpmodulerecord.FieldCode)
}

// SetBox sets the "box" field.
func (m *ERPModuleRecordMutation) SetBox(s string) {
	m.box = &s
}

// Box returns the value of the "box" field in the mutation.
func (m *ERPModuleRecordMutation) Box() (r string, exists bool) {
	v := m.box
	if v == nil {
		return
	}
	return *v, true
}

// OldBox returns the old "box" field's value of the ERPModuleRecord entity.
// If the ERPModuleRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPModuleRecordMutation) OldBox(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBox is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBox requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBox: %w", err)
	}
	return oldValue.Box, nil
}

// ClearBox clears the value of the "box" field.
func (m *ERPModuleRecordMutation) ClearBox() {
	m.box = nil
	m.clearedFields[erpmodulerecord.FieldBox] = struct{}{}
}

// BoxCleared returns if the "box" field was cleared in this mutation.
func (m *ERPModuleRecordMutation) BoxCleared() bool {
	_, ok := m.clearedFields[erpmodulerecord.FieldBox]
	return ok
}

// ResetBox resets all changes to the "box" field.
func (m *ERPModuleRecordMutation) ResetBox() {
	m.box = nil
	delete(m.clearedFields, erpmodulerecord.FieldBox)
}

// SetPayload sets the "payload" field.
func (m *ERPModuleRecordMutation) SetPayload(s string) {
	m.payload = &s
}

// Payload returns the value of the "payload" field in the mutation.
func (m *ERPModuleRecordMutation) Payload() (r string, exists bool) {
	v := m.payload
	if v == nil {
		return
	}
	return *v, true
}

// OldPayload returns the old "payload" field's value of the ERPModuleRecord entity.
// If the ERPModuleRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPModuleRecordMutation) OldPayload(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayload: %w", err)
	}
	return oldValue.Payload, nil
}

// ResetPayload resets all changes to the "payload" field.
func (m *ERPModuleRecordMutation) ResetPayload() {
	m.payload = nil
}

// SetCreatedByAdminID sets the "created_by_admin_id" field.
func (m *ERPModuleRecordMutation) SetCreatedByAdminID(i int) {
	m.created_by_admin_id = &i
	m.addcreated_by_admin_id = nil
}

// CreatedByAdminID returns the value of the "created_by_admin_id" field in the mutation.
func (m *ERPModuleRecordMutation) CreatedByAdminID() (r int, exists bool) {
	v := m.created_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedByAdminID returns the old "created_by_admin_id" field's value of the ERPModuleRecord entity.
// If the ERPModuleRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPModuleRecordMutation) OldCreatedByAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedByAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedByAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedByAdminID: %w", err)
	}
	return oldValue.CreatedByAdminID, nil
}

// AddCreatedByAdminID adds i to the "created_by_admin_id" field.
func (m *ERPModuleRecordMutation) AddCreatedByAdminID(i int) {
	if m.addcreated_by_admin_id != nil {
		*m.addcreated_by_admin_id += i
	} else {
		m.addcreated_by_admin_id = &i
	}
}

// AddedCreatedByAdminID returns the value that was added to the "created_by_admin_id" field in this mutation.
func (m *ERPModuleRecordMutation) AddedCreatedByAdminID() (r int, exists bool) {
	v := m.addcreated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedByAdminID clears the value of the "created_by_admin_id" field.
func (m *ERPModuleRecordMutation) ClearCreatedByAdminID() {
	m.created_by_admin_id = nil
	m.addcreated_by_admin_id = nil
	m.clearedFields[erpmodulerecord.FieldCreatedByAdminID] = struct{}{}
}

// CreatedByAdminIDCleared returns if the "created_by_admin_id" field was cleared in this mutation.
func (m *ERPModuleRecordMutation) CreatedByAdminIDCleared() bool {
	_, ok := m.clearedFields[erpmodulerecord.FieldCreatedByAdminID]
	return ok
}

// ResetCreatedByAdminID resets all changes to the "created_by_admin_id" field.
func (m *ERPModuleRecordMutation) ResetCreatedByAdminID() {
	m.created_by_admin_id = nil
	m.addcreated_by_admin_id = nil
	delete(m.clearedFields, erpmodulerecord.FieldCreatedByAdminID)
}

// SetUpdatedByAdminID sets the "updated_by_admin_id" field.
func (m *ERPModuleRecordMutation) SetUpdatedByAdminID(i int) {
	m.updated_by_admin_id = &i
	m.addupdated_by_admin_id = nil
}

// UpdatedByAdminID returns the value of the "updated_by_admin_id" field in the mutation.
func (m *ERPModuleRecordMutation) UpdatedByAdminID() (r int, exists bool) {
	v := m.updated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedByAdminID returns the old "updated_by_admin_id" field's value of the ERPModuleRecord entity.
// If the ERPModuleRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPModuleRecordMutation) OldUpdatedByAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedByAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedByAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedByAdminID: %w", err)
	}
	return oldValue.UpdatedByAdminID, nil
}

// AddUpdatedByAdminID adds i to the "updated_by_admin_id" field.
func (m *ERPModuleRecordMutation) AddUpdatedByAdminID(i int) {
	if m.addupdated_by_admin_id != nil {
		*m.addupdated_by_admin_id += i
	} else {
		m.addupdated_by_admin_id = &i
	}
}

// AddedUpdatedByAdminID returns the value that was added to the "updated_by_admin_id" field in this mutation.
func (m *ERPModuleRecordMutation) AddedUpdatedByAdminID() (r int, exists bool) {
	v := m.addupdated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedByAdminID clears the value of the "updated_by_admin_id" field.
func (m *ERPModuleRecordMutation) ClearUpdatedByAdminID() {
	m.updated_by_admin_id = nil
	m.addupdated_by_admin_id = nil
	m.clearedFields[erpmodulerecord.FieldUpdatedByAdminID] = struct{}{}
}

// UpdatedByAdminIDCleared returns if the "updated_by_admin_id" field was cleared in this mutation.
func (m *ERPModuleRecordMutation) UpdatedByAdminIDCleared() bool {
	_, ok := m.clearedFields[erpmodulerecord.FieldUpdatedByAdminID]
	return ok
}

// ResetUpdatedByAdminID resets all changes to the "updated_by_admin_id" field.
func (m *ERPModuleRecordMutation) ResetUpdatedByAdminID() {
	m.updated_by_admin_id = nil
	m.addupdated_by_admin_id = nil
	delete(m.clearedFields, erpmodulerecord.FieldUpdatedByAdminID)
}

// SetCreatedAt sets the "created_at" field.
func (m *ERPModuleRecordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ERPModuleRecordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ERPModuleRecord entity.
// If the ERPModuleRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPModuleRecordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ERPModuleRecordMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ERPModuleRecordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ERPModuleRecordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ERPModuleRecord entity.
// If the ERPModuleRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPModuleRecordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ERPModuleRecordMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ERPModuleRecordMutation builder.
func (m *ERPModuleRecordMutation) Where(ps ...predicate.ERPModuleRecord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ERPModuleRecordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ERPModuleRecordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ERPModuleRecord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ERPModuleRecordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ERPModuleRecordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ERPModuleRecord).
func (m *ERPModuleRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ERPModuleRecordMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.module_key != nil {
		fields = append(fields, erpmodulerecord.FieldModuleKey)
	}
	if m.code != nil {
		fields = append(fields, erpmodulerecord.FieldCode)
	}
	if m.box != nil {
		fields = append(fields, erpmodulerecord.FieldBox)
	}
	if m.payload != nil {
		fields = append(fields, erpmodulerecord.FieldPayload)
	}
	if m.created_by_admin_id != nil {
		fields = append(fields, erpmodulerecord.FieldCreatedByAdminID)
	}
	if m.updated_by_admin_id != nil {
		fields = append(fields, erpmodulerecord.FieldUpdatedByAdminID)
	}
	if m.created_at != nil {
		fields = append(fields, erpmodulerecord.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, erpmodulerecord.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ERPModuleRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case erpmodulerecord.FieldModuleKey:
		return m.ModuleKey()
	case erpmodulerecord.FieldCode:
		return m.Code()
	case erpmodulerecord.FieldBox:
		return m.Box()
	case erpmodulerecord.FieldPayload:
		return m.Payload()
	case erpmodulerecord.FieldCreatedByAdminID:
		return m.CreatedByAdminID()
	case erpmodulerecord.FieldUpdatedByAdminID:
		return m.UpdatedByAdminID()
	case erpmodulerecord.FieldCreatedAt:
		return m.CreatedAt()
	case erpmodulerecord.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ERPModuleRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case erpmodulerecord.FieldModuleKey:
		return m.OldModuleKey(ctx)
	case erpmodulerecord.FieldCode:
		return m.OldCode(ctx)
	case erpmodulerecord.FieldBox:
		return m.OldBox(ctx)
	case erpmodulerecord.FieldPayload:
		return m.OldPayload(ctx)
	case erpmodulerecord.FieldCreatedByAdminID:
		return m.OldCreatedByAdminID(ctx)
	case erpmodulerecord.FieldUpdatedByAdminID:
		return m.OldUpdatedByAdminID(ctx)
	case erpmodulerecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case erpmodulerecord.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ERPModuleRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPModuleRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case erpmodulerecord.FieldModuleKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModuleKey(v)
		return nil
	case erpmodulerecord.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case erpmodulerecord.FieldBox:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBox(v)
		return nil
	case erpmodulerecord.FieldPayload:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayload(v)
		return nil
	case erpmodulerecord.FieldCreatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedByAdminID(v)
		return nil
	case erpmodulerecord.FieldUpdatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedByAdminID(v)
		return nil
	case erpmodulerecord.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case erpmodulerecord.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ERPModuleRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ERPModuleRecordMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by_admin_id != nil {
		fields = append(fields, erpmodulerecord.FieldCreatedByAdminID)
	}
	if m.addupdated_by_admin_id != nil {
		fields = append(fields, erpmodulerecord.FieldUpdatedByAdminID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ERPModuleRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case erpmodulerecord.FieldCreatedByAdminID:
		return m.AddedCreatedByAdminID()
	case erpmodulerecord.FieldUpdatedByAdminID:
		return m.AddedUpdatedByAdminID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPModuleRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case erpmodulerecord.FieldCreatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedByAdminID(v)
		return nil
	case erpmodulerecord.FieldUpdatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedByAdminID(v)
		return nil
	}
	return fmt.Errorf("unknown ERPModuleRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ERPModuleRecordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(erpmodulerecord.FieldCode) {
		fields = append(fields, erpmodulerecord.FieldCode)
	}
	if m.FieldCleared(erpmodulerecord.FieldBox) {
		fields = append(fields, erpmodulerecord.FieldBox)
	}
	if m.FieldCleared(erpmodulerecord.FieldCreatedByAdminID) {
		fields = append(fields, erpmodulerecord.FieldCreatedByAdminID)
	}
	if m.FieldCleared(erpmodulerecord.FieldUpdatedByAdminID) {
		fields = append(fields, erpmodulerecord.FieldUpdatedByAdminID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ERPModuleRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ERPModuleRecordMutation) ClearField(name string) error {
	switch name {
	case erpmodulerecord.FieldCode:
		m.ClearCode()
		return nil
	case erpmodulerecord.FieldBox:
		m.ClearBox()
		return nil
	case erpmodulerecord.FieldCreatedByAdminID:
		m.ClearCreatedByAdminID()
		return nil
	case erpmodulerecord.FieldUpdatedByAdminID:
		m.ClearUpdatedByAdminID()
		return nil
	}
	return fmt.Errorf("unknown ERPModuleRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ERPModuleRecordMutation) ResetField(name string) error {
	switch name {
	case erpmodulerecord.FieldModuleKey:
		m.ResetModuleKey()
		return nil
	case erpmodulerecord.FieldCode:
		m.ResetCode()
		return nil
	case erpmodulerecord.FieldBox:
		m.ResetBox()
		return nil
	case erpmodulerecord.FieldPayload:
		m.ResetPayload()
		return nil
	case erpmodulerecord.FieldCreatedByAdminID:
		m.ResetCreatedByAdminID()
		return nil
	case erpmodulerecord.FieldUpdatedByAdminID:
		m.ResetUpdatedByAdminID()
		return nil
	case erpmodulerecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case erpmodulerecord.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPModuleRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ERPModuleRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ERPModuleRecordMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ERPModuleRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ERPModuleRecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ERPModuleRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ERPModuleRecordMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ERPModuleRecordMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ERPModuleRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ERPModuleRecordMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ERPModuleRecord edge %s", name)
}

// ERPOutboundOrderMutation represents an operation that mutates the ERPOutboundOrder nodes in the graph.
type ERPOutboundOrderMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	code                   *string
	shipment_detail_id     *int
	addshipment_detail_id  *int
	source_shipment_code   *string
	warehouse_id           *int
	addwarehouse_id        *int
	location_id            *int
	addlocation_id         *int
	outbound_date          *time.Time
	total_quantity         *float64
	addtotal_quantity      *float64
	status                 *string
	remark                 *string
	created_by_admin_id    *int
	addcreated_by_admin_id *int
	updated_by_admin_id    *int
	addupdated_by_admin_id *int
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*ERPOutboundOrder, error)
	predicates             []predicate.ERPOutboundOrder
}

var _ ent.Mutation = (*ERPOutboundOrderMutation)(nil)

// erpoutboundorderOption allows management of the mutation configuration using functional options.
type erpoutboundorderOption func(*ERPOutboundOrderMutation)

// newERPOutboundOrderMutation creates new mutation for the ERPOutboundOrder entity.
func newERPOutboundOrderMutation(c config, op Op, opts ...erpoutboundorderOption) *ERPOutboundOrderMutation {
	m := &ERPOutboundOrderMutation{
		config:        c,
		op:            op,
		typ:           TypeERPOutboundOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withERPOutboundOrderID sets the ID field of the mutation.
func withERPOutboundOrderID(id int) erpoutboundorderOption {
	return func(m *ERPOutboundOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *ERPOutboundOrder
		)
		m.oldValue = func(ctx context.Context) (*ERPOutboundOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ERPOutboundOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withERPOutboundOrder sets the old ERPOutboundOrder of the mutation.
func withERPOutboundOrder(node *ERPOutboundOrder) erpoutboundorderOption {
	return func(m *ERPOutboundOrderMutation) {
		m.oldValue = func(context.Context) (*ERPOutboundOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ERPOutboundOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ERPOutboundOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ERPOutboundOrderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ERPOutboundOrderMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ERPOutboundOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *ERPOutboundOrderMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ERPOutboundOrderMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the ERPOutboundOrder entity.
// If the ERPOutboundOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPOutboundOrderMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ERPOutboundOrderMutation) ResetCode() {
	m.code = nil
}

// SetShipmentDetailID sets the "shipment_detail_id" field.
func (m *ERPOutboundOrderMutation) SetShipmentDetailID(i int) {
	m.shipment_detail_id = &i
	m.addshipment_detail_id = nil
}

// ShipmentDetailID returns the value of the "shipment_detail_id" field in the mutation.
func (m *ERPOutboundOrderMutation) ShipmentDetailID() (r int, exists bool) {
	v := m.shipment_detail_id
	if v == nil {
		return
	}
	return *v, true
}

// OldShipmentDetailID returns the old "shipment_detail_id" field's value of the ERPOutboundOrder entity.
// If the ERPOutboundOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPOutboundOrderMutation) OldShipmentDetailID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipmentDetailID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipmentDetailID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipmentDetailID: %w", err)
	}
	return oldValue.ShipmentDetailID, nil
}

// AddShipmentDetailID adds i to the "shipment_detail_id" field.
func (m *ERPOutboundOrderMutation) AddShipmentDetailID(i int) {
	if m.addshipment_detail_id != nil {
		*m.addshipment_detail_id += i
	} else {
		m.addshipment_detail_id = &i
	}
}

// AddedShipmentDetailID returns the value that was added to the "shipment_detail_id" field in this mutation.
func (m *ERPOutboundOrderMutation) AddedShipmentDetailID() (r int, exists bool) {
	v := m.addshipment_detail_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearShipmentDetailID clears the value of the "shipment_detail_id" field.
func (m *ERPOutboundOrderMutation) ClearShipmentDetailID() {
	m.shipment_detail_id = nil
	m.addshipment_detail_id = nil
	m.clearedFields[erpoutboundorder.FieldShipmentDetailID] = struct{}{}
}

// ShipmentDetailIDCleared returns if the "shipment_detail_id" field was cleared in this mutation.
func (m *ERPOutboundOrderMutation) ShipmentDetailIDCleared() bool {
	_, ok := m.clearedFields[erpoutboundorder.FieldShipmentDetailID]
	return ok
}

// ResetShipmentDetailID resets all changes to the "shipment_detail_id" field.
func (m *ERPOutboundOrderMutation) ResetShipmentDetailID() {
	m.shipment_detail_id = nil
	m.addshipment_detail_id = nil
	delete(m.clearedFields, erpoutboundorder.FieldShipmentDetailID)
}

// SetSourceShipmentCode sets the "source_shipment_code" field.
func (m *ERPOutboundOrderMutation) SetSourceShipmentCode(s string) {
	m.source_shipment_code = &s
}

// SourceShipmentCode returns the value of the "source_shipment_code" field in the mutation.
func (m *ERPOutboundOrderMutation) SourceShipmentCode() (r string, exists bool) {
	v := m.source_shipment_code
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceShipmentCode returns the old "source_shipment_code" field's value of the ERPOutboundOrder entity.
// If the ERPOutboundOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPOutboundOrderMutation) OldSourceShipmentCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceShipmentCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceShipmentCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceShipmentCode: %w", err)
	}
	return oldValue.SourceShipmentCode, nil
}

// ClearSourceShipmentCode clears the value of the "source_shipment_code" field.
func (m *ERPOutboundOrderMutation) ClearSourceShipmentCode() {
	m.source_shipment_code = nil
	m.clearedFields[erpoutboundorder.FieldSourceShipmentCode] = struct{}{}
}

// SourceShipmentCodeCleared returns if the "source_shipment_code" field was cleared in this mutation.
func (m *ERPOutboundOrderMutation) SourceShipmentCodeCleared() bool {
	_, ok := m.clearedFields[erpoutboundorder.FieldSourceShipmentCode]
	return ok
}

// ResetSourceShipmentCode resets all changes to the "source_shipment_code" field.
func (m *ERPOutboundOrderMutation) ResetSourceShipmentCode() {
	m.source_shipment_code = nil
	delete(m.clearedFields, erpoutboundorder.FieldSourceShipmentCode)
}

// SetWarehouseID sets the "warehouse_id" field.
func (m *ERPOutboundOrderMutation) SetWarehouseID(i int) {
	m.warehouse_id = &i
	m.addwarehouse_id = nil
}

// WarehouseID returns the value of the "warehouse_id" field in the mutation.
func (m *ERPOutboundOrderMutation) WarehouseID() (r int, exists bool) {
	v := m.warehouse_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWarehouseID returns the old "warehouse_id" field's value of the ERPOutboundOrder entity.
// If the ERPOutboundOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPOutboundOrderMutation) OldWarehouseID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWarehouseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWarehouseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWarehouseID: %w", err)
	}
	return oldValue.WarehouseID, nil
}

// AddWarehouseID adds i to the "warehouse_id" field.
func (m *ERPOutboundOrderMutation) AddWarehouseID(i int) {
	if m.addwarehouse_id != nil {
		*m.addwarehouse_id += i
	} else {
		m.addwarehouse_id = &i
	}
}

// AddedWarehouseID returns the value that was added to the "warehouse_id" field in this mutation.
func (m *ERPOutboundOrderMutation) AddedWarehouseID() (r int, exists bool) {
	v := m.addwarehouse_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearWarehouseID clears the value of the "warehouse_id" field.
func (m *ERPOutboundOrderMutation) ClearWarehouseID() {
	m.warehouse_id = nil
	m.addwarehouse_id = nil
	m.clearedFields[erpoutboundorder.FieldWarehouseID] = struct{}{}
}

// WarehouseIDCleared returns if the "warehouse_id" field was cleared in this mutation.
func (m *ERPOutboundOrderMutation) WarehouseIDCleared() bool {
	_, ok := m.clearedFields[erpoutboundorder.FieldWarehouseID]
	return ok
}

// ResetWarehouseID resets all changes to the "warehouse_id" field.
func (m *ERPOutboundOrderMutation) ResetWarehouseID() {
	m.warehouse_id = nil
	m.addwarehouse_id = nil
	delete(m.clearedFields, erpoutboundorder.FieldWarehouseID)
}

// SetLocationID sets the "location_id" field.
func (m *ERPOutboundOrderMutation) SetLocationID(i int) {
	m.location_id = &i
	m.addlocation_id = nil
}

// LocationID returns the value of the "location_id" field in the mutation.
func (m *ERPOutboundOrderMutation) LocationID() (r int, exists bool) {
	v := m.location_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationID returns the old "location_id" field's value of the ERPOutboundOrder entity.
// If the ERPOutboundOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPOutboundOrderMutation) OldLocationID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationID: %w", err)
	}
	return oldValue.LocationID, nil
}

// AddLocationID adds i to the "location_id" field.
func (m *ERPOutboundOrderMutation) AddLocationID(i int) {
	if m.addlocation_id != nil {
		*m.addlocation_id += i
	} else {
		m.addlocation_id = &i
	}
}

// AddedLocationID returns the value that was added to the "location_id" field in this mutation.
func (m *ERPOutboundOrderMutation) AddedLocationID() (r int, exists bool) {
	v := m.addlocation_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearLocationID clears the value of the "location_id" field.
func (m *ERPOutboundOrderMutation) ClearLocationID() {
	m.location_id = nil
	m.addlocation_id = nil
	m.clearedFields[erpoutboundorder.FieldLocationID] = struct{}{}
}

// LocationIDCleared returns if the "location_id" field was cleared in this mutation.
func (m *ERPOutboundOrderMutation) LocationIDCleared() bool {
	_, ok := m.clearedFields[erpoutboundorder.FieldLocationID]
	return ok
}

// ResetLocationID resets all changes to the "location_id" field.
func (m *ERPOutboundOrderMutation) ResetLocationID() {
	m.location_id = nil
	m.addlocation_id = nil
	delete(m.clearedFields, erpoutboundorder.FieldLocationID)
}

// SetOutboundDate sets the "outbound_date" field.
func (m *ERPOutboundOrderMutation) SetOutboundDate(t time.Time) {
	m.outbound_date = &t
}

// OutboundDate returns the value of the "outbound_date" field in the mutation.
func (m *ERPOutboundOrderMutation) OutboundDate() (r time.Time, exists bool) {
	v := m.outbound_date
	if v == nil {
		return
	}
	return *v, true
}

// OldOutboundDate returns the old "outbound_date" field's value of the ERPOutboundOrder entity.
// If the ERPOutboundOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPOutboundOrderMutation) OldOutboundDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutboundDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutboundDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutboundDate: %w", err)
	}
	return oldValue.OutboundDate, nil
}

// ResetOutboundDate resets all changes to the "outbound_date" field.
func (m *ERPOutboundOrderMutation) ResetOutboundDate() {
	m.outbound_date = nil
}

// SetTotalQuantity sets the "total_quantity" field.
func (m *ERPOutboundOrderMutation) SetTotalQuantity(f float64) {
	m.total_quantity = &f
	m.addtotal_quantity = nil
}

// TotalQuantity returns the value of the "total_quantity" field in the mutation.
func (m *ERPOutboundOrderMutation) TotalQuantity() (r float64, exists bool) {
	v := m.total_quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalQuantity returns the old "total_quantity" field's value of the ERPOutboundOrder entity.
// If the ERPOutboundOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPOutboundOrderMutation) OldTotalQuantity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalQuantity: %w", err)
	}
	return oldValue.TotalQuantity, nil
}

// AddTotalQuantity adds f to the "total_quantity" field.
func (m *ERPOutboundOrderMutation) AddTotalQuantity(f float64) {
	if m.addtotal_quantity != nil {
		*m.addtotal_quantity += f
	} else {
		m.addtotal_quantity = &f
	}
}

// AddedTotalQuantity returns the value that was added to the "total_quantity" field in this mutation.
func (m *ERPOutboundOrderMutation) AddedTotalQuantity() (r float64, exists bool) {
	v := m.addtotal_quantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalQuantity resets all changes to the "total_quantity" field.
func (m *ERPOutboundOrderMutation) ResetTotalQuantity() {
	m.total_quantity = nil
	m.addtotal_quantity = nil
}

// SetStatus sets the "status" field.
func (m *ERPOutboundOrderMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ERPOutboundOrderMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ERPOutboundOrder entity.
// If the ERPOutboundOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPOutboundOrderMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ERPOutboundOrderMutation) ResetStatus() {
	m.status = nil
}

// SetRemark sets the "remark" field.
func (m *ERPOutboundOrderMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ERPOutboundOrderMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the ERPOutboundOrder entity.
// If the ERPOutboundOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPOutboundOrderMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ERPOutboundOrderMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[erpoutboundorder.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ERPOutboundOrderMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[erpoutboundorder.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ERPOutboundOrderMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, erpoutboundorder.FieldRemark)
}

// SetCreatedByAdminID sets the "created_by_admin_id" field.
func (m *ERPOutboundOrderMutation) SetCreatedByAdminID(i int) {
	m.created_by_admin_id = &i
	m.addcreated_by_admin_id = nil
}

// CreatedByAdminID returns the value of the "created_by_admin_id" field in the mutation.
func (m *ERPOutboundOrderMutation) CreatedByAdminID() (r int, exists bool) {
	v := m.created_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedByAdminID returns the old "created_by_admin_id" field's value of the ERPOutboundOrder entity.
// If the ERPOutboundOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPOutboundOrderMutation) OldCreatedByAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedByAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedByAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedByAdminID: %w", err)
	}
	return oldValue.CreatedByAdminID, nil
}

// AddCreatedByAdminID adds i to the "created_by_admin_id" field.
func (m *ERPOutboundOrderMutation) AddCreatedByAdminID(i int) {
	if m.addcreated_by_admin_id != nil {
		*m.addcreated_by_admin_id += i
	} else {
		m.addcreated_by_admin_id = &i
	}
}

// AddedCreatedByAdminID returns the value that was added to the "created_by_admin_id" field in this mutation.
func (m *ERPOutboundOrderMutation) AddedCreatedByAdminID() (r int, exists bool) {
	v := m.addcreated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedByAdminID clears the value of the "created_by_admin_id" field.
func (m *ERPOutboundOrderMutation) ClearCreatedByAdminID() {
	m.created_by_admin_id = nil
	m.addcreated_by_admin_id = nil
	m.clearedFields[erpoutboundorder.FieldCreatedByAdminID] = struct{}{}
}

// CreatedByAdminIDCleared returns if the "created_by_admin_id" field was cleared in this mutation.
func (m *ERPOutboundOrderMutation) CreatedByAdminIDCleared() bool {
	_, ok := m.clearedFields[erpoutboundorder.FieldCreatedByAdminID]
	return ok
}

// ResetCreatedByAdminID resets all changes to the "created_by_admin_id" field.
func (m *ERPOutboundOrderMutation) ResetCreatedByAdminID() {
	m.created_by_admin_id = nil
	m.addcreated_by_admin_id = nil
	delete(m.clearedFields, erpoutboundorder.FieldCreatedByAdminID)
}

// SetUpdatedByAdminID sets the "updated_by_admin_id" field.
func (m *ERPOutboundOrderMutation) SetUpdatedByAdminID(i int) {
	m.updated_by_admin_id = &i
	m.addupdated_by_admin_id = nil
}

// UpdatedByAdminID returns the value of the "updated_by_admin_id" field in the mutation.
func (m *ERPOutboundOrderMutation) UpdatedByAdminID() (r int, exists bool) {
	v := m.updated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedByAdminID returns the old "updated_by_admin_id" field's value of the ERPOutboundOrder entity.
// If the ERPOutboundOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPOutboundOrderMutation) OldUpdatedByAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedByAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedByAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedByAdminID: %w", err)
	}
	return oldValue.UpdatedByAdminID, nil
}

// AddUpdatedByAdminID adds i to the "updated_by_admin_id" field.
func (m *ERPOutboundOrderMutation) AddUpdatedByAdminID(i int) {
	if m.addupdated_by_admin_id != nil {
		*m.addupdated_by_admin_id += i
	} else {
		m.addupdated_by_admin_id = &i
	}
}

// AddedUpdatedByAdminID returns the value that was added to the "updated_by_admin_id" field in this mutation.
func (m *ERPOutboundOrderMutation) AddedUpdatedByAdminID() (r int, exists bool) {
	v := m.addupdated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedByAdminID clears the value of the "updated_by_admin_id" field.
func (m *ERPOutboundOrderMutation) ClearUpdatedByAdminID() {
	m.updated_by_admin_id = nil
	m.addupdated_by_admin_id = nil
	m.clearedFields[erpoutboundorder.FieldUpdatedByAdminID] = struct{}{}
}

// UpdatedByAdminIDCleared returns if the "updated_by_admin_id" field was cleared in this mutation.
func (m *ERPOutboundOrderMutation) UpdatedByAdminIDCleared() bool {
	_, ok := m.clearedFields[erpoutboundorder.FieldUpdatedByAdminID]
	return ok
}

// ResetUpdatedByAdminID resets all changes to the "updated_by_admin_id" field.
func (m *ERPOutboundOrderMutation) ResetUpdatedByAdminID() {
	m.updated_by_admin_id = nil
	m.addupdated_by_admin_id = nil
	delete(m.clearedFields, erpoutboundorder.FieldUpdatedByAdminID)
}

// SetCreatedAt sets the "created_at" field.
func (m *ERPOutboundOrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ERPOutboundOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ERPOutboundOrder entity.
// If the ERPOutboundOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPOutboundOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ERPOutboundOrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ERPOutboundOrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ERPOutboundOrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ERPOutboundOrder entity.
// If the ERPOutboundOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPOutboundOrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ERPOutboundOrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ERPOutboundOrderMutation builder.
func (m *ERPOutboundOrderMutation) Where(ps ...predicate.ERPOutboundOrder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ERPOutboundOrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ERPOutboundOrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ERPOutboundOrder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ERPOutboundOrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ERPOutboundOrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ERPOutboundOrder).
func (m *ERPOutboundOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ERPOutboundOrderMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.code != nil {
		fields = append(fields, erpoutboundorder.FieldCode)
	}
	if m.shipment_detail_id != nil {
		fields = append(fields, erpoutboundorder.FieldShipmentDetailID)
	}
	if m.source_shipment_code != nil {
		fields = append(fields, erpoutboundorder.FieldSourceShipmentCode)
	}
	if m.warehouse_id != nil {
		fields = append(fields, erpoutboundorder.FieldWarehouseID)
	}
	if m.location_id != nil {
		fields = append(fields, erpoutboundorder.FieldLocationID)
	}
	if m.outbound_date != nil {
		fields = append(fields, erpoutboundorder.FieldOutboundDate)
	}
	if m.total_quantity != nil {
		fields = append(fields, erpoutboundorder.FieldTotalQuantity)
	}
	if m.status != nil {
		fields = append(fields, erpoutboundorder.FieldStatus)
	}
	if m.remark != nil {
		fields = append(fields, erpoutboundorder.FieldRemark)
	}
	if m.created_by_admin_id != nil {
		fields = append(fields, erpoutboundorder.FieldCreatedByAdminID)
	}
	if m.updated_by_admin_id != nil {
		fields = append(fields, erpoutboundorder.FieldUpdatedByAdminID)
	}
	if m.created_at != nil {
		fields = append(fields, erpoutboundorder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, erpoutboundorder.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ERPOutboundOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case erpoutboundorder.FieldCode:
		return m.Code()
	case erpoutboundorder.FieldShipmentDetailID:
		return m.ShipmentDetailID()
	case erpoutboundorder.FieldSourceShipmentCode:
		return m.SourceShipmentCode()
	case erpoutboundorder.FieldWarehouseID:
		return m.WarehouseID()
	case erpoutboundorder.FieldLocationID:
		return m.LocationID()
	case erpoutboundorder.FieldOutboundDate:
		return m.OutboundDate()
	case erpoutboundorder.FieldTotalQuantity:
		return m.TotalQuantity()
	case erpoutboundorder.FieldStatus:
		return m.Status()
	case erpoutboundorder.FieldRemark:
		return m.Remark()
	case erpoutboundorder.FieldCreatedByAdminID:
		return m.CreatedByAdminID()
	case erpoutboundorder.FieldUpdatedByAdminID:
		return m.UpdatedByAdminID()
	case erpoutboundorder.FieldCreatedAt:
		return m.CreatedAt()
	case erpoutboundorder.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ERPOutboundOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case erpoutboundorder.FieldCode:
		return m.OldCode(ctx)
	case erpoutboundorder.FieldShipmentDetailID:
		return m.OldShipmentDetailID(ctx)
	case erpoutboundorder.FieldSourceShipmentCode:
		return m.OldSourceShipmentCode(ctx)
	case erpoutboundorder.FieldWarehouseID:
		return m.OldWarehouseID(ctx)
	case erpoutboundorder.FieldLocationID:
		return m.OldLocationID(ctx)
	case erpoutboundorder.FieldOutboundDate:
		return m.OldOutboundDate(ctx)
	case erpoutboundorder.FieldTotalQuantity:
		return m.OldTotalQuantity(ctx)
	case erpoutboundorder.FieldStatus:
		return m.OldStatus(ctx)
	case erpoutboundorder.FieldRemark:
		return m.OldRemark(ctx)
	case erpoutboundorder.FieldCreatedByAdminID:
		return m.OldCreatedByAdminID(ctx)
	case erpoutboundorder.FieldUpdatedByAdminID:
		return m.OldUpdatedByAdminID(ctx)
	case erpoutboundorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case erpoutboundorder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ERPOutboundOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPOutboundOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case erpoutboundorder.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case erpoutboundorder.FieldShipmentDetailID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipmentDetailID(v)
		return nil
	case erpoutboundorder.FieldSourceShipmentCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceShipmentCode(v)
		return nil
	case erpoutboundorder.FieldWarehouseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWarehouseID(v)
		return nil
	case erpoutboundorder.FieldLocationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationID(v)
		return nil
	case erpoutboundorder.FieldOutboundDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutboundDate(v)
		return nil
	case erpoutboundorder.FieldTotalQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalQuantity(v)
		return nil
	case erpoutboundorder.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case erpoutboundorder.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case erpoutboundorder.FieldCreatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedByAdminID(v)
		return nil
	case erpoutboundorder.FieldUpdatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedByAdminID(v)
		return nil
	case erpoutboundorder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case erpoutboundorder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ERPOutboundOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ERPOutboundOrderMutation) AddedFields() []string {
	var fields []string
	if m.addshipment_detail_id != nil {
		fields = append(fields, erpoutboundorder.FieldShipmentDetailID)
	}
	if m.addwarehouse_id != nil {
		fields = append(fields, erpoutboundorder.FieldWarehouseID)
	}
	if m.addlocation_id != nil {
		fields = append(fields, erpoutboundorder.FieldLocationID)
	}
	if m.addtotal_quantity != nil {
		fields = append(fields, erpoutboundorder.FieldTotalQuantity)
	}
	if m.addcreated_by_admin_id != nil {
		fields = append(fields, erpoutboundorder.FieldCreatedByAdminID)
	}
	if m.addupdated_by_admin_id != nil {
		fields = append(fields, erpoutboundorder.FieldUpdatedByAdminID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ERPOutboundOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case erpoutboundorder.FieldShipmentDetailID:
		return m.AddedShipmentDetailID()
	case erpoutboundorder.FieldWarehouseID:
		return m.AddedWarehouseID()
	case erpoutboundorder.FieldLocationID:
		return m.AddedLocationID()
	case erpoutboundorder.FieldTotalQuantity:
		return m.AddedTotalQuantity()
	case erpoutboundorder.FieldCreatedByAdminID:
		return m.AddedCreatedByAdminID()
	case erpoutboundorder.FieldUpdatedByAdminID:
		return m.AddedUpdatedByAdminID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPOutboundOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case erpoutboundorder.FieldShipmentDetailID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShipmentDetailID(v)
		return nil
	case erpoutboundorder.FieldWarehouseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWarehouseID(v)
		return nil
	case erpoutboundorder.FieldLocationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLocationID(v)
		return nil
	case erpoutboundorder.FieldTotalQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalQuantity(v)
		return nil
	case erpoutboundorder.FieldCreatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedByAdminID(v)
		return nil
	case erpoutboundorder.FieldUpdatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedByAdminID(v)
		return nil
	}
	return fmt.Errorf("unknown ERPOutboundOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ERPOutboundOrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(erpoutboundorder.FieldShipmentDetailID) {
		fields = append(fields, erpoutboundorder.FieldShipmentDetailID)
	}
	if m.FieldCleared(erpoutboundorder.FieldSourceShipmentCode) {
		fields = append(fields, erpoutboundorder.FieldSourceShipmentCode)
	}
	if m.FieldCleared(erpoutboundorder.FieldWarehouseID) {
		fields = append(fields, erpoutboundorder.FieldWarehouseID)
	}
	if m.FieldCleared(erpoutboundorder.FieldLocationID) {
		fields = append(fields, erpoutboundorder.FieldLocationID)
	}
	if m.FieldCleared(erpoutboundorder.FieldRemark) {
		fields = append(fields, erpoutboundorder.FieldRemark)
	}
	if m.FieldCleared(erpoutboundorder.FieldCreatedByAdminID) {
		fields = append(fields, erpoutboundorder.FieldCreatedByAdminID)
	}
	if m.FieldCleared(erpoutboundorder.FieldUpdatedByAdminID) {
		fields = append(fields, erpoutboundorder.FieldUpdatedByAdminID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ERPOutboundOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ERPOutboundOrderMutation) ClearField(name string) error {
	switch name {
	case erpoutboundorder.FieldShipmentDetailID:
		m.ClearShipmentDetailID()
		return nil
	case erpoutboundorder.FieldSourceShipmentCode:
		m.ClearSourceShipmentCode()
		return nil
	case erpoutboundorder.FieldWarehouseID:
		m.ClearWarehouseID()
		return nil
	case erpoutboundorder.FieldLocationID:
		m.ClearLocationID()
		return nil
	case erpoutboundorder.FieldRemark:
		m.ClearRemark()
		return nil
	case erpoutboundorder.FieldCreatedByAdminID:
		m.ClearCreatedByAdminID()
		return nil
	case erpoutboundorder.FieldUpdatedByAdminID:
		m.ClearUpdatedByAdminID()
		return nil
	}
	return fmt.Errorf("unknown ERPOutboundOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ERPOutboundOrderMutation) ResetField(name string) error {
	switch name {
	case erpoutboundorder.FieldCode:
		m.ResetCode()
		return nil
	case erpoutboundorder.FieldShipmentDetailID:
		m.ResetShipmentDetailID()
		return nil
	case erpoutboundorder.FieldSourceShipmentCode:
		m.ResetSourceShipmentCode()
		return nil
	case erpoutboundorder.FieldWarehouseID:
		m.ResetWarehouseID()
		return nil
	case erpoutboundorder.FieldLocationID:
		m.ResetLocationID()
		return nil
	case erpoutboundorder.FieldOutboundDate:
		m.ResetOutboundDate()
		return nil
	case erpoutboundorder.FieldTotalQuantity:
		m.ResetTotalQuantity()
		return nil
	case erpoutboundorder.FieldStatus:
		m.ResetStatus()
		return nil
	case erpoutboundorder.FieldRemark:
		m.ResetRemark()
		return nil
	case erpoutboundorder.FieldCreatedByAdminID:
		m.ResetCreatedByAdminID()
		return nil
	case erpoutboundorder.FieldUpdatedByAdminID:
		m.ResetUpdatedByAdminID()
		return nil
	case erpoutboundorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case erpoutboundorder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPOutboundOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ERPOutboundOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ERPOutboundOrderMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ERPOutboundOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ERPOutboundOrderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ERPOutboundOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ERPOutboundOrderMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ERPOutboundOrderMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ERPOutboundOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ERPOutboundOrderMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ERPOutboundOrder edge %s", name)
}

// ERPOutboundOrderItemMutation represents an operation that mutates the ERPOutboundOrderItem nodes in the graph.
type ERPOutboundOrderItemMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	outbound_order_id    *int
	addoutbound_order_id *int
	line_no              *int
	addline_no           *int
	product_id           *int
	addproduct_id        *int
	product_code         *string
	lot_no               *string
	quantity             *float64
	addquantity          *float64
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*ERPOutboundOrderItem, error)
	predicates           []predicate.ERPOutboundOrderItem
}

var _ ent.Mutation = (*ERPOutboundOrderItemMutation)(nil)

// erpoutboundorderitemOption allows management of the mutation configuration using functional options.
type erpoutboundorderitemOption func(*ERPOutboundOrderItemMutation)

// newERPOutboundOrderItemMutation creates new mutation for the ERPOutboundOrderItem entity.
func newERPOutboundOrderItemMutation(c config, op Op, opts ...erpoutboundorderitemOption) *ERPOutboundOrderItemMutation {
	m := &ERPOutboundOrderItemMutation{
		config:        c,
		op:            op,
		typ:           TypeERPOutboundOrderItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withERPOutboundOrderItemID sets the ID field of the mutation.
func withERPOutboundOrderItemID(id int) erpoutboundorderitemOption {
	return func(m *ERPOutboundOrderItemMutation) {
		var (
			err   error
			once  sync.Once
			value *ERPOutboundOrderItem
		)
		m.oldValue = func(ctx context.Context) (*ERPOutboundOrderItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ERPOutboundOrderItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withERPOutboundOrderItem sets the old ERPOutboundOrderItem of the mutation.
func withERPOutboundOrderItem(node *ERPOutboundOrderItem) erpoutboundorderitemOption {
	return func(m *ERPOutboundOrderItemMutation) {
		m.oldValue = func(context.Context) (*ERPOutboundOrderItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ERPOutboundOrderItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ERPOutboundOrderItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ERPOutboundOrderItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ERPOutboundOrderItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ERPOutboundOrderItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOutboundOrderID sets the "outbound_order_id" field.
func (m *ERPOutboundOrderItemMutation) SetOutboundOrderID(i int) {
	m.outbound_order_id = &i
	m.addoutbound_order_id = nil
}

// OutboundOrderID returns the value of the "outbound_order_id" field in the mutation.
func (m *ERPOutboundOrderItemMutation) OutboundOrderID() (r int, exists bool) {
	v := m.outbound_order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOutboundOrderID returns the old "outbound_order_id" field's value of the ERPOutboundOrderItem entity.
// If the ERPOutboundOrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPOutboundOrderItemMutation) OldOutboundOrderID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutboundOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutboundOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutboundOrderID: %w", err)
	}
	return oldValue.OutboundOrderID, nil
}

// AddOutboundOrderID adds i to the "outbound_order_id" field.
func (m *ERPOutboundOrderItemMutation) AddOutboundOrderID(i int) {
	if m.addoutbound_order_id != nil {
		*m.addoutbound_order_id += i
	} else {
		m.addoutbound_order_id = &i
	}
}

// AddedOutboundOrderID returns the value that was added to the "outbound_order_id" field in this mutation.
func (m *ERPOutboundOrderItemMutation) AddedOutboundOrderID() (r int, exists bool) {
	v := m.addoutbound_order_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOutboundOrderID resets all changes to the "outbound_order_id" field.
func (m *ERPOutboundOrderItemMutation) ResetOutboundOrderID() {
	m.outbound_order_id = nil
	m.addoutbound_order_id = nil
}

// SetLineNo sets the "line_no" field.
func (m *ERPOutboundOrderItemMutation) SetLineNo(i int) {
	m.line_no = &i
	m.addline_no = nil
}

// LineNo returns the value of the "line_no" field in the mutation.
func (m *ERPOutboundOrderItemMutation) LineNo() (r int, exists bool) {
	v := m.line_no
	if v == nil {
		return
	}
	return *v, true
}

// OldLineNo returns the old "line_no" field's value of the ERPOutboundOrderItem entity.
// If the ERPOutboundOrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPOutboundOrderItemMutation) OldLineNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLineNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLineNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLineNo: %w", err)
	}
	return oldValue.LineNo, nil
}

// AddLineNo adds i to the "line_no" field.
func (m *ERPOutboundOrderItemMutation) AddLineNo(i int) {
	if m.addline_no != nil {
		*m.addline_no += i
	} else {
		m.addline_no = &i
	}
}

// AddedLineNo returns the value that was added to the "line_no" field in this mutation.
func (m *ERPOutboundOrderItemMutation) AddedLineNo() (r int, exists bool) {
	v := m.addline_no
	if v == nil {
		return
	}
	return *v, true
}

// ResetLineNo resets all changes to the "line_no" field.
func (m *ERPOutboundOrderItemMutation) ResetLineNo() {
	m.line_no = nil
	m.addline_no = nil
}

// SetProductID sets the "product_id" field.
func (m *ERPOutboundOrderItemMutation) SetProductID(i int) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ERPOutboundOrderItemMutation) ProductID() (r int, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the ERPOutboundOrderItem entity.
// If the ERPOutboundOrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPOutboundOrderItemMutation) OldProductID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *ERPOutboundOrderItemMutation) AddProductID(i int) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *ERPOutboundOrderItemMutation) AddedProductID() (r int, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductID clears the value of the "product_id" field.
func (m *ERPOutboundOrderItemMutation) ClearProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	m.clearedFields[erpoutboundorderitem.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *ERPOutboundOrderItemMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[erpoutboundorderitem.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ERPOutboundOrderItemMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	delete(m.clearedFields, erpoutboundorderitem.FieldProductID)
}

// SetProductCode sets the "product_code" field.
func (m *ERPOutboundOrderItemMutation) SetProductCode(s string) {
	m.product_code = &s
}

// ProductCode returns the value of the "product_code" field in the mutation.
func (m *ERPOutboundOrderItemMutation) ProductCode() (r string, exists bool) {
	v := m.product_code
	if v == nil {
		return
	}
	return *v, true
}

// OldProductCode returns the old "product_code" field's value of the ERPOutboundOrderItem entity.
// If the ERPOutboundOrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPOutboundOrderItemMutation) OldProductCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductCode: %w", err)
	}
	return oldValue.ProductCode, nil
}

// ClearProductCode clears the value of the "product_code" field.
func (m *ERPOutboundOrderItemMutation) ClearProductCode() {
	m.product_code = nil
	m.clearedFields[erpoutboundorderitem.FieldProductCode] = struct{}{}
}

// ProductCodeCleared returns if the "product_code" field was cleared in this mutation.
func (m *ERPOutboundOrderItemMutation) ProductCodeCleared() bool {
	_, ok := m.clearedFields[erpoutboundorderitem.FieldProductCode]
	return ok
}

// ResetProductCode resets all changes to the "product_code" field.
func (m *ERPOutboundOrderItemMutation) ResetProductCode() {
	m.product_code = nil
	delete(m.clearedFields, erpoutboundorderitem.FieldProductCode)
}

// SetLotNo sets the "lot_no" field.
func (m *ERPOutboundOrderItemMutation) SetLotNo(s string) {
	m.lot_no = &s
}

// LotNo returns the value of the "lot_no" field in the mutation.
func (m *ERPOutboundOrderItemMutation) LotNo() (r string, exists bool) {
	v := m.lot_no
	if v == nil {
		return
	}
	return *v, true
}

// OldLotNo returns the old "lot_no" field's value of the ERPOutboundOrderItem entity.
// If the ERPOutboundOrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPOutboundOrderItemMutation) OldLotNo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLotNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLotNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLotNo: %w", err)
	}
	return oldValue.LotNo, nil
}

// ClearLotNo clears the value of the "lot_no" field.
func (m *ERPOutboundOrderItemMutation) ClearLotNo() {
	m.lot_no = nil
	m.clearedFields[erpoutboundorderitem.FieldLotNo] = struct{}{}
}

// LotNoCleared returns if the "lot_no" field was cleared in this mutation.
func (m *ERPOutboundOrderItemMutation) LotNoCleared() bool {
	_, ok := m.clearedFields[erpoutboundorderitem.FieldLotNo]
	return ok
}

// ResetLotNo resets all changes to the "lot_no" field.
func (m *ERPOutboundOrderItemMutation) ResetLotNo() {
	m.lot_no = nil
	delete(m.clearedFields, erpoutboundorderitem.FieldLotNo)
}

// SetQuantity sets the "quantity" field.
func (m *ERPOutboundOrderItemMutation) SetQuantity(f float64) {
	m.quantity = &f
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *ERPOutboundOrderItemMutation) Quantity() (r float64, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the ERPOutboundOrderItem entity.
// If the ERPOutboundOrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPOutboundOrderItemMutation) OldQuantity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds f to the "quantity" field.
func (m *ERPOutboundOrderItemMutation) AddQuantity(f float64) {
	if m.addquantity != nil {
		*m.addquantity += f
	} else {
		m.addquantity = &f
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *ERPOutboundOrderItemMutation) AddedQuantity() (r float64, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *ERPOutboundOrderItemMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ERPOutboundOrderItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ERPOutboundOrderItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ERPOutboundOrderItem entity.
// If the ERPOutboundOrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPOutboundOrderItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ERPOutboundOrderItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ERPOutboundOrderItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ERPOutboundOrderItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ERPOutboundOrderItem entity.
// If the ERPOutboundOrderItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPOutboundOrderItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ERPOutboundOrderItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ERPOutboundOrderItemMutation builder.
func (m *ERPOutboundOrderItemMutation) Where(ps ...predicate.ERPOutboundOrderItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ERPOutboundOrderItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ERPOutboundOrderItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ERPOutboundOrderItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ERPOutboundOrderItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ERPOutboundOrderItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ERPOutboundOrderItem).
func (m *ERPOutboundOrderItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ERPOutboundOrderItemMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.outbound_order_id != nil {
		fields = append(fields, erpoutboundorderitem.FieldOutboundOrderID)
	}
	if m.line_no != nil {
		fields = append(fields, erpoutboundorderitem.FieldLineNo)
	}
	if m.product_id != nil {
		fields = append(fields, erpoutboundorderitem.FieldProductID)
	}
	if m.product_code != nil {
		fields = append(fields, erpoutboundorderitem.FieldProductCode)
	}
	if m.lot_no != nil {
		fields = append(fields, erpoutboundorderitem.FieldLotNo)
	}
	if m.quantity != nil {
		fields = append(fields, erpoutboundorderitem.FieldQuantity)
	}
	if m.created_at != nil {
		fields = append(fields, erpoutboundorderitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, erpoutboundorderitem.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ERPOutboundOrderItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case erpoutboundorderitem.FieldOutboundOrderID:
		return m.OutboundOrderID()
	case erpoutboundorderitem.FieldLineNo:
		return m.LineNo()
	case erpoutboundorderitem.FieldProductID:
		return m.ProductID()
	case erpoutboundorderitem.FieldProductCode:
		return m.ProductCode()
	case erpoutboundorderitem.FieldLotNo:
		return m.LotNo()
	case erpoutboundorderitem.FieldQuantity:
		return m.Quantity()
	case erpoutboundorderitem.FieldCreatedAt:
		return m.CreatedAt()
	case erpoutboundorderitem.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ERPOutboundOrderItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case erpoutboundorderitem.FieldOutboundOrderID:
		return m.OldOutboundOrderID(ctx)
	case erpoutboundorderitem.FieldLineNo:
		return m.OldLineNo(ctx)
	case erpoutboundorderitem.FieldProductID:
		return m.OldProductID(ctx)
	case erpoutboundorderitem.FieldProductCode:
		return m.OldProductCode(ctx)
	case erpoutboundorderitem.FieldLotNo:
		return m.OldLotNo(ctx)
	case erpoutboundorderitem.FieldQuantity:
		return m.OldQuantity(ctx)
	case erpoutboundorderitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case erpoutboundorderitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ERPOutboundOrderItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPOutboundOrderItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case erpoutboundorderitem.FieldOutboundOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutboundOrderID(v)
		return nil
	case erpoutboundorderitem.FieldLineNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLineNo(v)
		return nil
	case erpoutboundorderitem.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case erpoutboundorderitem.FieldProductCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductCode(v)
		return nil
	case erpoutboundorderitem.FieldLotNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLotNo(v)
		return nil
	case erpoutboundorderitem.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case erpoutboundorderitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case erpoutboundorderitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ERPOutboundOrderItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ERPOutboundOrderItemMutation) AddedFields() []string {
	var fields []string
	if m.addoutbound_order_id != nil {
		fields = append(fields, erpoutboundorderitem.FieldOutboundOrderID)
	}
	if m.addline_no != nil {
		fields = append(fields, erpoutboundorderitem.FieldLineNo)
	}
	if m.addproduct_id != nil {
		fields = append(fields, erpoutboundorderitem.FieldProductID)
	}
	if m.addquantity != nil {
		fields = append(fields, erpoutboundorderitem.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ERPOutboundOrderItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case erpoutboundorderitem.FieldOutboundOrderID:
		return m.AddedOutboundOrderID()
	case erpoutboundorderitem.FieldLineNo:
		return m.AddedLineNo()
	case erpoutboundorderitem.FieldProductID:
		return m.AddedProductID()
	case erpoutboundorderitem.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPOutboundOrderItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case erpoutboundorderitem.FieldOutboundOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutboundOrderID(v)
		return nil
	case erpoutboundorderitem.FieldLineNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLineNo(v)
		return nil
	case erpoutboundorderitem.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case erpoutboundorderitem.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown ERPOutboundOrderItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ERPOutboundOrderItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(erpoutboundorderitem.FieldProductID) {
		fields = append(fields, erpoutboundorderitem.FieldProductID)
	}
	if m.FieldCleared(erpoutboundorderitem.FieldProductCode) {
		fields = append(fields, erpoutboundorderitem.FieldProductCode)
	}
	if m.FieldCleared(erpoutboundorderitem.FieldLotNo) {
		fields = append(fields, erpoutboundorderitem.FieldLotNo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ERPOutboundOrderItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ERPOutboundOrderItemMutation) ClearField(name string) error {
	switch name {
	case erpoutboundorderitem.FieldProductID:
		m.ClearProductID()
		return nil
	case erpoutboundorderitem.FieldProductCode:
		m.ClearProductCode()
		return nil
	case erpoutboundorderitem.FieldLotNo:
		m.ClearLotNo()
		return nil
	}
	return fmt.Errorf("unknown ERPOutboundOrderItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ERPOutboundOrderItemMutation) ResetField(name string) error {
	switch name {
	case erpoutboundorderitem.FieldOutboundOrderID:
		m.ResetOutboundOrderID()
		return nil
	case erpoutboundorderitem.FieldLineNo:
		m.ResetLineNo()
		return nil
	case erpoutboundorderitem.FieldProductID:
		m.ResetProductID()
		return nil
	case erpoutboundorderitem.FieldProductCode:
		m.ResetProductCode()
		return nil
	case erpoutboundorderitem.FieldLotNo:
		m.ResetLotNo()
		return nil
	case erpoutboundorderitem.FieldQuantity:
		m.ResetQuantity()
		return nil
	case erpoutboundorderitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case erpoutboundorderitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPOutboundOrderItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ERPOutboundOrderItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ERPOutboundOrderItemMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ERPOutboundOrderItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ERPOutboundOrderItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ERPOutboundOrderItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ERPOutboundOrderItemMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ERPOutboundOrderItemMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ERPOutboundOrderItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ERPOutboundOrderItemMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ERPOutboundOrderItem edge %s", name)
}

// ERPPartnerMutation represents an operation that mutates the ERPPartner nodes in the graph.
type ERPPartnerMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	code                   *string
	partner_type           *string
	name                   *string
	short_name             *string
	tax_no                 *string
	currency               *string
	payment_cycle_days     *int
	addpayment_cycle_days  *int
	address                *string
	contact                *string
	contact_phone          *string
	email                  *string
	disabled               *bool
	extra_json             *string
	created_by_admin_id    *int
	addcreated_by_admin_id *int
	updated_by_admin_id    *int
	addupdated_by_admin_id *int
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*ERPPartner, error)
	predicates             []predicate.ERPPartner
}

var _ ent.Mutation = (*ERPPartnerMutation)(nil)

// erppartnerOption allows management of the mutation configuration using functional options.
type erppartnerOption func(*ERPPartnerMutation)

// newERPPartnerMutation creates new mutation for the ERPPartner entity.
func newERPPartnerMutation(c config, op Op, opts ...erppartnerOption) *ERPPartnerMutation {
	m := &ERPPartnerMutation{
		config:        c,
		op:            op,
		typ:           TypeERPPartner,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withERPPartnerID sets the ID field of the mutation.
func withERPPartnerID(id int) erppartnerOption {
	return func(m *ERPPartnerMutation) {
		var (
			err   error
			once  sync.Once
			value *ERPPartner
		)
		m.oldValue = func(ctx context.Context) (*ERPPartner, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ERPPartner.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withERPPartner sets the old ERPPartner of the mutation.
func withERPPartner(node *ERPPartner) erppartnerOption {
	return func(m *ERPPartnerMutation) {
		m.oldValue = func(context.Context) (*ERPPartner, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ERPPartnerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ERPPartnerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ERPPartnerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ERPPartnerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ERPPartner.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *ERPPartnerMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ERPPartnerMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the ERPPartner entity.
// If the ERPPartner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPartnerMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ERPPartnerMutation) ResetCode() {
	m.code = nil
}

// SetPartnerType sets the "partner_type" field.
func (m *ERPPartnerMutation) SetPartnerType(s string) {
	m.partner_type = &s
}

// PartnerType returns the value of the "partner_type" field in the mutation.
func (m *ERPPartnerMutation) PartnerType() (r string, exists bool) {
	v := m.partner_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPartnerType returns the old "partner_type" field's value of the ERPPartner entity.
// If the ERPPartner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPartnerMutation) OldPartnerType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPartnerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPartnerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPartnerType: %w", err)
	}
	return oldValue.PartnerType, nil
}

// ResetPartnerType resets all changes to the "partner_type" field.
func (m *ERPPartnerMutation) ResetPartnerType() {
	m.partner_type = nil
}

// SetName sets the "name" field.
func (m *ERPPartnerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ERPPartnerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ERPPartner entity.
// If the ERPPartner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPartnerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ERPPartnerMutation) ResetName() {
	m.name = nil
}

// SetShortName sets the "short_name" field.
func (m *ERPPartnerMutation) SetShortName(s string) {
	m.short_name = &s
}

// ShortName returns the value of the "short_name" field in the mutation.
func (m *ERPPartnerMutation) ShortName() (r string, exists bool) {
	v := m.short_name
	if v == nil {
		return
	}
	return *v, true
}

// OldShortName returns the old "short_name" field's value of the ERPPartner entity.
// If the ERPPartner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPartnerMutation) OldShortName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShortName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShortName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShortName: %w", err)
	}
	return oldValue.ShortName, nil
}

// ClearShortName clears the value of the "short_name" field.
func (m *ERPPartnerMutation) ClearShortName() {
	m.short_name = nil
	m.clearedFields[erppartner.FieldShortName] = struct{}{}
}

// ShortNameCleared returns if the "short_name" field was cleared in this mutation.
func (m *ERPPartnerMutation) ShortNameCleared() bool {
	_, ok := m.clearedFields[erppartner.FieldShortName]
	return ok
}

// ResetShortName resets all changes to the "short_name" field.
func (m *ERPPartnerMutation) ResetShortName() {
	m.short_name = nil
	delete(m.clearedFields, erppartner.FieldShortName)
}

// SetTaxNo sets the "tax_no" field.
func (m *ERPPartnerMutation) SetTaxNo(s string) {
	m.tax_no = &s
}

// TaxNo returns the value of the "tax_no" field in the mutation.
func (m *ERPPartnerMutation) TaxNo() (r string, exists bool) {
	v := m.tax_no
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxNo returns the old "tax_no" field's value of the ERPPartner entity.
// If the ERPPartner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPartnerMutation) OldTaxNo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxNo: %w", err)
	}
	return oldValue.TaxNo, nil
}

// ClearTaxNo clears the value of the "tax_no" field.
func (m *ERPPartnerMutation) ClearTaxNo() {
	m.tax_no = nil
	m.clearedFields[erppartner.FieldTaxNo] = struct{}{}
}

// TaxNoCleared returns if the "tax_no" field was cleared in this mutation.
func (m *ERPPartnerMutation) TaxNoCleared() bool {
	_, ok := m.clearedFields[erppartner.FieldTaxNo]
	return ok
}

// ResetTaxNo resets all changes to the "tax_no" field.
func (m *ERPPartnerMutation) ResetTaxNo() {
	m.tax_no = nil
	delete(m.clearedFields, erppartner.FieldTaxNo)
}

// SetCurrency sets the "currency" field.
func (m *ERPPartnerMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *ERPPartnerMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the ERPPartner entity.
// If the ERPPartner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPartnerMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *ERPPartnerMutation) ResetCurrency() {
	m.currency = nil
}

// SetPaymentCycleDays sets the "payment_cycle_days" field.
func (m *ERPPartnerMutation) SetPaymentCycleDays(i int) {
	m.payment_cycle_days = &i
	m.addpayment_cycle_days = nil
}

// PaymentCycleDays returns the value of the "payment_cycle_days" field in the mutation.
func (m *ERPPartnerMutation) PaymentCycleDays() (r int, exists bool) {
	v := m.payment_cycle_days
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentCycleDays returns the old "payment_cycle_days" field's value of the ERPPartner entity.
// If the ERPPartner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPartnerMutation) OldPaymentCycleDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentCycleDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentCycleDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentCycleDays: %w", err)
	}
	return oldValue.PaymentCycleDays, nil
}

// AddPaymentCycleDays adds i to the "payment_cycle_days" field.
func (m *ERPPartnerMutation) AddPaymentCycleDays(i int) {
	if m.addpayment_cycle_days != nil {
		*m.addpayment_cycle_days += i
	} else {
		m.addpayment_cycle_days = &i
	}
}

// AddedPaymentCycleDays returns the value that was added to the "payment_cycle_days" field in this mutation.
func (m *ERPPartnerMutation) AddedPaymentCycleDays() (r int, exists bool) {
	v := m.addpayment_cycle_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetPaymentCycleDays resets all changes to the "payment_cycle_days" field.
func (m *ERPPartnerMutation) ResetPaymentCycleDays() {
	m.payment_cycle_days = nil
	m.addpayment_cycle_days = nil
}

// SetAddress sets the "address" field.
func (m *ERPPartnerMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *ERPPartnerMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the ERPPartner entity.
// If the ERPPartner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPartnerMutation) OldAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *ERPPartnerMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[erppartner.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *ERPPartnerMutation) AddressCleared() bool {
	_, ok := m.clearedFields[erppartner.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *ERPPartnerMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, erppartner.FieldAddress)
}

// SetContact sets the "contact" field.
func (m *ERPPartnerMutation) SetContact(s string) {
	m.contact = &s
}

// Contact returns the value of the "contact" field in the mutation.
func (m *ERPPartnerMutation) Contact() (r string, exists bool) {
	v := m.contact
	if v == nil {
		return
	}
	return *v, true
}

// OldContact returns the old "contact" field's value of the ERPPartner entity.
// If the ERPPartner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPartnerMutation) OldContact(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContact: %w", err)
	}
	return oldValue.Contact, nil
}

// ClearContact clears the value of the "contact" field.
func (m *ERPPartnerMutation) ClearContact() {
	m.contact = nil
	m.clearedFields[erppartner.FieldContact] = struct{}{}
}

// ContactCleared returns if the "contact" field was cleared in this mutation.
func (m *ERPPartnerMutation) ContactCleared() bool {
	_, ok := m.clearedFields[erppartner.FieldContact]
	return ok
}

// ResetContact resets all changes to the "contact" field.
func (m *ERPPartnerMutation) ResetContact() {
	m.contact = nil
	delete(m.clearedFields, erppartner.FieldContact)
}

// SetContactPhone sets the "contact_phone" field.
func (m *ERPPartnerMutation) SetContactPhone(s string) {
	m.contact_phone = &s
}

// ContactPhone returns the value of the "contact_phone" field in the mutation.
func (m *ERPPartnerMutation) ContactPhone() (r string, exists bool) {
	v := m.contact_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldContactPhone returns the old "contact_phone" field's value of the ERPPartner entity.
// If the ERPPartner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPartnerMutation) OldContactPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactPhone: %w", err)
	}
	return oldValue.ContactPhone, nil
}

// ClearContactPhone clears the value of the "contact_phone" field.
func (m *ERPPartnerMutation) ClearContactPhone() {
	m.contact_phone = nil
	m.clearedFields[erppartner.FieldContactPhone] = struct{}{}
}

// ContactPhoneCleared returns if the "contact_phone" field was cleared in this mutation.
func (m *ERPPartnerMutation) ContactPhoneCleared() bool {
	_, ok := m.clearedFields[erppartner.FieldContactPhone]
	return ok
}

// ResetContactPhone resets all changes to the "contact_phone" field.
func (m *ERPPartnerMutation) ResetContactPhone() {
	m.contact_phone = nil
	delete(m.clearedFields, erppartner.FieldContactPhone)
}

// SetEmail sets the "email" field.
func (m *ERPPartnerMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *ERPPartnerMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the ERPPartner entity.
// If the ERPPartner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPartnerMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *ERPPartnerMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[erppartner.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *ERPPartnerMutation) EmailCleared() bool {
	_, ok := m.clearedFields[erppartner.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *ERPPartnerMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, erppartner.FieldEmail)
}

// SetDisabled sets the "disabled" field.
func (m *ERPPartnerMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *ERPPartnerMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the ERPPartner entity.
// If the ERPPartner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPartnerMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *ERPPartnerMutation) ResetDisabled() {
	m.disabled = nil
}

// SetExtraJSON sets the "extra_json" field.
func (m *ERPPartnerMutation) SetExtraJSON(s string) {
	m.extra_json = &s
}

// ExtraJSON returns the value of the "extra_json" field in the mutation.
func (m *ERPPartnerMutation) ExtraJSON() (r string, exists bool) {
	v := m.extra_json
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraJSON returns the old "extra_json" field's value of the ERPPartner entity.
// If the ERPPartner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPartnerMutation) OldExtraJSON(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraJSON is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraJSON requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraJSON: %w", err)
	}
	return oldValue.ExtraJSON, nil
}

// ClearExtraJSON clears the value of the "extra_json" field.
func (m *ERPPartnerMutation) ClearExtraJSON() {
	m.extra_json = nil
	m.clearedFields[erppartner.FieldExtraJSON] = struct{}{}
}

// ExtraJSONCleared returns if the "extra_json" field was cleared in this mutation.
func (m *ERPPartnerMutation) ExtraJSONCleared() bool {
	_, ok := m.clearedFields[erppartner.FieldExtraJSON]
	return ok
}

// ResetExtraJSON resets all changes to the "extra_json" field.
func (m *ERPPartnerMutation) ResetExtraJSON() {
	m.extra_json = nil
	delete(m.clearedFields, erppartner.FieldExtraJSON)
}

// SetCreatedByAdminID sets the "created_by_admin_id" field.
func (m *ERPPartnerMutation) SetCreatedByAdminID(i int) {
	m.created_by_admin_id = &i
	m.addcreated_by_admin_id = nil
}

// CreatedByAdminID returns the value of the "created_by_admin_id" field in the mutation.
func (m *ERPPartnerMutation) CreatedByAdminID() (r int, exists bool) {
	v := m.created_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedByAdminID returns the old "created_by_admin_id" field's value of the ERPPartner entity.
// If the ERPPartner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPartnerMutation) OldCreatedByAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedByAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedByAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedByAdminID: %w", err)
	}
	return oldValue.CreatedByAdminID, nil
}

// AddCreatedByAdminID adds i to the "created_by_admin_id" field.
func (m *ERPPartnerMutation) AddCreatedByAdminID(i int) {
	if m.addcreated_by_admin_id != nil {
		*m.addcreated_by_admin_id += i
	} else {
		m.addcreated_by_admin_id = &i
	}
}

// AddedCreatedByAdminID returns the value that was added to the "created_by_admin_id" field in this mutation.
func (m *ERPPartnerMutation) AddedCreatedByAdminID() (r int, exists bool) {
	v := m.addcreated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedByAdminID clears the value of the "created_by_admin_id" field.
func (m *ERPPartnerMutation) ClearCreatedByAdminID() {
	m.created_by_admin_id = nil
	m.addcreated_by_admin_id = nil
	m.clearedFields[erppartner.FieldCreatedByAdminID] = struct{}{}
}

// CreatedByAdminIDCleared returns if the "created_by_admin_id" field was cleared in this mutation.
func (m *ERPPartnerMutation) CreatedByAdminIDCleared() bool {
	_, ok := m.clearedFields[erppartner.FieldCreatedByAdminID]
	return ok
}

// ResetCreatedByAdminID resets all changes to the "created_by_admin_id" field.
func (m *ERPPartnerMutation) ResetCreatedByAdminID() {
	m.created_by_admin_id = nil
	m.addcreated_by_admin_id = nil
	delete(m.clearedFields, erppartner.FieldCreatedByAdminID)
}

// SetUpdatedByAdminID sets the "updated_by_admin_id" field.
func (m *ERPPartnerMutation) SetUpdatedByAdminID(i int) {
	m.updated_by_admin_id = &i
	m.addupdated_by_admin_id = nil
}

// UpdatedByAdminID returns the value of the "updated_by_admin_id" field in the mutation.
func (m *ERPPartnerMutation) UpdatedByAdminID() (r int, exists bool) {
	v := m.updated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedByAdminID returns the old "updated_by_admin_id" field's value of the ERPPartner entity.
// If the ERPPartner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPartnerMutation) OldUpdatedByAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedByAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedByAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedByAdminID: %w", err)
	}
	return oldValue.UpdatedByAdminID, nil
}

// AddUpdatedByAdminID adds i to the "updated_by_admin_id" field.
func (m *ERPPartnerMutation) AddUpdatedByAdminID(i int) {
	if m.addupdated_by_admin_id != nil {
		*m.addupdated_by_admin_id += i
	} else {
		m.addupdated_by_admin_id = &i
	}
}

// AddedUpdatedByAdminID returns the value that was added to the "updated_by_admin_id" field in this mutation.
func (m *ERPPartnerMutation) AddedUpdatedByAdminID() (r int, exists bool) {
	v := m.addupdated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedByAdminID clears the value of the "updated_by_admin_id" field.
func (m *ERPPartnerMutation) ClearUpdatedByAdminID() {
	m.updated_by_admin_id = nil
	m.addupdated_by_admin_id = nil
	m.clearedFields[erppartner.FieldUpdatedByAdminID] = struct{}{}
}

// UpdatedByAdminIDCleared returns if the "updated_by_admin_id" field was cleared in this mutation.
func (m *ERPPartnerMutation) UpdatedByAdminIDCleared() bool {
	_, ok := m.clearedFields[erppartner.FieldUpdatedByAdminID]
	return ok
}

// ResetUpdatedByAdminID resets all changes to the "updated_by_admin_id" field.
func (m *ERPPartnerMutation) ResetUpdatedByAdminID() {
	m.updated_by_admin_id = nil
	m.addupdated_by_admin_id = nil
	delete(m.clearedFields, erppartner.FieldUpdatedByAdminID)
}

// SetCreatedAt sets the "created_at" field.
func (m *ERPPartnerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ERPPartnerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ERPPartner entity.
// If the ERPPartner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPartnerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ERPPartnerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ERPPartnerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ERPPartnerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ERPPartner entity.
// If the ERPPartner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPartnerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ERPPartnerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ERPPartnerMutation builder.
func (m *ERPPartnerMutation) Where(ps ...predicate.ERPPartner) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ERPPartnerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ERPPartnerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ERPPartner, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ERPPartnerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ERPPartnerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ERPPartner).
func (m *ERPPartnerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ERPPartnerMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.code != nil {
		fields = append(fields, erppartner.FieldCode)
	}
	if m.partner_type != nil {
		fields = append(fields, erppartner.FieldPartnerType)
	}
	if m.name != nil {
		fields = append(fields, erppartner.FieldName)
	}
	if m.short_name != nil {
		fields = append(fields, erppartner.FieldShortName)
	}
	if m.tax_no != nil {
		fields = append(fields, erppartner.FieldTaxNo)
	}
	if m.currency != nil {
		fields = append(fields, erppartner.FieldCurrency)
	}
	if m.payment_cycle_days != nil {
		fields = append(fields, erppartner.FieldPaymentCycleDays)
	}
	if m.address != nil {
		fields = append(fields, erppartner.FieldAddress)
	}
	if m.contact != nil {
		fields = append(fields, erppartner.FieldContact)
	}
	if m.contact_phone != nil {
		fields = append(fields, erppartner.FieldContactPhone)
	}
	if m.email != nil {
		fields = append(fields, erppartner.FieldEmail)
	}
	if m.disabled != nil {
		fields = append(fields, erppartner.FieldDisabled)
	}
	if m.extra_json != nil {
		fields = append(fields, erppartner.FieldExtraJSON)
	}
	if m.created_by_admin_id != nil {
		fields = append(fields, erppartner.FieldCreatedByAdminID)
	}
	if m.updated_by_admin_id != nil {
		fields = append(fields, erppartner.FieldUpdatedByAdminID)
	}
	if m.created_at != nil {
		fields = append(fields, erppartner.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, erppartner.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ERPPartnerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case erppartner.FieldCode:
		return m.Code()
	case erppartner.FieldPartnerType:
		return m.PartnerType()
	case erppartner.FieldName:
		return m.Name()
	case erppartner.FieldShortName:
		return m.ShortName()
	case erppartner.FieldTaxNo:
		return m.TaxNo()
	case erppartner.FieldCurrency:
		return m.Currency()
	case erppartner.FieldPaymentCycleDays:
		return m.PaymentCycleDays()
	case erppartner.FieldAddress:
		return m.Address()
	case erppartner.FieldContact:
		return m.Contact()
	case erppartner.FieldContactPhone:
		return m.ContactPhone()
	case erppartner.FieldEmail:
		return m.Email()
	case erppartner.FieldDisabled:
		return m.Disabled()
	case erppartner.FieldExtraJSON:
		return m.ExtraJSON()
	case erppartner.FieldCreatedByAdminID:
		return m.CreatedByAdminID()
	case erppartner.FieldUpdatedByAdminID:
		return m.UpdatedByAdminID()
	case erppartner.FieldCreatedAt:
		return m.CreatedAt()
	case erppartner.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ERPPartnerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case erppartner.FieldCode:
		return m.OldCode(ctx)
	case erppartner.FieldPartnerType:
		return m.OldPartnerType(ctx)
	case erppartner.FieldName:
		return m.OldName(ctx)
	case erppartner.FieldShortName:
		return m.OldShortName(ctx)
	case erppartner.FieldTaxNo:
		return m.OldTaxNo(ctx)
	case erppartner.FieldCurrency:
		return m.OldCurrency(ctx)
	case erppartner.FieldPaymentCycleDays:
		return m.OldPaymentCycleDays(ctx)
	case erppartner.FieldAddress:
		return m.OldAddress(ctx)
	case erppartner.FieldContact:
		return m.OldContact(ctx)
	case erppartner.FieldContactPhone:
		return m.OldContactPhone(ctx)
	case erppartner.FieldEmail:
		return m.OldEmail(ctx)
	case erppartner.FieldDisabled:
		return m.OldDisabled(ctx)
	case erppartner.FieldExtraJSON:
		return m.OldExtraJSON(ctx)
	case erppartner.FieldCreatedByAdminID:
		return m.OldCreatedByAdminID(ctx)
	case erppartner.FieldUpdatedByAdminID:
		return m.OldUpdatedByAdminID(ctx)
	case erppartner.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case erppartner.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ERPPartner field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPPartnerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case erppartner.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case erppartner.FieldPartnerType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPartnerType(v)
		return nil
	case erppartner.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case erppartner.FieldShortName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShortName(v)
		return nil
	case erppartner.FieldTaxNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxNo(v)
		return nil
	case erppartner.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case erppartner.FieldPaymentCycleDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentCycleDays(v)
		return nil
	case erppartner.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case erppartner.FieldContact:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContact(v)
		return nil
	case erppartner.FieldContactPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactPhone(v)
		return nil
	case erppartner.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case erppartner.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case erppartner.FieldExtraJSON:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraJSON(v)
		return nil
	case erppartner.FieldCreatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedByAdminID(v)
		return nil
	case erppartner.FieldUpdatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedByAdminID(v)
		return nil
	case erppartner.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case erppartner.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ERPPartner field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ERPPartnerMutation) AddedFields() []string {
	var fields []string
	if m.addpayment_cycle_days != nil {
		fields = append(fields, erppartner.FieldPaymentCycleDays)
	}
	if m.addcreated_by_admin_id != nil {
		fields = append(fields, erppartner.FieldCreatedByAdminID)
	}
	if m.addupdated_by_admin_id != nil {
		fields = append(fields, erppartner.FieldUpdatedByAdminID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ERPPartnerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case erppartner.FieldPaymentCycleDays:
		return m.AddedPaymentCycleDays()
	case erppartner.FieldCreatedByAdminID:
		return m.AddedCreatedByAdminID()
	case erppartner.FieldUpdatedByAdminID:
		return m.AddedUpdatedByAdminID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPPartnerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case erppartner.FieldPaymentCycleDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPaymentCycleDays(v)
		return nil
	case erppartner.FieldCreatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedByAdminID(v)
		return nil
	case erppartner.FieldUpdatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedByAdminID(v)
		return nil
	}
	return fmt.Errorf("unknown ERPPartner numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ERPPartnerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(erppartner.FieldShortName) {
		fields = append(fields, erppartner.FieldShortName)
	}
	if m.FieldCleared(erppartner.FieldTaxNo) {
		fields = append(fields, erppartner.FieldTaxNo)
	}
	if m.FieldCleared(erppartner.FieldAddress) {
		fields = append(fields, erppartner.FieldAddress)
	}
	if m.FieldCleared(erppartner.FieldContact) {
		fields = append(fields, erppartner.FieldContact)
	}
	if m.FieldCleared(erppartner.FieldContactPhone) {
		fields = append(fields, erppartner.FieldContactPhone)
	}
	if m.FieldCleared(erppartner.FieldEmail) {
		fields = append(fields, erppartner.FieldEmail)
	}
	if m.FieldCleared(erppartner.FieldExtraJSON) {
		fields = append(fields, erppartner.FieldExtraJSON)
	}
	if m.FieldCleared(erppartner.FieldCreatedByAdminID) {
		fields = append(fields, erppartner.FieldCreatedByAdminID)
	}
	if m.FieldCleared(erppartner.FieldUpdatedByAdminID) {
		fields = append(fields, erppartner.FieldUpdatedByAdminID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ERPPartnerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ERPPartnerMutation) ClearField(name string) error {
	switch name {
	case erppartner.FieldShortName:
		m.ClearShortName()
		return nil
	case erppartner.FieldTaxNo:
		m.ClearTaxNo()
		return nil
	case erppartner.FieldAddress:
		m.ClearAddress()
		return nil
	case erppartner.FieldContact:
		m.ClearContact()
		return nil
	case erppartner.FieldContactPhone:
		m.ClearContactPhone()
		return nil
	case erppartner.FieldEmail:
		m.ClearEmail()
		return nil
	case erppartner.FieldExtraJSON:
		m.ClearExtraJSON()
		return nil
	case erppartner.FieldCreatedByAdminID:
		m.ClearCreatedByAdminID()
		return nil
	case erppartner.FieldUpdatedByAdminID:
		m.ClearUpdatedByAdminID()
		return nil
	}
	return fmt.Errorf("unknown ERPPartner nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ERPPartnerMutation) ResetField(name string) error {
	switch name {
	case erppartner.FieldCode:
		m.ResetCode()
		return nil
	case erppartner.FieldPartnerType:
		m.ResetPartnerType()
		return nil
	case erppartner.FieldName:
		m.ResetName()
		return nil
	case erppartner.FieldShortName:
		m.ResetShortName()
		return nil
	case erppartner.FieldTaxNo:
		m.ResetTaxNo()
		return nil
	case erppartner.FieldCurrency:
		m.ResetCurrency()
		return nil
	case erppartner.FieldPaymentCycleDays:
		m.ResetPaymentCycleDays()
		return nil
	case erppartner.FieldAddress:
		m.ResetAddress()
		return nil
	case erppartner.FieldContact:
		m.ResetContact()
		return nil
	case erppartner.FieldContactPhone:
		m.ResetContactPhone()
		return nil
	case erppartner.FieldEmail:
		m.ResetEmail()
		return nil
	case erppartner.FieldDisabled:
		m.ResetDisabled()
		return nil
	case erppartner.FieldExtraJSON:
		m.ResetExtraJSON()
		return nil
	case erppartner.FieldCreatedByAdminID:
		m.ResetCreatedByAdminID()
		return nil
	case erppartner.FieldUpdatedByAdminID:
		m.ResetUpdatedByAdminID()
		return nil
	case erppartner.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case erppartner.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPPartner field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ERPPartnerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ERPPartnerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ERPPartnerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ERPPartnerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ERPPartnerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ERPPartnerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ERPPartnerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ERPPartner unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ERPPartnerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ERPPartner edge %s", name)
}

// ERPProductMutation represents an operation that mutates the ERPProduct nodes in the graph.
type ERPProductMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	code                   *string
	hs_code                *string
	spec_code              *string
	drawing_no             *string
	cn_desc                *string
	en_desc                *string
	unit                   *string
	disabled               *bool
	extra_json             *string
	created_by_admin_id    *int
	addcreated_by_admin_id *int
	updated_by_admin_id    *int
	addupdated_by_admin_id *int
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*ERPProduct, error)
	predicates             []predicate.ERPProduct
}

var _ ent.Mutation = (*ERPProductMutation)(nil)

// erpproductOption allows management of the mutation configuration using functional options.
type erpproductOption func(*ERPProductMutation)

// newERPProductMutation creates new mutation for the ERPProduct entity.
func newERPProductMutation(c config, op Op, opts ...erpproductOption) *ERPProductMutation {
	m := &ERPProductMutation{
		config:        c,
		op:            op,
		typ:           TypeERPProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withERPProductID sets the ID field of the mutation.
func withERPProductID(id int) erpproductOption {
	return func(m *ERPProductMutation) {
		var (
			err   error
			once  sync.Once
			value *ERPProduct
		)
		m.oldValue = func(ctx context.Context) (*ERPProduct, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ERPProduct.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withERPProduct sets the old ERPProduct of the mutation.
func withERPProduct(node *ERPProduct) erpproductOption {
	return func(m *ERPProductMutation) {
		m.oldValue = func(context.Context) (*ERPProduct, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ERPProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ERPProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ERPProductMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ERPProductMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ERPProduct.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *ERPProductMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ERPProductMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the ERPProduct entity.
// If the ERPProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPProductMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ERPProductMutation) ResetCode() {
	m.code = nil
}

// SetHsCode sets the "hs_code" field.
func (m *ERPProductMutation) SetHsCode(s string) {
	m.hs_code = &s
}

// HsCode returns the value of the "hs_code" field in the mutation.
func (m *ERPProductMutation) HsCode() (r string, exists bool) {
	v := m.hs_code
	if v == nil {
		return
	}
	return *v, true
}

// OldHsCode returns the old "hs_code" field's value of the ERPProduct entity.
// If the ERPProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPProductMutation) OldHsCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHsCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHsCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHsCode: %w", err)
	}
	return oldValue.HsCode, nil
}

// ClearHsCode clears the value of the "hs_code" field.
func (m *ERPProductMutation) ClearHsCode() {
	m.hs_code = nil
	m.clearedFields[erpproduct.FieldHsCode] = struct{}{}
}

// HsCodeCleared returns if the "hs_code" field was cleared in this mutation.
func (m *ERPProductMutation) HsCodeCleared() bool {
	_, ok := m.clearedFields[erpproduct.FieldHsCode]
	return ok
}

// ResetHsCode resets all changes to the "hs_code" field.
func (m *ERPProductMutation) ResetHsCode() {
	m.hs_code = nil
	delete(m.clearedFields, erpproduct.FieldHsCode)
}

// SetSpecCode sets the "spec_code" field.
func (m *ERPProductMutation) SetSpecCode(s string) {
	m.spec_code = &s
}

// SpecCode returns the value of the "spec_code" field in the mutation.
func (m *ERPProductMutation) SpecCode() (r string, exists bool) {
	v := m.spec_code
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecCode returns the old "spec_code" field's value of the ERPProduct entity.
// If the ERPProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPProductMutation) OldSpecCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpecCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpecCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecCode: %w", err)
	}
	return oldValue.SpecCode, nil
}

// ClearSpecCode clears the value of the "spec_code" field.
func (m *ERPProductMutation) ClearSpecCode() {
	m.spec_code = nil
	m.clearedFields[erpproduct.FieldSpecCode] = struct{}{}
}

// SpecCodeCleared returns if the "spec_code" field was cleared in this mutation.
func (m *ERPProductMutation) SpecCodeCleared() bool {
	_, ok := m.clearedFields[erpproduct.FieldSpecCode]
	return ok
}

// ResetSpecCode resets all changes to the "spec_code" field.
func (m *ERPProductMutation) ResetSpecCode() {
	m.spec_code = nil
	delete(m.clearedFields, erpproduct.FieldSpecCode)
}

// SetDrawingNo sets the "drawing_no" field.
func (m *ERPProductMutation) SetDrawingNo(s string) {
	m.drawing_no = &s
}

// DrawingNo returns the value of the "drawing_no" field in the mutation.
func (m *ERPProductMutation) DrawingNo() (r string, exists bool) {
	v := m.drawing_no
	if v == nil {
		return
	}
	return *v, true
}

// OldDrawingNo returns the old "drawing_no" field's value of the ERPProduct entity.
// If the ERPProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPProductMutation) OldDrawingNo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDrawingNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDrawingNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDrawingNo: %w", err)
	}
	return oldValue.DrawingNo, nil
}

// ClearDrawingNo clears the value of the "drawing_no" field.
func (m *ERPProductMutation) ClearDrawingNo() {
	m.drawing_no = nil
	m.clearedFields[erpproduct.FieldDrawingNo] = struct{}{}
}

// DrawingNoCleared returns if the "drawing_no" field was cleared in this mutation.
func (m *ERPProductMutation) DrawingNoCleared() bool {
	_, ok := m.clearedFields[erpproduct.FieldDrawingNo]
	return ok
}

// ResetDrawingNo resets all changes to the "drawing_no" field.
func (m *ERPProductMutation) ResetDrawingNo() {
	m.drawing_no = nil
	delete(m.clearedFields, erpproduct.FieldDrawingNo)
}

// SetCnDesc sets the "cn_desc" field.
func (m *ERPProductMutation) SetCnDesc(s string) {
	m.cn_desc = &s
}

// CnDesc returns the value of the "cn_desc" field in the mutation.
func (m *ERPProductMutation) CnDesc() (r string, exists bool) {
	v := m.cn_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldCnDesc returns the old "cn_desc" field's value of the ERPProduct entity.
// If the ERPProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPProductMutation) OldCnDesc(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCnDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCnDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCnDesc: %w", err)
	}
	return oldValue.CnDesc, nil
}

// ClearCnDesc clears the value of the "cn_desc" field.
func (m *ERPProductMutation) ClearCnDesc() {
	m.cn_desc = nil
	m.clearedFields[erpproduct.FieldCnDesc] = struct{}{}
}

// CnDescCleared returns if the "cn_desc" field was cleared in this mutation.
func (m *ERPProductMutation) CnDescCleared() bool {
	_, ok := m.clearedFields[erpproduct.FieldCnDesc]
	return ok
}

// ResetCnDesc resets all changes to the "cn_desc" field.
func (m *ERPProductMutation) ResetCnDesc() {
	m.cn_desc = nil
	delete(m.clearedFields, erpproduct.FieldCnDesc)
}

// SetEnDesc sets the "en_desc" field.
func (m *ERPProductMutation) SetEnDesc(s string) {
	m.en_desc = &s
}

// EnDesc returns the value of the "en_desc" field in the mutation.
func (m *ERPProductMutation) EnDesc() (r string, exists bool) {
	v := m.en_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldEnDesc returns the old "en_desc" field's value of the ERPProduct entity.
// If the ERPProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPProductMutation) OldEnDesc(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnDesc: %w", err)
	}
	return oldValue.EnDesc, nil
}

// ClearEnDesc clears the value of the "en_desc" field.
func (m *ERPProductMutation) ClearEnDesc() {
	m.en_desc = nil
	m.clearedFields[erpproduct.FieldEnDesc] = struct{}{}
}

// EnDescCleared returns if the "en_desc" field was cleared in this mutation.
func (m *ERPProductMutation) EnDescCleared() bool {
	_, ok := m.clearedFields[erpproduct.FieldEnDesc]
	return ok
}

// ResetEnDesc resets all changes to the "en_desc" field.
func (m *ERPProductMutation) ResetEnDesc() {
	m.en_desc = nil
	delete(m.clearedFields, erpproduct.FieldEnDesc)
}

// SetUnit sets the "unit" field.
func (m *ERPProductMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the value of the "unit" field in the mutation.
func (m *ERPProductMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the ERPProduct entity.
// If the ERPProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPProductMutation) OldUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ResetUnit resets all changes to the "unit" field.
func (m *ERPProductMutation) ResetUnit() {
	m.unit = nil
}

// SetDisabled sets the "disabled" field.
func (m *ERPProductMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *ERPProductMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the ERPProduct entity.
// If the ERPProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPProductMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *ERPProductMutation) ResetDisabled() {
	m.disabled = nil
}

// SetExtraJSON sets the "extra_json" field.
func (m *ERPProductMutation) SetExtraJSON(s string) {
	m.extra_json = &s
}

// ExtraJSON returns the value of the "extra_json" field in the mutation.
func (m *ERPProductMutation) ExtraJSON() (r string, exists bool) {
	v := m.extra_json
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraJSON returns the old "extra_json" field's value of the ERPProduct entity.
// If the ERPProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPProductMutation) OldExtraJSON(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraJSON is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraJSON requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraJSON: %w", err)
	}
	return oldValue.ExtraJSON, nil
}

// ClearExtraJSON clears the value of the "extra_json" field.
func (m *ERPProductMutation) ClearExtraJSON() {
	m.extra_json = nil
	m.clearedFields[erpproduct.FieldExtraJSON] = struct{}{}
}

// ExtraJSONCleared returns if the "extra_json" field was cleared in this mutation.
func (m *ERPProductMutation) ExtraJSONCleared() bool {
	_, ok := m.clearedFields[erpproduct.FieldExtraJSON]
	return ok
}

// ResetExtraJSON resets all changes to the "extra_json" field.
func (m *ERPProductMutation) ResetExtraJSON() {
	m.extra_json = nil
	delete(m.clearedFields, erpproduct.FieldExtraJSON)
}

// SetCreatedByAdminID sets the "created_by_admin_id" field.
func (m *ERPProductMutation) SetCreatedByAdminID(i int) {
	m.created_by_admin_id = &i
	m.addcreated_by_admin_id = nil
}

// CreatedByAdminID returns the value of the "created_by_admin_id" field in the mutation.
func (m *ERPProductMutation) CreatedByAdminID() (r int, exists bool) {
	v := m.created_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedByAdminID returns the old "created_by_admin_id" field's value of the ERPProduct entity.
// If the ERPProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPProductMutation) OldCreatedByAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedByAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedByAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedByAdminID: %w", err)
	}
	return oldValue.CreatedByAdminID, nil
}

// AddCreatedByAdminID adds i to the "created_by_admin_id" field.
func (m *ERPProductMutation) AddCreatedByAdminID(i int) {
	if m.addcreated_by_admin_id != nil {
		*m.addcreated_by_admin_id += i
	} else {
		m.addcreated_by_admin_id = &i
	}
}

// AddedCreatedByAdminID returns the value that was added to the "created_by_admin_id" field in this mutation.
func (m *ERPProductMutation) AddedCreatedByAdminID() (r int, exists bool) {
	v := m.addcreated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedByAdminID clears the value of the "created_by_admin_id" field.
func (m *ERPProductMutation) ClearCreatedByAdminID() {
	m.created_by_admin_id = nil
	m.addcreated_by_admin_id = nil
	m.clearedFields[erpproduct.FieldCreatedByAdminID] = struct{}{}
}

// CreatedByAdminIDCleared returns if the "created_by_admin_id" field was cleared in this mutation.
func (m *ERPProductMutation) CreatedByAdminIDCleared() bool {
	_, ok := m.clearedFields[erpproduct.FieldCreatedByAdminID]
	return ok
}

// ResetCreatedByAdminID resets all changes to the "created_by_admin_id" field.
func (m *ERPProductMutation) ResetCreatedByAdminID() {
	m.created_by_admin_id = nil
	m.addcreated_by_admin_id = nil
	delete(m.clearedFields, erpproduct.FieldCreatedByAdminID)
}

// SetUpdatedByAdminID sets the "updated_by_admin_id" field.
func (m *ERPProductMutation) SetUpdatedByAdminID(i int) {
	m.updated_by_admin_id = &i
	m.addupdated_by_admin_id = nil
}

// UpdatedByAdminID returns the value of the "updated_by_admin_id" field in the mutation.
func (m *ERPProductMutation) UpdatedByAdminID() (r int, exists bool) {
	v := m.updated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedByAdminID returns the old "updated_by_admin_id" field's value of the ERPProduct entity.
// If the ERPProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPProductMutation) OldUpdatedByAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedByAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedByAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedByAdminID: %w", err)
	}
	return oldValue.UpdatedByAdminID, nil
}

// AddUpdatedByAdminID adds i to the "updated_by_admin_id" field.
func (m *ERPProductMutation) AddUpdatedByAdminID(i int) {
	if m.addupdated_by_admin_id != nil {
		*m.addupdated_by_admin_id += i
	} else {
		m.addupdated_by_admin_id = &i
	}
}

// AddedUpdatedByAdminID returns the value that was added to the "updated_by_admin_id" field in this mutation.
func (m *ERPProductMutation) AddedUpdatedByAdminID() (r int, exists bool) {
	v := m.addupdated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedByAdminID clears the value of the "updated_by_admin_id" field.
func (m *ERPProductMutation) ClearUpdatedByAdminID() {
	m.updated_by_admin_id = nil
	m.addupdated_by_admin_id = nil
	m.clearedFields[erpproduct.FieldUpdatedByAdminID] = struct{}{}
}

// UpdatedByAdminIDCleared returns if the "updated_by_admin_id" field was cleared in this mutation.
func (m *ERPProductMutation) UpdatedByAdminIDCleared() bool {
	_, ok := m.clearedFields[erpproduct.FieldUpdatedByAdminID]
	return ok
}

// ResetUpdatedByAdminID resets all changes to the "updated_by_admin_id" field.
func (m *ERPProductMutation) ResetUpdatedByAdminID() {
	m.updated_by_admin_id = nil
	m.addupdated_by_admin_id = nil
	delete(m.clearedFields, erpproduct.FieldUpdatedByAdminID)
}

// SetCreatedAt sets the "created_at" field.
func (m *ERPProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ERPProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ERPProduct entity.
// If the ERPProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ERPProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ERPProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ERPProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ERPProduct entity.
// If the ERPProduct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ERPProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ERPProductMutation builder.
func (m *ERPProductMutation) Where(ps ...predicate.ERPProduct) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ERPProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ERPProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ERPProduct, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ERPProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ERPProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ERPProduct).
func (m *ERPProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ERPProductMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.code != nil {
		fields = append(fields, erpproduct.FieldCode)
	}
	if m.hs_code != nil {
		fields = append(fields, erpproduct.FieldHsCode)
	}
	if m.spec_code != nil {
		fields = append(fields, erpproduct.FieldSpecCode)
	}
	if m.drawing_no != nil {
		fields = append(fields, erpproduct.FieldDrawingNo)
	}
	if m.cn_desc != nil {
		fields = append(fields, erpproduct.FieldCnDesc)
	}
	if m.en_desc != nil {
		fields = append(fields, erpproduct.FieldEnDesc)
	}
	if m.unit != nil {
		fields = append(fields, erpproduct.FieldUnit)
	}
	if m.disabled != nil {
		fields = append(fields, erpproduct.FieldDisabled)
	}
	if m.extra_json != nil {
		fields = append(fields, erpproduct.FieldExtraJSON)
	}
	if m.created_by_admin_id != nil {
		fields = append(fields, erpproduct.FieldCreatedByAdminID)
	}
	if m.updated_by_admin_id != nil {
		fields = append(fields, erpproduct.FieldUpdatedByAdminID)
	}
	if m.created_at != nil {
		fields = append(fields, erpproduct.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, erpproduct.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ERPProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case erpproduct.FieldCode:
		return m.Code()
	case erpproduct.FieldHsCode:
		return m.HsCode()
	case erpproduct.FieldSpecCode:
		return m.SpecCode()
	case erpproduct.FieldDrawingNo:
		return m.DrawingNo()
	case erpproduct.FieldCnDesc:
		return m.CnDesc()
	case erpproduct.FieldEnDesc:
		return m.EnDesc()
	case erpproduct.FieldUnit:
		return m.Unit()
	case erpproduct.FieldDisabled:
		return m.Disabled()
	case erpproduct.FieldExtraJSON:
		return m.ExtraJSON()
	case erpproduct.FieldCreatedByAdminID:
		return m.CreatedByAdminID()
	case erpproduct.FieldUpdatedByAdminID:
		return m.UpdatedByAdminID()
	case erpproduct.FieldCreatedAt:
		return m.CreatedAt()
	case erpproduct.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ERPProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case erpproduct.FieldCode:
		return m.OldCode(ctx)
	case erpproduct.FieldHsCode:
		return m.OldHsCode(ctx)
	case erpproduct.FieldSpecCode:
		return m.OldSpecCode(ctx)
	case erpproduct.FieldDrawingNo:
		return m.OldDrawingNo(ctx)
	case erpproduct.FieldCnDesc:
		return m.OldCnDesc(ctx)
	case erpproduct.FieldEnDesc:
		return m.OldEnDesc(ctx)
	case erpproduct.FieldUnit:
		return m.OldUnit(ctx)
	case erpproduct.FieldDisabled:
		return m.OldDisabled(ctx)
	case erpproduct.FieldExtraJSON:
		return m.OldExtraJSON(ctx)
	case erpproduct.FieldCreatedByAdminID:
		return m.OldCreatedByAdminID(ctx)
	case erpproduct.FieldUpdatedByAdminID:
		return m.OldUpdatedByAdminID(ctx)
	case erpproduct.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case erpproduct.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ERPProduct field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case erpproduct.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case erpproduct.FieldHsCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHsCode(v)
		return nil
	case erpproduct.FieldSpecCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecCode(v)
		return nil
	case erpproduct.FieldDrawingNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDrawingNo(v)
		return nil
	case erpproduct.FieldCnDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCnDesc(v)
		return nil
	case erpproduct.FieldEnDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnDesc(v)
		return nil
	case erpproduct.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case erpproduct.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case erpproduct.FieldExtraJSON:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraJSON(v)
		return nil
	case erpproduct.FieldCreatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedByAdminID(v)
		return nil
	case erpproduct.FieldUpdatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedByAdminID(v)
		return nil
	case erpproduct.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case erpproduct.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ERPProduct field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ERPProductMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by_admin_id != nil {
		fields = append(fields, erpproduct.FieldCreatedByAdminID)
	}
	if m.addupdated_by_admin_id != nil {
		fields = append(fields, erpproduct.FieldUpdatedByAdminID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ERPProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case erpproduct.FieldCreatedByAdminID:
		return m.AddedCreatedByAdminID()
	case erpproduct.FieldUpdatedByAdminID:
		return m.AddedUpdatedByAdminID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case erpproduct.FieldCreatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedByAdminID(v)
		return nil
	case erpproduct.FieldUpdatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedByAdminID(v)
		return nil
	}
	return fmt.Errorf("unknown ERPProduct numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ERPProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(erpproduct.FieldHsCode) {
		fields = append(fields, erpproduct.FieldHsCode)
	}
	if m.FieldCleared(erpproduct.FieldSpecCode) {
		fields = append(fields, erpproduct.FieldSpecCode)
	}
	if m.FieldCleared(erpproduct.FieldDrawingNo) {
		fields = append(fields, erpproduct.FieldDrawingNo)
	}
	if m.FieldCleared(erpproduct.FieldCnDesc) {
		fields = append(fields, erpproduct.FieldCnDesc)
	}
	if m.FieldCleared(erpproduct.FieldEnDesc) {
		fields = append(fields, erpproduct.FieldEnDesc)
	}
	if m.FieldCleared(erpproduct.FieldExtraJSON) {
		fields = append(fields, erpproduct.FieldExtraJSON)
	}
	if m.FieldCleared(erpproduct.FieldCreatedByAdminID) {
		fields = append(fields, erpproduct.FieldCreatedByAdminID)
	}
	if m.FieldCleared(erpproduct.FieldUpdatedByAdminID) {
		fields = append(fields, erpproduct.FieldUpdatedByAdminID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ERPProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ERPProductMutation) ClearField(name string) error {
	switch name {
	case erpproduct.FieldHsCode:
		m.ClearHsCode()
		return nil
	case erpproduct.FieldSpecCode:
		m.ClearSpecCode()
		return nil
	case erpproduct.FieldDrawingNo:
		m.ClearDrawingNo()
		return nil
	case erpproduct.FieldCnDesc:
		m.ClearCnDesc()
		return nil
	case erpproduct.FieldEnDesc:
		m.ClearEnDesc()
		return nil
	case erpproduct.FieldExtraJSON:
		m.ClearExtraJSON()
		return nil
	case erpproduct.FieldCreatedByAdminID:
		m.ClearCreatedByAdminID()
		return nil
	case erpproduct.FieldUpdatedByAdminID:
		m.ClearUpdatedByAdminID()
		return nil
	}
	return fmt.Errorf("unknown ERPProduct nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ERPProductMutation) ResetField(name string) error {
	switch name {
	case erpproduct.FieldCode:
		m.ResetCode()
		return nil
	case erpproduct.FieldHsCode:
		m.ResetHsCode()
		return nil
	case erpproduct.FieldSpecCode:
		m.ResetSpecCode()
		return nil
	case erpproduct.FieldDrawingNo:
		m.ResetDrawingNo()
		return nil
	case erpproduct.FieldCnDesc:
		m.ResetCnDesc()
		return nil
	case erpproduct.FieldEnDesc:
		m.ResetEnDesc()
		return nil
	case erpproduct.FieldUnit:
		m.ResetUnit()
		return nil
	case erpproduct.FieldDisabled:
		m.ResetDisabled()
		return nil
	case erpproduct.FieldExtraJSON:
		m.ResetExtraJSON()
		return nil
	case erpproduct.FieldCreatedByAdminID:
		m.ResetCreatedByAdminID()
		return nil
	case erpproduct.FieldUpdatedByAdminID:
		m.ResetUpdatedByAdminID()
		return nil
	case erpproduct.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case erpproduct.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPProduct field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ERPProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ERPProductMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ERPProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ERPProductMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ERPProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ERPProductMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ERPProductMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ERPProduct unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ERPProductMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ERPProduct edge %s", name)
}

// ERPPurchaseContractMutation represents an operation that mutates the ERPPurchaseContract nodes in the graph.
type ERPPurchaseContractMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	code                   *string
	export_sale_id         *int
	addexport_sale_id      *int
	source_export_code     *string
	supplier_partner_id    *int
	addsupplier_partner_id *int
	supplier_code          *string
	sign_date              *time.Time
	sales_no               *string
	delivery_date          *time.Time
	delivery_address       *string
	follower               *string
	buyer                  *string
	invoice_required       *bool
	total_amount           *float64
	addtotal_amount        *float64
	status                 *string
	remark                 *string
	created_by_admin_id    *int
	addcreated_by_admin_id *int
	updated_by_admin_id    *int
	addupdated_by_admin_id *int
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*ERPPurchaseContract, error)
	predicates             []predicate.ERPPurchaseContract
}

var _ ent.Mutation = (*ERPPurchaseContractMutation)(nil)

// erppurchasecontractOption allows management of the mutation configuration using functional options.
type erppurchasecontractOption func(*ERPPurchaseContractMutation)

// newERPPurchaseContractMutation creates new mutation for the ERPPurchaseContract entity.
func newERPPurchaseContractMutation(c config, op Op, opts ...erppurchasecontractOption) *ERPPurchaseContractMutation {
	m := &ERPPurchaseContractMutation{
		config:        c,
		op:            op,
		typ:           TypeERPPurchaseContract,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withERPPurchaseContractID sets the ID field of the mutation.
func withERPPurchaseContractID(id int) erppurchasecontractOption {
	return func(m *ERPPurchaseContractMutation) {
		var (
			err   error
			once  sync.Once
			value *ERPPurchaseContract
		)
		m.oldValue = func(ctx context.Context) (*ERPPurchaseContract, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ERPPurchaseContract.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withERPPurchaseContract sets the old ERPPurchaseContract of the mutation.
func withERPPurchaseContract(node *ERPPurchaseContract) erppurchasecontractOption {
	return func(m *ERPPurchaseContractMutation) {
		m.oldValue = func(context.Context) (*ERPPurchaseContract, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ERPPurchaseContractMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ERPPurchaseContractMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ERPPurchaseContractMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ERPPurchaseContractMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ERPPurchaseContract.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *ERPPurchaseContractMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ERPPurchaseContractMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the ERPPurchaseContract entity.
// If the ERPPurchaseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ERPPurchaseContractMutation) ResetCode() {
	m.code = nil
}

// SetExportSaleID sets the "export_sale_id" field.
func (m *ERPPurchaseContractMutation) SetExportSaleID(i int) {
	m.export_sale_id = &i
	m.addexport_sale_id = nil
}

// ExportSaleID returns the value of the "export_sale_id" field in the mutation.
func (m *ERPPurchaseContractMutation) ExportSaleID() (r int, exists bool) {
	v := m.export_sale_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExportSaleID returns the old "export_sale_id" field's value of the ERPPurchaseContract entity.
// If the ERPPurchaseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractMutation) OldExportSaleID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExportSaleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExportSaleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExportSaleID: %w", err)
	}
	return oldValue.ExportSaleID, nil
}

// AddExportSaleID adds i to the "export_sale_id" field.
func (m *ERPPurchaseContractMutation) AddExportSaleID(i int) {
	if m.addexport_sale_id != nil {
		*m.addexport_sale_id += i
	} else {
		m.addexport_sale_id = &i
	}
}

// AddedExportSaleID returns the value that was added to the "export_sale_id" field in this mutation.
func (m *ERPPurchaseContractMutation) AddedExportSaleID() (r int, exists bool) {
	v := m.addexport_sale_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearExportSaleID clears the value of the "export_sale_id" field.
func (m *ERPPurchaseContractMutation) ClearExportSaleID() {
	m.export_sale_id = nil
	m.addexport_sale_id = nil
	m.clearedFields[erppurchasecontract.FieldExportSaleID] = struct{}{}
}

// ExportSaleIDCleared returns if the "export_sale_id" field was cleared in this mutation.
func (m *ERPPurchaseContractMutation) ExportSaleIDCleared() bool {
	_, ok := m.clearedFields[erppurchasecontract.FieldExportSaleID]
	return ok
}

// ResetExportSaleID resets all changes to the "export_sale_id" field.
func (m *ERPPurchaseContractMutation) ResetExportSaleID() {
	m.export_sale_id = nil
	m.addexport_sale_id = nil
	delete(m.clearedFields, erppurchasecontract.FieldExportSaleID)
}

// SetSourceExportCode sets the "source_export_code" field.
func (m *ERPPurchaseContractMutation) SetSourceExportCode(s string) {
	m.source_export_code = &s
}

// SourceExportCode returns the value of the "source_export_code" field in the mutation.
func (m *ERPPurchaseContractMutation) SourceExportCode() (r string, exists bool) {
	v := m.source_export_code
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceExportCode returns the old "source_export_code" field's value of the ERPPurchaseContract entity.
// If the ERPPurchaseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractMutation) OldSourceExportCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceExportCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceExportCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceExportCode: %w", err)
	}
	return oldValue.SourceExportCode, nil
}

// ClearSourceExportCode clears the value of the "source_export_code" field.
func (m *ERPPurchaseContractMutation) ClearSourceExportCode() {
	m.source_export_code = nil
	m.clearedFields[erppurchasecontract.FieldSourceExportCode] = struct{}{}
}

// SourceExportCodeCleared returns if the "source_export_code" field was cleared in this mutation.
func (m *ERPPurchaseContractMutation) SourceExportCodeCleared() bool {
	_, ok := m.clearedFields[erppurchasecontract.FieldSourceExportCode]
	return ok
}

// ResetSourceExportCode resets all changes to the "source_export_code" field.
func (m *ERPPurchaseContractMutation) ResetSourceExportCode() {
	m.source_export_code = nil
	delete(m.clearedFields, erppurchasecontract.FieldSourceExportCode)
}

// SetSupplierPartnerID sets the "supplier_partner_id" field.
func (m *ERPPurchaseContractMutation) SetSupplierPartnerID(i int) {
	m.supplier_partner_id = &i
	m.addsupplier_partner_id = nil
}

// SupplierPartnerID returns the value of the "supplier_partner_id" field in the mutation.
func (m *ERPPurchaseContractMutation) SupplierPartnerID() (r int, exists bool) {
	v := m.supplier_partner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierPartnerID returns the old "supplier_partner_id" field's value of the ERPPurchaseContract entity.
// If the ERPPurchaseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractMutation) OldSupplierPartnerID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierPartnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierPartnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierPartnerID: %w", err)
	}
	return oldValue.SupplierPartnerID, nil
}

// AddSupplierPartnerID adds i to the "supplier_partner_id" field.
func (m *ERPPurchaseContractMutation) AddSupplierPartnerID(i int) {
	if m.addsupplier_partner_id != nil {
		*m.addsupplier_partner_id += i
	} else {
		m.addsupplier_partner_id = &i
	}
}

// AddedSupplierPartnerID returns the value that was added to the "supplier_partner_id" field in this mutation.
func (m *ERPPurchaseContractMutation) AddedSupplierPartnerID() (r int, exists bool) {
	v := m.addsupplier_partner_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearSupplierPartnerID clears the value of the "supplier_partner_id" field.
func (m *ERPPurchaseContractMutation) ClearSupplierPartnerID() {
	m.supplier_partner_id = nil
	m.addsupplier_partner_id = nil
	m.clearedFields[erppurchasecontract.FieldSupplierPartnerID] = struct{}{}
}

// SupplierPartnerIDCleared returns if the "supplier_partner_id" field was cleared in this mutation.
func (m *ERPPurchaseContractMutation) SupplierPartnerIDCleared() bool {
	_, ok := m.clearedFields[erppurchasecontract.FieldSupplierPartnerID]
	return ok
}

// ResetSupplierPartnerID resets all changes to the "supplier_partner_id" field.
func (m *ERPPurchaseContractMutation) ResetSupplierPartnerID() {
	m.supplier_partner_id = nil
	m.addsupplier_partner_id = nil
	delete(m.clearedFields, erppurchasecontract.FieldSupplierPartnerID)
}

// SetSupplierCode sets the "supplier_code" field.
func (m *ERPPurchaseContractMutation) SetSupplierCode(s string) {
	m.supplier_code = &s
}

// SupplierCode returns the value of the "supplier_code" field in the mutation.
func (m *ERPPurchaseContractMutation) SupplierCode() (r string, exists bool) {
	v := m.supplier_code
	if v == nil {
		return
	}
	return *v, true
}

// OldSupplierCode returns the old "supplier_code" field's value of the ERPPurchaseContract entity.
// If the ERPPurchaseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractMutation) OldSupplierCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupplierCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupplierCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupplierCode: %w", err)
	}
	return oldValue.SupplierCode, nil
}

// ClearSupplierCode clears the value of the "supplier_code" field.
func (m *ERPPurchaseContractMutation) ClearSupplierCode() {
	m.supplier_code = nil
	m.clearedFields[erppurchasecontract.FieldSupplierCode] = struct{}{}
}

// SupplierCodeCleared returns if the "supplier_code" field was cleared in this mutation.
func (m *ERPPurchaseContractMutation) SupplierCodeCleared() bool {
	_, ok := m.clearedFields[erppurchasecontract.FieldSupplierCode]
	return ok
}

// ResetSupplierCode resets all changes to the "supplier_code" field.
func (m *ERPPurchaseContractMutation) ResetSupplierCode() {
	m.supplier_code = nil
	delete(m.clearedFields, erppurchasecontract.FieldSupplierCode)
}

// SetSignDate sets the "sign_date" field.
func (m *ERPPurchaseContractMutation) SetSignDate(t time.Time) {
	m.sign_date = &t
}

// SignDate returns the value of the "sign_date" field in the mutation.
func (m *ERPPurchaseContractMutation) SignDate() (r time.Time, exists bool) {
	v := m.sign_date
	if v == nil {
		return
	}
	return *v, true
}

// OldSignDate returns the old "sign_date" field's value of the ERPPurchaseContract entity.
// If the ERPPurchaseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractMutation) OldSignDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignDate: %w", err)
	}
	return oldValue.SignDate, nil
}

// ResetSignDate resets all changes to the "sign_date" field.
func (m *ERPPurchaseContractMutation) ResetSignDate() {
	m.sign_date = nil
}

// SetSalesNo sets the "sales_no" field.
func (m *ERPPurchaseContractMutation) SetSalesNo(s string) {
	m.sales_no = &s
}

// SalesNo returns the value of the "sales_no" field in the mutation.
func (m *ERPPurchaseContractMutation) SalesNo() (r string, exists bool) {
	v := m.sales_no
	if v == nil {
		return
	}
	return *v, true
}

// OldSalesNo returns the old "sales_no" field's value of the ERPPurchaseContract entity.
// If the ERPPurchaseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractMutation) OldSalesNo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalesNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalesNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalesNo: %w", err)
	}
	return oldValue.SalesNo, nil
}

// ClearSalesNo clears the value of the "sales_no" field.
func (m *ERPPurchaseContractMutation) ClearSalesNo() {
	m.sales_no = nil
	m.clearedFields[erppurchasecontract.FieldSalesNo] = struct{}{}
}

// SalesNoCleared returns if the "sales_no" field was cleared in this mutation.
func (m *ERPPurchaseContractMutation) SalesNoCleared() bool {
	_, ok := m.clearedFields[erppurchasecontract.FieldSalesNo]
	return ok
}

// ResetSalesNo resets all changes to the "sales_no" field.
func (m *ERPPurchaseContractMutation) ResetSalesNo() {
	m.sales_no = nil
	delete(m.clearedFields, erppurchasecontract.FieldSalesNo)
}

// SetDeliveryDate sets the "delivery_date" field.
func (m *ERPPurchaseContractMutation) SetDeliveryDate(t time.Time) {
	m.delivery_date = &t
}

// DeliveryDate returns the value of the "delivery_date" field in the mutation.
func (m *ERPPurchaseContractMutation) DeliveryDate() (r time.Time, exists bool) {
	v := m.delivery_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryDate returns the old "delivery_date" field's value of the ERPPurchaseContract entity.
// If the ERPPurchaseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractMutation) OldDeliveryDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryDate: %w", err)
	}
	return oldValue.DeliveryDate, nil
}

// ResetDeliveryDate resets all changes to the "delivery_date" field.
func (m *ERPPurchaseContractMutation) ResetDeliveryDate() {
	m.delivery_date = nil
}

// SetDeliveryAddress sets the "delivery_address" field.
func (m *ERPPurchaseContractMutation) SetDeliveryAddress(s string) {
	m.delivery_address = &s
}

// DeliveryAddress returns the value of the "delivery_address" field in the mutation.
func (m *ERPPurchaseContractMutation) DeliveryAddress() (r string, exists bool) {
	v := m.delivery_address
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryAddress returns the old "delivery_address" field's value of the ERPPurchaseContract entity.
// If the ERPPurchaseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractMutation) OldDeliveryAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryAddress: %w", err)
	}
	return oldValue.DeliveryAddress, nil
}

// ClearDeliveryAddress clears the value of the "delivery_address" field.
func (m *ERPPurchaseContractMutation) ClearDeliveryAddress() {
	m.delivery_address = nil
	m.clearedFields[erppurchasecontract.FieldDeliveryAddress] = struct{}{}
}

// DeliveryAddressCleared returns if the "delivery_address" field was cleared in this mutation.
func (m *ERPPurchaseContractMutation) DeliveryAddressCleared() bool {
	_, ok := m.clearedFields[erppurchasecontract.FieldDeliveryAddress]
	return ok
}

// ResetDeliveryAddress resets all changes to the "delivery_address" field.
func (m *ERPPurchaseContractMutation) ResetDeliveryAddress() {
	m.delivery_address = nil
	delete(m.clearedFields, erppurchasecontract.FieldDeliveryAddress)
}

// SetFollower sets the "follower" field.
func (m *ERPPurchaseContractMutation) SetFollower(s string) {
	m.follower = &s
}

// Follower returns the value of the "follower" field in the mutation.
func (m *ERPPurchaseContractMutation) Follower() (r string, exists bool) {
	v := m.follower
	if v == nil {
		return
	}
	return *v, true
}

// OldFollower returns the old "follower" field's value of the ERPPurchaseContract entity.
// If the ERPPurchaseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractMutation) OldFollower(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollower is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollower requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollower: %w", err)
	}
	return oldValue.Follower, nil
}

// ClearFollower clears the value of the "follower" field.
func (m *ERPPurchaseContractMutation) ClearFollower() {
	m.follower = nil
	m.clearedFields[erppurchasecontract.FieldFollower] = struct{}{}
}

// FollowerCleared returns if the "follower" field was cleared in this mutation.
func (m *ERPPurchaseContractMutation) FollowerCleared() bool {
	_, ok := m.clearedFields[erppurchasecontract.FieldFollower]
	return ok
}

// ResetFollower resets all changes to the "follower" field.
func (m *ERPPurchaseContractMutation) ResetFollower() {
	m.follower = nil
	delete(m.clearedFields, erppurchasecontract.FieldFollower)
}

// SetBuyer sets the "buyer" field.
func (m *ERPPurchaseContractMutation) SetBuyer(s string) {
	m.buyer = &s
}

// Buyer returns the value of the "buyer" field in the mutation.
func (m *ERPPurchaseContractMutation) Buyer() (r string, exists bool) {
	v := m.buyer
	if v == nil {
		return
	}
	return *v, true
}

// OldBuyer returns the old "buyer" field's value of the ERPPurchaseContract entity.
// If the ERPPurchaseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractMutation) OldBuyer(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuyer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuyer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuyer: %w", err)
	}
	return oldValue.Buyer, nil
}

// ClearBuyer clears the value of the "buyer" field.
func (m *ERPPurchaseContractMutation) ClearBuyer() {
	m.buyer = nil
	m.clearedFields[erppurchasecontract.FieldBuyer] = struct{}{}
}

// BuyerCleared returns if the "buyer" field was cleared in this mutation.
func (m *ERPPurchaseContractMutation) BuyerCleared() bool {
	_, ok := m.clearedFields[erppurchasecontract.FieldBuyer]
	return ok
}

// ResetBuyer resets all changes to the "buyer" field.
func (m *ERPPurchaseContractMutation) ResetBuyer() {
	m.buyer = nil
	delete(m.clearedFields, erppurchasecontract.FieldBuyer)
}

// SetInvoiceRequired sets the "invoice_required" field.
func (m *ERPPurchaseContractMutation) SetInvoiceRequired(b bool) {
	m.invoice_required = &b
}

// InvoiceRequired returns the value of the "invoice_required" field in the mutation.
func (m *ERPPurchaseContractMutation) InvoiceRequired() (r bool, exists bool) {
	v := m.invoice_required
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceRequired returns the old "invoice_required" field's value of the ERPPurchaseContract entity.
// If the ERPPurchaseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractMutation) OldInvoiceRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceRequired: %w", err)
	}
	return oldValue.InvoiceRequired, nil
}

// ResetInvoiceRequired resets all changes to the "invoice_required" field.
func (m *ERPPurchaseContractMutation) ResetInvoiceRequired() {
	m.invoice_required = nil
}

// SetTotalAmount sets the "total_amount" field.
func (m *ERPPurchaseContractMutation) SetTotalAmount(f float64) {
	m.total_amount = &f
	m.addtotal_amount = nil
}

// TotalAmount returns the value of the "total_amount" field in the mutation.
func (m *ERPPurchaseContractMutation) TotalAmount() (r float64, exists bool) {
	v := m.total_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAmount returns the old "total_amount" field's value of the ERPPurchaseContract entity.
// If the ERPPurchaseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractMutation) OldTotalAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAmount: %w", err)
	}
	return oldValue.TotalAmount, nil
}

// AddTotalAmount adds f to the "total_amount" field.
func (m *ERPPurchaseContractMutation) AddTotalAmount(f float64) {
	if m.addtotal_amount != nil {
		*m.addtotal_amount += f
	} else {
		m.addtotal_amount = &f
	}
}

// AddedTotalAmount returns the value that was added to the "total_amount" field in this mutation.
func (m *ERPPurchaseContractMutation) AddedTotalAmount() (r float64, exists bool) {
	v := m.addtotal_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalAmount resets all changes to the "total_amount" field.
func (m *ERPPurchaseContractMutation) ResetTotalAmount() {
	m.total_amount = nil
	m.addtotal_amount = nil
}

// SetStatus sets the "status" field.
func (m *ERPPurchaseContractMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ERPPurchaseContractMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ERPPurchaseContract entity.
// If the ERPPurchaseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ERPPurchaseContractMutation) ResetStatus() {
	m.status = nil
}

// SetRemark sets the "remark" field.
func (m *ERPPurchaseContractMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ERPPurchaseContractMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the ERPPurchaseContract entity.
// If the ERPPurchaseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ERPPurchaseContractMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[erppurchasecontract.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ERPPurchaseContractMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[erppurchasecontract.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ERPPurchaseContractMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, erppurchasecontract.FieldRemark)
}

// SetCreatedByAdminID sets the "created_by_admin_id" field.
func (m *ERPPurchaseContractMutation) SetCreatedByAdminID(i int) {
	m.created_by_admin_id = &i
	m.addcreated_by_admin_id = nil
}

// CreatedByAdminID returns the value of the "created_by_admin_id" field in the mutation.
func (m *ERPPurchaseContractMutation) CreatedByAdminID() (r int, exists bool) {
	v := m.created_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedByAdminID returns the old "created_by_admin_id" field's value of the ERPPurchaseContract entity.
// If the ERPPurchaseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractMutation) OldCreatedByAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedByAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedByAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedByAdminID: %w", err)
	}
	return oldValue.CreatedByAdminID, nil
}

// AddCreatedByAdminID adds i to the "created_by_admin_id" field.
func (m *ERPPurchaseContractMutation) AddCreatedByAdminID(i int) {
	if m.addcreated_by_admin_id != nil {
		*m.addcreated_by_admin_id += i
	} else {
		m.addcreated_by_admin_id = &i
	}
}

// AddedCreatedByAdminID returns the value that was added to the "created_by_admin_id" field in this mutation.
func (m *ERPPurchaseContractMutation) AddedCreatedByAdminID() (r int, exists bool) {
	v := m.addcreated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedByAdminID clears the value of the "created_by_admin_id" field.
func (m *ERPPurchaseContractMutation) ClearCreatedByAdminID() {
	m.created_by_admin_id = nil
	m.addcreated_by_admin_id = nil
	m.clearedFields[erppurchasecontract.FieldCreatedByAdminID] = struct{}{}
}

// CreatedByAdminIDCleared returns if the "created_by_admin_id" field was cleared in this mutation.
func (m *ERPPurchaseContractMutation) CreatedByAdminIDCleared() bool {
	_, ok := m.clearedFields[erppurchasecontract.FieldCreatedByAdminID]
	return ok
}

// ResetCreatedByAdminID resets all changes to the "created_by_admin_id" field.
func (m *ERPPurchaseContractMutation) ResetCreatedByAdminID() {
	m.created_by_admin_id = nil
	m.addcreated_by_admin_id = nil
	delete(m.clearedFields, erppurchasecontract.FieldCreatedByAdminID)
}

// SetUpdatedByAdminID sets the "updated_by_admin_id" field.
func (m *ERPPurchaseContractMutation) SetUpdatedByAdminID(i int) {
	m.updated_by_admin_id = &i
	m.addupdated_by_admin_id = nil
}

// UpdatedByAdminID returns the value of the "updated_by_admin_id" field in the mutation.
func (m *ERPPurchaseContractMutation) UpdatedByAdminID() (r int, exists bool) {
	v := m.updated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedByAdminID returns the old "updated_by_admin_id" field's value of the ERPPurchaseContract entity.
// If the ERPPurchaseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractMutation) OldUpdatedByAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedByAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedByAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedByAdminID: %w", err)
	}
	return oldValue.UpdatedByAdminID, nil
}

// AddUpdatedByAdminID adds i to the "updated_by_admin_id" field.
func (m *ERPPurchaseContractMutation) AddUpdatedByAdminID(i int) {
	if m.addupdated_by_admin_id != nil {
		*m.addupdated_by_admin_id += i
	} else {
		m.addupdated_by_admin_id = &i
	}
}

// AddedUpdatedByAdminID returns the value that was added to the "updated_by_admin_id" field in this mutation.
func (m *ERPPurchaseContractMutation) AddedUpdatedByAdminID() (r int, exists bool) {
	v := m.addupdated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedByAdminID clears the value of the "updated_by_admin_id" field.
func (m *ERPPurchaseContractMutation) ClearUpdatedByAdminID() {
	m.updated_by_admin_id = nil
	m.addupdated_by_admin_id = nil
	m.clearedFields[erppurchasecontract.FieldUpdatedByAdminID] = struct{}{}
}

// UpdatedByAdminIDCleared returns if the "updated_by_admin_id" field was cleared in this mutation.
func (m *ERPPurchaseContractMutation) UpdatedByAdminIDCleared() bool {
	_, ok := m.clearedFields[erppurchasecontract.FieldUpdatedByAdminID]
	return ok
}

// ResetUpdatedByAdminID resets all changes to the "updated_by_admin_id" field.
func (m *ERPPurchaseContractMutation) ResetUpdatedByAdminID() {
	m.updated_by_admin_id = nil
	m.addupdated_by_admin_id = nil
	delete(m.clearedFields, erppurchasecontract.FieldUpdatedByAdminID)
}

// SetCreatedAt sets the "created_at" field.
func (m *ERPPurchaseContractMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ERPPurchaseContractMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ERPPurchaseContract entity.
// If the ERPPurchaseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ERPPurchaseContractMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ERPPurchaseContractMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ERPPurchaseContractMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ERPPurchaseContract entity.
// If the ERPPurchaseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ERPPurchaseContractMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ERPPurchaseContractMutation builder.
func (m *ERPPurchaseContractMutation) Where(ps ...predicate.ERPPurchaseContract) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ERPPurchaseContractMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ERPPurchaseContractMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ERPPurchaseContract, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ERPPurchaseContractMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ERPPurchaseContractMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ERPPurchaseContract).
func (m *ERPPurchaseContractMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ERPPurchaseContractMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.code != nil {
		fields = append(fields, erppurchasecontract.FieldCode)
	}
	if m.export_sale_id != nil {
		fields = append(fields, erppurchasecontract.FieldExportSaleID)
	}
	if m.source_export_code != nil {
		fields = append(fields, erppurchasecontract.FieldSourceExportCode)
	}
	if m.supplier_partner_id != nil {
		fields = append(fields, erppurchasecontract.FieldSupplierPartnerID)
	}
	if m.supplier_code != nil {
		fields = append(fields, erppurchasecontract.FieldSupplierCode)
	}
	if m.sign_date != nil {
		fields = append(fields, erppurchasecontract.FieldSignDate)
	}
	if m.sales_no != nil {
		fields = append(fields, erppurchasecontract.FieldSalesNo)
	}
	if m.delivery_date != nil {
		fields = append(fields, erppurchasecontract.FieldDeliveryDate)
	}
	if m.delivery_address != nil {
		fields = append(fields, erppurchasecontract.FieldDeliveryAddress)
	}
	if m.follower != nil {
		fields = append(fields, erppurchasecontract.FieldFollower)
	}
	if m.buyer != nil {
		fields = append(fields, erppurchasecontract.FieldBuyer)
	}
	if m.invoice_required != nil {
		fields = append(fields, erppurchasecontract.FieldInvoiceRequired)
	}
	if m.total_amount != nil {
		fields = append(fields, erppurchasecontract.FieldTotalAmount)
	}
	if m.status != nil {
		fields = append(fields, erppurchasecontract.FieldStatus)
	}
	if m.remark != nil {
		fields = append(fields, erppurchasecontract.FieldRemark)
	}
	if m.created_by_admin_id != nil {
		fields = append(fields, erppurchasecontract.FieldCreatedByAdminID)
	}
	if m.updated_by_admin_id != nil {
		fields = append(fields, erppurchasecontract.FieldUpdatedByAdminID)
	}
	if m.created_at != nil {
		fields = append(fields, erppurchasecontract.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, erppurchasecontract.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ERPPurchaseContractMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case erppurchasecontract.FieldCode:
		return m.Code()
	case erppurchasecontract.FieldExportSaleID:
		return m.ExportSaleID()
	case erppurchasecontract.FieldSourceExportCode:
		return m.SourceExportCode()
	case erppurchasecontract.FieldSupplierPartnerID:
		return m.SupplierPartnerID()
	case erppurchasecontract.FieldSupplierCode:
		return m.SupplierCode()
	case erppurchasecontract.FieldSignDate:
		return m.SignDate()
	case erppurchasecontract.FieldSalesNo:
		return m.SalesNo()
	case erppurchasecontract.FieldDeliveryDate:
		return m.DeliveryDate()
	case erppurchasecontract.FieldDeliveryAddress:
		return m.DeliveryAddress()
	case erppurchasecontract.FieldFollower:
		return m.Follower()
	case erppurchasecontract.FieldBuyer:
		return m.Buyer()
	case erppurchasecontract.FieldInvoiceRequired:
		return m.InvoiceRequired()
	case erppurchasecontract.FieldTotalAmount:
		return m.TotalAmount()
	case erppurchasecontract.FieldStatus:
		return m.Status()
	case erppurchasecontract.FieldRemark:
		return m.Remark()
	case erppurchasecontract.FieldCreatedByAdminID:
		return m.CreatedByAdminID()
	case erppurchasecontract.FieldUpdatedByAdminID:
		return m.UpdatedByAdminID()
	case erppurchasecontract.FieldCreatedAt:
		return m.CreatedAt()
	case erppurchasecontract.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ERPPurchaseContractMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case erppurchasecontract.FieldCode:
		return m.OldCode(ctx)
	case erppurchasecontract.FieldExportSaleID:
		return m.OldExportSaleID(ctx)
	case erppurchasecontract.FieldSourceExportCode:
		return m.OldSourceExportCode(ctx)
	case erppurchasecontract.FieldSupplierPartnerID:
		return m.OldSupplierPartnerID(ctx)
	case erppurchasecontract.FieldSupplierCode:
		return m.OldSupplierCode(ctx)
	case erppurchasecontract.FieldSignDate:
		return m.OldSignDate(ctx)
	case erppurchasecontract.FieldSalesNo:
		return m.OldSalesNo(ctx)
	case erppurchasecontract.FieldDeliveryDate:
		return m.OldDeliveryDate(ctx)
	case erppurchasecontract.FieldDeliveryAddress:
		return m.OldDeliveryAddress(ctx)
	case erppurchasecontract.FieldFollower:
		return m.OldFollower(ctx)
	case erppurchasecontract.FieldBuyer:
		return m.OldBuyer(ctx)
	case erppurchasecontract.FieldInvoiceRequired:
		return m.OldInvoiceRequired(ctx)
	case erppurchasecontract.FieldTotalAmount:
		return m.OldTotalAmount(ctx)
	case erppurchasecontract.FieldStatus:
		return m.OldStatus(ctx)
	case erppurchasecontract.FieldRemark:
		return m.OldRemark(ctx)
	case erppurchasecontract.FieldCreatedByAdminID:
		return m.OldCreatedByAdminID(ctx)
	case erppurchasecontract.FieldUpdatedByAdminID:
		return m.OldUpdatedByAdminID(ctx)
	case erppurchasecontract.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case erppurchasecontract.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ERPPurchaseContract field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPPurchaseContractMutation) SetField(name string, value ent.Value) error {
	switch name {
	case erppurchasecontract.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case erppurchasecontract.FieldExportSaleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExportSaleID(v)
		return nil
	case erppurchasecontract.FieldSourceExportCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceExportCode(v)
		return nil
	case erppurchasecontract.FieldSupplierPartnerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierPartnerID(v)
		return nil
	case erppurchasecontract.FieldSupplierCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupplierCode(v)
		return nil
	case erppurchasecontract.FieldSignDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignDate(v)
		return nil
	case erppurchasecontract.FieldSalesNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalesNo(v)
		return nil
	case erppurchasecontract.FieldDeliveryDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryDate(v)
		return nil
	case erppurchasecontract.FieldDeliveryAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryAddress(v)
		return nil
	case erppurchasecontract.FieldFollower:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollower(v)
		return nil
	case erppurchasecontract.FieldBuyer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuyer(v)
		return nil
	case erppurchasecontract.FieldInvoiceRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceRequired(v)
		return nil
	case erppurchasecontract.FieldTotalAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAmount(v)
		return nil
	case erppurchasecontract.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case erppurchasecontract.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case erppurchasecontract.FieldCreatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedByAdminID(v)
		return nil
	case erppurchasecontract.FieldUpdatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedByAdminID(v)
		return nil
	case erppurchasecontract.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case erppurchasecontract.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ERPPurchaseContract field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ERPPurchaseContractMutation) AddedFields() []string {
	var fields []string
	if m.addexport_sale_id != nil {
		fields = append(fields, erppurchasecontract.FieldExportSaleID)
	}
	if m.addsupplier_partner_id != nil {
		fields = append(fields, erppurchasecontract.FieldSupplierPartnerID)
	}
	if m.addtotal_amount != nil {
		fields = append(fields, erppurchasecontract.FieldTotalAmount)
	}
	if m.addcreated_by_admin_id != nil {
		fields = append(fields, erppurchasecontract.FieldCreatedByAdminID)
	}
	if m.addupdated_by_admin_id != nil {
		fields = append(fields, erppurchasecontract.FieldUpdatedByAdminID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ERPPurchaseContractMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case erppurchasecontract.FieldExportSaleID:
		return m.AddedExportSaleID()
	case erppurchasecontract.FieldSupplierPartnerID:
		return m.AddedSupplierPartnerID()
	case erppurchasecontract.FieldTotalAmount:
		return m.AddedTotalAmount()
	case erppurchasecontract.FieldCreatedByAdminID:
		return m.AddedCreatedByAdminID()
	case erppurchasecontract.FieldUpdatedByAdminID:
		return m.AddedUpdatedByAdminID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPPurchaseContractMutation) AddField(name string, value ent.Value) error {
	switch name {
	case erppurchasecontract.FieldExportSaleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExportSaleID(v)
		return nil
	case erppurchasecontract.FieldSupplierPartnerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSupplierPartnerID(v)
		return nil
	case erppurchasecontract.FieldTotalAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalAmount(v)
		return nil
	case erppurchasecontract.FieldCreatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedByAdminID(v)
		return nil
	case erppurchasecontract.FieldUpdatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedByAdminID(v)
		return nil
	}
	return fmt.Errorf("unknown ERPPurchaseContract numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ERPPurchaseContractMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(erppurchasecontract.FieldExportSaleID) {
		fields = append(fields, erppurchasecontract.FieldExportSaleID)
	}
	if m.FieldCleared(erppurchasecontract.FieldSourceExportCode) {
		fields = append(fields, erppurchasecontract.FieldSourceExportCode)
	}
	if m.FieldCleared(erppurchasecontract.FieldSupplierPartnerID) {
		fields = append(fields, erppurchasecontract.FieldSupplierPartnerID)
	}
	if m.FieldCleared(erppurchasecontract.FieldSupplierCode) {
		fields = append(fields, erppurchasecontract.FieldSupplierCode)
	}
	if m.FieldCleared(erppurchasecontract.FieldSalesNo) {
		fields = append(fields, erppurchasecontract.FieldSalesNo)
	}
	if m.FieldCleared(erppurchasecontract.FieldDeliveryAddress) {
		fields = append(fields, erppurchasecontract.FieldDeliveryAddress)
	}
	if m.FieldCleared(erppurchasecontract.FieldFollower) {
		fields = append(fields, erppurchasecontract.FieldFollower)
	}
	if m.FieldCleared(erppurchasecontract.FieldBuyer) {
		fields = append(fields, erppurchasecontract.FieldBuyer)
	}
	if m.FieldCleared(erppurchasecontract.FieldRemark) {
		fields = append(fields, erppurchasecontract.FieldRemark)
	}
	if m.FieldCleared(erppurchasecontract.FieldCreatedByAdminID) {
		fields = append(fields, erppurchasecontract.FieldCreatedByAdminID)
	}
	if m.FieldCleared(erppurchasecontract.FieldUpdatedByAdminID) {
		fields = append(fields, erppurchasecontract.FieldUpdatedByAdminID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ERPPurchaseContractMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ERPPurchaseContractMutation) ClearField(name string) error {
	switch name {
	case erppurchasecontract.FieldExportSaleID:
		m.ClearExportSaleID()
		return nil
	case erppurchasecontract.FieldSourceExportCode:
		m.ClearSourceExportCode()
		return nil
	case erppurchasecontract.FieldSupplierPartnerID:
		m.ClearSupplierPartnerID()
		return nil
	case erppurchasecontract.FieldSupplierCode:
		m.ClearSupplierCode()
		return nil
	case erppurchasecontract.FieldSalesNo:
		m.ClearSalesNo()
		return nil
	case erppurchasecontract.FieldDeliveryAddress:
		m.ClearDeliveryAddress()
		return nil
	case erppurchasecontract.FieldFollower:
		m.ClearFollower()
		return nil
	case erppurchasecontract.FieldBuyer:
		m.ClearBuyer()
		return nil
	case erppurchasecontract.FieldRemark:
		m.ClearRemark()
		return nil
	case erppurchasecontract.FieldCreatedByAdminID:
		m.ClearCreatedByAdminID()
		return nil
	case erppurchasecontract.FieldUpdatedByAdminID:
		m.ClearUpdatedByAdminID()
		return nil
	}
	return fmt.Errorf("unknown ERPPurchaseContract nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ERPPurchaseContractMutation) ResetField(name string) error {
	switch name {
	case erppurchasecontract.FieldCode:
		m.ResetCode()
		return nil
	case erppurchasecontract.FieldExportSaleID:
		m.ResetExportSaleID()
		return nil
	case erppurchasecontract.FieldSourceExportCode:
		m.ResetSourceExportCode()
		return nil
	case erppurchasecontract.FieldSupplierPartnerID:
		m.ResetSupplierPartnerID()
		return nil
	case erppurchasecontract.FieldSupplierCode:
		m.ResetSupplierCode()
		return nil
	case erppurchasecontract.FieldSignDate:
		m.ResetSignDate()
		return nil
	case erppurchasecontract.FieldSalesNo:
		m.ResetSalesNo()
		return nil
	case erppurchasecontract.FieldDeliveryDate:
		m.ResetDeliveryDate()
		return nil
	case erppurchasecontract.FieldDeliveryAddress:
		m.ResetDeliveryAddress()
		return nil
	case erppurchasecontract.FieldFollower:
		m.ResetFollower()
		return nil
	case erppurchasecontract.FieldBuyer:
		m.ResetBuyer()
		return nil
	case erppurchasecontract.FieldInvoiceRequired:
		m.ResetInvoiceRequired()
		return nil
	case erppurchasecontract.FieldTotalAmount:
		m.ResetTotalAmount()
		return nil
	case erppurchasecontract.FieldStatus:
		m.ResetStatus()
		return nil
	case erppurchasecontract.FieldRemark:
		m.ResetRemark()
		return nil
	case erppurchasecontract.FieldCreatedByAdminID:
		m.ResetCreatedByAdminID()
		return nil
	case erppurchasecontract.FieldUpdatedByAdminID:
		m.ResetUpdatedByAdminID()
		return nil
	case erppurchasecontract.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case erppurchasecontract.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPPurchaseContract field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ERPPurchaseContractMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ERPPurchaseContractMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ERPPurchaseContractMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ERPPurchaseContractMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ERPPurchaseContractMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ERPPurchaseContractMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ERPPurchaseContractMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ERPPurchaseContract unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ERPPurchaseContractMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ERPPurchaseContract edge %s", name)
}

// ERPPurchaseContractItemMutation represents an operation that mutates the ERPPurchaseContractItem nodes in the graph.
type ERPPurchaseContractItemMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	purchase_contract_id    *int
	addpurchase_contract_id *int
	line_no                 *int
	addline_no              *int
	product_id              *int
	addproduct_id           *int
	product_code            *string
	product_name            *string
	spec_code               *string
	quantity                *float64
	addquantity             *float64
	unit_price              *float64
	addunit_price           *float64
	total_price             *float64
	addtotal_price          *float64
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*ERPPurchaseContractItem, error)
	predicates              []predicate.ERPPurchaseContractItem
}

var _ ent.Mutation = (*ERPPurchaseContractItemMutation)(nil)

// erppurchasecontractitemOption allows management of the mutation configuration using functional options.
type erppurchasecontractitemOption func(*ERPPurchaseContractItemMutation)

// newERPPurchaseContractItemMutation creates new mutation for the ERPPurchaseContractItem entity.
func newERPPurchaseContractItemMutation(c config, op Op, opts ...erppurchasecontractitemOption) *ERPPurchaseContractItemMutation {
	m := &ERPPurchaseContractItemMutation{
		config:        c,
		op:            op,
		typ:           TypeERPPurchaseContractItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withERPPurchaseContractItemID sets the ID field of the mutation.
func withERPPurchaseContractItemID(id int) erppurchasecontractitemOption {
	return func(m *ERPPurchaseContractItemMutation) {
		var (
			err   error
			once  sync.Once
			value *ERPPurchaseContractItem
		)
		m.oldValue = func(ctx context.Context) (*ERPPurchaseContractItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ERPPurchaseContractItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withERPPurchaseContractItem sets the old ERPPurchaseContractItem of the mutation.
func withERPPurchaseContractItem(node *ERPPurchaseContractItem) erppurchasecontractitemOption {
	return func(m *ERPPurchaseContractItemMutation) {
		m.oldValue = func(context.Context) (*ERPPurchaseContractItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ERPPurchaseContractItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ERPPurchaseContractItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ERPPurchaseContractItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ERPPurchaseContractItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ERPPurchaseContractItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPurchaseContractID sets the "purchase_contract_id" field.
func (m *ERPPurchaseContractItemMutation) SetPurchaseContractID(i int) {
	m.purchase_contract_id = &i
	m.addpurchase_contract_id = nil
}

// PurchaseContractID returns the value of the "purchase_contract_id" field in the mutation.
func (m *ERPPurchaseContractItemMutation) PurchaseContractID() (r int, exists bool) {
	v := m.purchase_contract_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchaseContractID returns the old "purchase_contract_id" field's value of the ERPPurchaseContractItem entity.
// If the ERPPurchaseContractItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractItemMutation) OldPurchaseContractID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchaseContractID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchaseContractID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchaseContractID: %w", err)
	}
	return oldValue.PurchaseContractID, nil
}

// AddPurchaseContractID adds i to the "purchase_contract_id" field.
func (m *ERPPurchaseContractItemMutation) AddPurchaseContractID(i int) {
	if m.addpurchase_contract_id != nil {
		*m.addpurchase_contract_id += i
	} else {
		m.addpurchase_contract_id = &i
	}
}

// AddedPurchaseContractID returns the value that was added to the "purchase_contract_id" field in this mutation.
func (m *ERPPurchaseContractItemMutation) AddedPurchaseContractID() (r int, exists bool) {
	v := m.addpurchase_contract_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPurchaseContractID resets all changes to the "purchase_contract_id" field.
func (m *ERPPurchaseContractItemMutation) ResetPurchaseContractID() {
	m.purchase_contract_id = nil
	m.addpurchase_contract_id = nil
}

// SetLineNo sets the "line_no" field.
func (m *ERPPurchaseContractItemMutation) SetLineNo(i int) {
	m.line_no = &i
	m.addline_no = nil
}

// LineNo returns the value of the "line_no" field in the mutation.
func (m *ERPPurchaseContractItemMutation) LineNo() (r int, exists bool) {
	v := m.line_no
	if v == nil {
		return
	}
	return *v, true
}

// OldLineNo returns the old "line_no" field's value of the ERPPurchaseContractItem entity.
// If the ERPPurchaseContractItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractItemMutation) OldLineNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLineNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLineNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLineNo: %w", err)
	}
	return oldValue.LineNo, nil
}

// AddLineNo adds i to the "line_no" field.
func (m *ERPPurchaseContractItemMutation) AddLineNo(i int) {
	if m.addline_no != nil {
		*m.addline_no += i
	} else {
		m.addline_no = &i
	}
}

// AddedLineNo returns the value that was added to the "line_no" field in this mutation.
func (m *ERPPurchaseContractItemMutation) AddedLineNo() (r int, exists bool) {
	v := m.addline_no
	if v == nil {
		return
	}
	return *v, true
}

// ResetLineNo resets all changes to the "line_no" field.
func (m *ERPPurchaseContractItemMutation) ResetLineNo() {
	m.line_no = nil
	m.addline_no = nil
}

// SetProductID sets the "product_id" field.
func (m *ERPPurchaseContractItemMutation) SetProductID(i int) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ERPPurchaseContractItemMutation) ProductID() (r int, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the ERPPurchaseContractItem entity.
// If the ERPPurchaseContractItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractItemMutation) OldProductID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *ERPPurchaseContractItemMutation) AddProductID(i int) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *ERPPurchaseContractItemMutation) AddedProductID() (r int, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductID clears the value of the "product_id" field.
func (m *ERPPurchaseContractItemMutation) ClearProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	m.clearedFields[erppurchasecontractitem.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *ERPPurchaseContractItemMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[erppurchasecontractitem.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ERPPurchaseContractItemMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	delete(m.clearedFields, erppurchasecontractitem.FieldProductID)
}

// SetProductCode sets the "product_code" field.
func (m *ERPPurchaseContractItemMutation) SetProductCode(s string) {
	m.product_code = &s
}

// ProductCode returns the value of the "product_code" field in the mutation.
func (m *ERPPurchaseContractItemMutation) ProductCode() (r string, exists bool) {
	v := m.product_code
	if v == nil {
		return
	}
	return *v, true
}

// OldProductCode returns the old "product_code" field's value of the ERPPurchaseContractItem entity.
// If the ERPPurchaseContractItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractItemMutation) OldProductCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductCode: %w", err)
	}
	return oldValue.ProductCode, nil
}

// ClearProductCode clears the value of the "product_code" field.
func (m *ERPPurchaseContractItemMutation) ClearProductCode() {
	m.product_code = nil
	m.clearedFields[erppurchasecontractitem.FieldProductCode] = struct{}{}
}

// ProductCodeCleared returns if the "product_code" field was cleared in this mutation.
func (m *ERPPurchaseContractItemMutation) ProductCodeCleared() bool {
	_, ok := m.clearedFields[erppurchasecontractitem.FieldProductCode]
	return ok
}

// ResetProductCode resets all changes to the "product_code" field.
func (m *ERPPurchaseContractItemMutation) ResetProductCode() {
	m.product_code = nil
	delete(m.clearedFields, erppurchasecontractitem.FieldProductCode)
}

// SetProductName sets the "product_name" field.
func (m *ERPPurchaseContractItemMutation) SetProductName(s string) {
	m.product_name = &s
}

// ProductName returns the value of the "product_name" field in the mutation.
func (m *ERPPurchaseContractItemMutation) ProductName() (r string, exists bool) {
	v := m.product_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProductName returns the old "product_name" field's value of the ERPPurchaseContractItem entity.
// If the ERPPurchaseContractItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractItemMutation) OldProductName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductName: %w", err)
	}
	return oldValue.ProductName, nil
}

// ClearProductName clears the value of the "product_name" field.
func (m *ERPPurchaseContractItemMutation) ClearProductName() {
	m.product_name = nil
	m.clearedFields[erppurchasecontractitem.FieldProductName] = struct{}{}
}

// ProductNameCleared returns if the "product_name" field was cleared in this mutation.
func (m *ERPPurchaseContractItemMutation) ProductNameCleared() bool {
	_, ok := m.clearedFields[erppurchasecontractitem.FieldProductName]
	return ok
}

// ResetProductName resets all changes to the "product_name" field.
func (m *ERPPurchaseContractItemMutation) ResetProductName() {
	m.product_name = nil
	delete(m.clearedFields, erppurchasecontractitem.FieldProductName)
}

// SetSpecCode sets the "spec_code" field.
func (m *ERPPurchaseContractItemMutation) SetSpecCode(s string) {
	m.spec_code = &s
}

// SpecCode returns the value of the "spec_code" field in the mutation.
func (m *ERPPurchaseContractItemMutation) SpecCode() (r string, exists bool) {
	v := m.spec_code
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecCode returns the old "spec_code" field's value of the ERPPurchaseContractItem entity.
// If the ERPPurchaseContractItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractItemMutation) OldSpecCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpecCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpecCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecCode: %w", err)
	}
	return oldValue.SpecCode, nil
}

// ClearSpecCode clears the value of the "spec_code" field.
func (m *ERPPurchaseContractItemMutation) ClearSpecCode() {
	m.spec_code = nil
	m.clearedFields[erppurchasecontractitem.FieldSpecCode] = struct{}{}
}

// SpecCodeCleared returns if the "spec_code" field was cleared in this mutation.
func (m *ERPPurchaseContractItemMutation) SpecCodeCleared() bool {
	_, ok := m.clearedFields[erppurchasecontractitem.FieldSpecCode]
	return ok
}

// ResetSpecCode resets all changes to the "spec_code" field.
func (m *ERPPurchaseContractItemMutation) ResetSpecCode() {
	m.spec_code = nil
	delete(m.clearedFields, erppurchasecontractitem.FieldSpecCode)
}

// SetQuantity sets the "quantity" field.
func (m *ERPPurchaseContractItemMutation) SetQuantity(f float64) {
	m.quantity = &f
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *ERPPurchaseContractItemMutation) Quantity() (r float64, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the ERPPurchaseContractItem entity.
// If the ERPPurchaseContractItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractItemMutation) OldQuantity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds f to the "quantity" field.
func (m *ERPPurchaseContractItemMutation) AddQuantity(f float64) {
	if m.addquantity != nil {
		*m.addquantity += f
	} else {
		m.addquantity = &f
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *ERPPurchaseContractItemMutation) AddedQuantity() (r float64, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *ERPPurchaseContractItemMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetUnitPrice sets the "unit_price" field.
func (m *ERPPurchaseContractItemMutation) SetUnitPrice(f float64) {
	m.unit_price = &f
	m.addunit_price = nil
}

// UnitPrice returns the value of the "unit_price" field in the mutation.
func (m *ERPPurchaseContractItemMutation) UnitPrice() (r float64, exists bool) {
	v := m.unit_price
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitPrice returns the old "unit_price" field's value of the ERPPurchaseContractItem entity.
// If the ERPPurchaseContractItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractItemMutation) OldUnitPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitPrice: %w", err)
	}
	return oldValue.UnitPrice, nil
}

// AddUnitPrice adds f to the "unit_price" field.
func (m *ERPPurchaseContractItemMutation) AddUnitPrice(f float64) {
	if m.addunit_price != nil {
		*m.addunit_price += f
	} else {
		m.addunit_price = &f
	}
}

// AddedUnitPrice returns the value that was added to the "unit_price" field in this mutation.
func (m *ERPPurchaseContractItemMutation) AddedUnitPrice() (r float64, exists bool) {
	v := m.addunit_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnitPrice resets all changes to the "unit_price" field.
func (m *ERPPurchaseContractItemMutation) ResetUnitPrice() {
	m.unit_price = nil
	m.addunit_price = nil
}

// SetTotalPrice sets the "total_price" field.
func (m *ERPPurchaseContractItemMutation) SetTotalPrice(f float64) {
	m.total_price = &f
	m.addtotal_price = nil
}

// TotalPrice returns the value of the "total_price" field in the mutation.
func (m *ERPPurchaseContractItemMutation) TotalPrice() (r float64, exists bool) {
	v := m.total_price
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalPrice returns the old "total_price" field's value of the ERPPurchaseContractItem entity.
// If the ERPPurchaseContractItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractItemMutation) OldTotalPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalPrice: %w", err)
	}
	return oldValue.TotalPrice, nil
}

// AddTotalPrice adds f to the "total_price" field.
func (m *ERPPurchaseContractItemMutation) AddTotalPrice(f float64) {
	if m.addtotal_price != nil {
		*m.addtotal_price += f
	} else {
		m.addtotal_price = &f
	}
}

// AddedTotalPrice returns the value that was added to the "total_price" field in this mutation.
func (m *ERPPurchaseContractItemMutation) AddedTotalPrice() (r float64, exists bool) {
	v := m.addtotal_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalPrice resets all changes to the "total_price" field.
func (m *ERPPurchaseContractItemMutation) ResetTotalPrice() {
	m.total_price = nil
	m.addtotal_price = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ERPPurchaseContractItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ERPPurchaseContractItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ERPPurchaseContractItem entity.
// If the ERPPurchaseContractItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ERPPurchaseContractItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ERPPurchaseContractItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ERPPurchaseContractItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ERPPurchaseContractItem entity.
// If the ERPPurchaseContractItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPPurchaseContractItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ERPPurchaseContractItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ERPPurchaseContractItemMutation builder.
func (m *ERPPurchaseContractItemMutation) Where(ps ...predicate.ERPPurchaseContractItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ERPPurchaseContractItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ERPPurchaseContractItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ERPPurchaseContractItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ERPPurchaseContractItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ERPPurchaseContractItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ERPPurchaseContractItem).
func (m *ERPPurchaseContractItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ERPPurchaseContractItemMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.purchase_contract_id != nil {
		fields = append(fields, erppurchasecontractitem.FieldPurchaseContractID)
	}
	if m.line_no != nil {
		fields = append(fields, erppurchasecontractitem.FieldLineNo)
	}
	if m.product_id != nil {
		fields = append(fields, erppurchasecontractitem.FieldProductID)
	}
	if m.product_code != nil {
		fields = append(fields, erppurchasecontractitem.FieldProductCode)
	}
	if m.product_name != nil {
		fields = append(fields, erppurchasecontractitem.FieldProductName)
	}
	if m.spec_code != nil {
		fields = append(fields, erppurchasecontractitem.FieldSpecCode)
	}
	if m.quantity != nil {
		fields = append(fields, erppurchasecontractitem.FieldQuantity)
	}
	if m.unit_price != nil {
		fields = append(fields, erppurchasecontractitem.FieldUnitPrice)
	}
	if m.total_price != nil {
		fields = append(fields, erppurchasecontractitem.FieldTotalPrice)
	}
	if m.created_at != nil {
		fields = append(fields, erppurchasecontractitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, erppurchasecontractitem.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ERPPurchaseContractItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case erppurchasecontractitem.FieldPurchaseContractID:
		return m.PurchaseContractID()
	case erppurchasecontractitem.FieldLineNo:
		return m.LineNo()
	case erppurchasecontractitem.FieldProductID:
		return m.ProductID()
	case erppurchasecontractitem.FieldProductCode:
		return m.ProductCode()
	case erppurchasecontractitem.FieldProductName:
		return m.ProductName()
	case erppurchasecontractitem.FieldSpecCode:
		return m.SpecCode()
	case erppurchasecontractitem.FieldQuantity:
		return m.Quantity()
	case erppurchasecontractitem.FieldUnitPrice:
		return m.UnitPrice()
	case erppurchasecontractitem.FieldTotalPrice:
		return m.TotalPrice()
	case erppurchasecontractitem.FieldCreatedAt:
		return m.CreatedAt()
	case erppurchasecontractitem.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ERPPurchaseContractItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case erppurchasecontractitem.FieldPurchaseContractID:
		return m.OldPurchaseContractID(ctx)
	case erppurchasecontractitem.FieldLineNo:
		return m.OldLineNo(ctx)
	case erppurchasecontractitem.FieldProductID:
		return m.OldProductID(ctx)
	case erppurchasecontractitem.FieldProductCode:
		return m.OldProductCode(ctx)
	case erppurchasecontractitem.FieldProductName:
		return m.OldProductName(ctx)
	case erppurchasecontractitem.FieldSpecCode:
		return m.OldSpecCode(ctx)
	case erppurchasecontractitem.FieldQuantity:
		return m.OldQuantity(ctx)
	case erppurchasecontractitem.FieldUnitPrice:
		return m.OldUnitPrice(ctx)
	case erppurchasecontractitem.FieldTotalPrice:
		return m.OldTotalPrice(ctx)
	case erppurchasecontractitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case erppurchasecontractitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ERPPurchaseContractItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPPurchaseContractItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case erppurchasecontractitem.FieldPurchaseContractID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchaseContractID(v)
		return nil
	case erppurchasecontractitem.FieldLineNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLineNo(v)
		return nil
	case erppurchasecontractitem.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case erppurchasecontractitem.FieldProductCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductCode(v)
		return nil
	case erppurchasecontractitem.FieldProductName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductName(v)
		return nil
	case erppurchasecontractitem.FieldSpecCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecCode(v)
		return nil
	case erppurchasecontractitem.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case erppurchasecontractitem.FieldUnitPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitPrice(v)
		return nil
	case erppurchasecontractitem.FieldTotalPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalPrice(v)
		return nil
	case erppurchasecontractitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case erppurchasecontractitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ERPPurchaseContractItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ERPPurchaseContractItemMutation) AddedFields() []string {
	var fields []string
	if m.addpurchase_contract_id != nil {
		fields = append(fields, erppurchasecontractitem.FieldPurchaseContractID)
	}
	if m.addline_no != nil {
		fields = append(fields, erppurchasecontractitem.FieldLineNo)
	}
	if m.addproduct_id != nil {
		fields = append(fields, erppurchasecontractitem.FieldProductID)
	}
	if m.addquantity != nil {
		fields = append(fields, erppurchasecontractitem.FieldQuantity)
	}
	if m.addunit_price != nil {
		fields = append(fields, erppurchasecontractitem.FieldUnitPrice)
	}
	if m.addtotal_price != nil {
		fields = append(fields, erppurchasecontractitem.FieldTotalPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ERPPurchaseContractItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case erppurchasecontractitem.FieldPurchaseContractID:
		return m.AddedPurchaseContractID()
	case erppurchasecontractitem.FieldLineNo:
		return m.AddedLineNo()
	case erppurchasecontractitem.FieldProductID:
		return m.AddedProductID()
	case erppurchasecontractitem.FieldQuantity:
		return m.AddedQuantity()
	case erppurchasecontractitem.FieldUnitPrice:
		return m.AddedUnitPrice()
	case erppurchasecontractitem.FieldTotalPrice:
		return m.AddedTotalPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPPurchaseContractItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case erppurchasecontractitem.FieldPurchaseContractID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPurchaseContractID(v)
		return nil
	case erppurchasecontractitem.FieldLineNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLineNo(v)
		return nil
	case erppurchasecontractitem.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case erppurchasecontractitem.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case erppurchasecontractitem.FieldUnitPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitPrice(v)
		return nil
	case erppurchasecontractitem.FieldTotalPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalPrice(v)
		return nil
	}
	return fmt.Errorf("unknown ERPPurchaseContractItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ERPPurchaseContractItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(erppurchasecontractitem.FieldProductID) {
		fields = append(fields, erppurchasecontractitem.FieldProductID)
	}
	if m.FieldCleared(erppurchasecontractitem.FieldProductCode) {
		fields = append(fields, erppurchasecontractitem.FieldProductCode)
	}
	if m.FieldCleared(erppurchasecontractitem.FieldProductName) {
		fields = append(fields, erppurchasecontractitem.FieldProductName)
	}
	if m.FieldCleared(erppurchasecontractitem.FieldSpecCode) {
		fields = append(fields, erppurchasecontractitem.FieldSpecCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ERPPurchaseContractItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ERPPurchaseContractItemMutation) ClearField(name string) error {
	switch name {
	case erppurchasecontractitem.FieldProductID:
		m.ClearProductID()
		return nil
	case erppurchasecontractitem.FieldProductCode:
		m.ClearProductCode()
		return nil
	case erppurchasecontractitem.FieldProductName:
		m.ClearProductName()
		return nil
	case erppurchasecontractitem.FieldSpecCode:
		m.ClearSpecCode()
		return nil
	}
	return fmt.Errorf("unknown ERPPurchaseContractItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ERPPurchaseContractItemMutation) ResetField(name string) error {
	switch name {
	case erppurchasecontractitem.FieldPurchaseContractID:
		m.ResetPurchaseContractID()
		return nil
	case erppurchasecontractitem.FieldLineNo:
		m.ResetLineNo()
		return nil
	case erppurchasecontractitem.FieldProductID:
		m.ResetProductID()
		return nil
	case erppurchasecontractitem.FieldProductCode:
		m.ResetProductCode()
		return nil
	case erppurchasecontractitem.FieldProductName:
		m.ResetProductName()
		return nil
	case erppurchasecontractitem.FieldSpecCode:
		m.ResetSpecCode()
		return nil
	case erppurchasecontractitem.FieldQuantity:
		m.ResetQuantity()
		return nil
	case erppurchasecontractitem.FieldUnitPrice:
		m.ResetUnitPrice()
		return nil
	case erppurchasecontractitem.FieldTotalPrice:
		m.ResetTotalPrice()
		return nil
	case erppurchasecontractitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case erppurchasecontractitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPPurchaseContractItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ERPPurchaseContractItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ERPPurchaseContractItemMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ERPPurchaseContractItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ERPPurchaseContractItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ERPPurchaseContractItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ERPPurchaseContractItemMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ERPPurchaseContractItemMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ERPPurchaseContractItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ERPPurchaseContractItemMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ERPPurchaseContractItem edge %s", name)
}

// ERPQuotationMutation represents an operation that mutates the ERPQuotation nodes in the graph.
type ERPQuotationMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	code                   *string
	customer_partner_id    *int
	addcustomer_partner_id *int
	customer_code          *string
	quoted_date            *time.Time
	currency               *string
	price_term             *string
	payment_method         *string
	delivery_method        *string
	start_place            *string
	end_place              *string
	total_amount           *float64
	addtotal_amount        *float64
	status                 *string
	accepted               *bool
	accepted_at            *time.Time
	remark                 *string
	created_by_admin_id    *int
	addcreated_by_admin_id *int
	updated_by_admin_id    *int
	addupdated_by_admin_id *int
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*ERPQuotation, error)
	predicates             []predicate.ERPQuotation
}

var _ ent.Mutation = (*ERPQuotationMutation)(nil)

// erpquotationOption allows management of the mutation configuration using functional options.
type erpquotationOption func(*ERPQuotationMutation)

// newERPQuotationMutation creates new mutation for the ERPQuotation entity.
func newERPQuotationMutation(c config, op Op, opts ...erpquotationOption) *ERPQuotationMutation {
	m := &ERPQuotationMutation{
		config:        c,
		op:            op,
		typ:           TypeERPQuotation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withERPQuotationID sets the ID field of the mutation.
func withERPQuotationID(id int) erpquotationOption {
	return func(m *ERPQuotationMutation) {
		var (
			err   error
			once  sync.Once
			value *ERPQuotation
		)
		m.oldValue = func(ctx context.Context) (*ERPQuotation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ERPQuotation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withERPQuotation sets the old ERPQuotation of the mutation.
func withERPQuotation(node *ERPQuotation) erpquotationOption {
	return func(m *ERPQuotationMutation) {
		m.oldValue = func(context.Context) (*ERPQuotation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ERPQuotationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ERPQuotationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ERPQuotationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ERPQuotationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ERPQuotation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *ERPQuotationMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ERPQuotationMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the ERPQuotation entity.
// If the ERPQuotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ERPQuotationMutation) ResetCode() {
	m.code = nil
}

// SetCustomerPartnerID sets the "customer_partner_id" field.
func (m *ERPQuotationMutation) SetCustomerPartnerID(i int) {
	m.customer_partner_id = &i
	m.addcustomer_partner_id = nil
}

// CustomerPartnerID returns the value of the "customer_partner_id" field in the mutation.
func (m *ERPQuotationMutation) CustomerPartnerID() (r int, exists bool) {
	v := m.customer_partner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerPartnerID returns the old "customer_partner_id" field's value of the ERPQuotation entity.
// If the ERPQuotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationMutation) OldCustomerPartnerID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerPartnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerPartnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerPartnerID: %w", err)
	}
	return oldValue.CustomerPartnerID, nil
}

// AddCustomerPartnerID adds i to the "customer_partner_id" field.
func (m *ERPQuotationMutation) AddCustomerPartnerID(i int) {
	if m.addcustomer_partner_id != nil {
		*m.addcustomer_partner_id += i
	} else {
		m.addcustomer_partner_id = &i
	}
}

// AddedCustomerPartnerID returns the value that was added to the "customer_partner_id" field in this mutation.
func (m *ERPQuotationMutation) AddedCustomerPartnerID() (r int, exists bool) {
	v := m.addcustomer_partner_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCustomerPartnerID clears the value of the "customer_partner_id" field.
func (m *ERPQuotationMutation) ClearCustomerPartnerID() {
	m.customer_partner_id = nil
	m.addcustomer_partner_id = nil
	m.clearedFields[erpquotation.FieldCustomerPartnerID] = struct{}{}
}

// CustomerPartnerIDCleared returns if the "customer_partner_id" field was cleared in this mutation.
func (m *ERPQuotationMutation) CustomerPartnerIDCleared() bool {
	_, ok := m.clearedFields[erpquotation.FieldCustomerPartnerID]
	return ok
}

// ResetCustomerPartnerID resets all changes to the "customer_partner_id" field.
func (m *ERPQuotationMutation) ResetCustomerPartnerID() {
	m.customer_partner_id = nil
	m.addcustomer_partner_id = nil
	delete(m.clearedFields, erpquotation.FieldCustomerPartnerID)
}

// SetCustomerCode sets the "customer_code" field.
func (m *ERPQuotationMutation) SetCustomerCode(s string) {
	m.customer_code = &s
}

// CustomerCode returns the value of the "customer_code" field in the mutation.
func (m *ERPQuotationMutation) CustomerCode() (r string, exists bool) {
	v := m.customer_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerCode returns the old "customer_code" field's value of the ERPQuotation entity.
// If the ERPQuotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationMutation) OldCustomerCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerCode: %w", err)
	}
	return oldValue.CustomerCode, nil
}

// ClearCustomerCode clears the value of the "customer_code" field.
func (m *ERPQuotationMutation) ClearCustomerCode() {
	m.customer_code = nil
	m.clearedFields[erpquotation.FieldCustomerCode] = struct{}{}
}

// CustomerCodeCleared returns if the "customer_code" field was cleared in this mutation.
func (m *ERPQuotationMutation) CustomerCodeCleared() bool {
	_, ok := m.clearedFields[erpquotation.FieldCustomerCode]
	return ok
}

// ResetCustomerCode resets all changes to the "customer_code" field.
func (m *ERPQuotationMutation) ResetCustomerCode() {
	m.customer_code = nil
	delete(m.clearedFields, erpquotation.FieldCustomerCode)
}

// SetQuotedDate sets the "quoted_date" field.
func (m *ERPQuotationMutation) SetQuotedDate(t time.Time) {
	m.quoted_date = &t
}

// QuotedDate returns the value of the "quoted_date" field in the mutation.
func (m *ERPQuotationMutation) QuotedDate() (r time.Time, exists bool) {
	v := m.quoted_date
	if v == nil {
		return
	}
	return *v, true
}

// OldQuotedDate returns the old "quoted_date" field's value of the ERPQuotation entity.
// If the ERPQuotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationMutation) OldQuotedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuotedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuotedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuotedDate: %w", err)
	}
	return oldValue.QuotedDate, nil
}

// ResetQuotedDate resets all changes to the "quoted_date" field.
func (m *ERPQuotationMutation) ResetQuotedDate() {
	m.quoted_date = nil
}

// SetCurrency sets the "currency" field.
func (m *ERPQuotationMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *ERPQuotationMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the ERPQuotation entity.
// If the ERPQuotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *ERPQuotationMutation) ResetCurrency() {
	m.currency = nil
}

// SetPriceTerm sets the "price_term" field.
func (m *ERPQuotationMutation) SetPriceTerm(s string) {
	m.price_term = &s
}

// PriceTerm returns the value of the "price_term" field in the mutation.
func (m *ERPQuotationMutation) PriceTerm() (r string, exists bool) {
	v := m.price_term
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceTerm returns the old "price_term" field's value of the ERPQuotation entity.
// If the ERPQuotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationMutation) OldPriceTerm(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriceTerm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriceTerm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceTerm: %w", err)
	}
	return oldValue.PriceTerm, nil
}

// ClearPriceTerm clears the value of the "price_term" field.
func (m *ERPQuotationMutation) ClearPriceTerm() {
	m.price_term = nil
	m.clearedFields[erpquotation.FieldPriceTerm] = struct{}{}
}

// PriceTermCleared returns if the "price_term" field was cleared in this mutation.
func (m *ERPQuotationMutation) PriceTermCleared() bool {
	_, ok := m.clearedFields[erpquotation.FieldPriceTerm]
	return ok
}

// ResetPriceTerm resets all changes to the "price_term" field.
func (m *ERPQuotationMutation) ResetPriceTerm() {
	m.price_term = nil
	delete(m.clearedFields, erpquotation.FieldPriceTerm)
}

// SetPaymentMethod sets the "payment_method" field.
func (m *ERPQuotationMutation) SetPaymentMethod(s string) {
	m.payment_method = &s
}

// PaymentMethod returns the value of the "payment_method" field in the mutation.
func (m *ERPQuotationMutation) PaymentMethod() (r string, exists bool) {
	v := m.payment_method
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentMethod returns the old "payment_method" field's value of the ERPQuotation entity.
// If the ERPQuotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationMutation) OldPaymentMethod(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentMethod: %w", err)
	}
	return oldValue.PaymentMethod, nil
}

// ClearPaymentMethod clears the value of the "payment_method" field.
func (m *ERPQuotationMutation) ClearPaymentMethod() {
	m.payment_method = nil
	m.clearedFields[erpquotation.FieldPaymentMethod] = struct{}{}
}

// PaymentMethodCleared returns if the "payment_method" field was cleared in this mutation.
func (m *ERPQuotationMutation) PaymentMethodCleared() bool {
	_, ok := m.clearedFields[erpquotation.FieldPaymentMethod]
	return ok
}

// ResetPaymentMethod resets all changes to the "payment_method" field.
func (m *ERPQuotationMutation) ResetPaymentMethod() {
	m.payment_method = nil
	delete(m.clearedFields, erpquotation.FieldPaymentMethod)
}

// SetDeliveryMethod sets the "delivery_method" field.
func (m *ERPQuotationMutation) SetDeliveryMethod(s string) {
	m.delivery_method = &s
}

// DeliveryMethod returns the value of the "delivery_method" field in the mutation.
func (m *ERPQuotationMutation) DeliveryMethod() (r string, exists bool) {
	v := m.delivery_method
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryMethod returns the old "delivery_method" field's value of the ERPQuotation entity.
// If the ERPQuotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationMutation) OldDeliveryMethod(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryMethod: %w", err)
	}
	return oldValue.DeliveryMethod, nil
}

// ClearDeliveryMethod clears the value of the "delivery_method" field.
func (m *ERPQuotationMutation) ClearDeliveryMethod() {
	m.delivery_method = nil
	m.clearedFields[erpquotation.FieldDeliveryMethod] = struct{}{}
}

// DeliveryMethodCleared returns if the "delivery_method" field was cleared in this mutation.
func (m *ERPQuotationMutation) DeliveryMethodCleared() bool {
	_, ok := m.clearedFields[erpquotation.FieldDeliveryMethod]
	return ok
}

// ResetDeliveryMethod resets all changes to the "delivery_method" field.
func (m *ERPQuotationMutation) ResetDeliveryMethod() {
	m.delivery_method = nil
	delete(m.clearedFields, erpquotation.FieldDeliveryMethod)
}

// SetStartPlace sets the "start_place" field.
func (m *ERPQuotationMutation) SetStartPlace(s string) {
	m.start_place = &s
}

// StartPlace returns the value of the "start_place" field in the mutation.
func (m *ERPQuotationMutation) StartPlace() (r string, exists bool) {
	v := m.start_place
	if v == nil {
		return
	}
	return *v, true
}

// OldStartPlace returns the old "start_place" field's value of the ERPQuotation entity.
// If the ERPQuotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationMutation) OldStartPlace(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartPlace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartPlace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartPlace: %w", err)
	}
	return oldValue.StartPlace, nil
}

// ClearStartPlace clears the value of the "start_place" field.
func (m *ERPQuotationMutation) ClearStartPlace() {
	m.start_place = nil
	m.clearedFields[erpquotation.FieldStartPlace] = struct{}{}
}

// StartPlaceCleared returns if the "start_place" field was cleared in this mutation.
func (m *ERPQuotationMutation) StartPlaceCleared() bool {
	_, ok := m.clearedFields[erpquotation.FieldStartPlace]
	return ok
}

// ResetStartPlace resets all changes to the "start_place" field.
func (m *ERPQuotationMutation) ResetStartPlace() {
	m.start_place = nil
	delete(m.clearedFields, erpquotation.FieldStartPlace)
}

// SetEndPlace sets the "end_place" field.
func (m *ERPQuotationMutation) SetEndPlace(s string) {
	m.end_place = &s
}

// EndPlace returns the value of the "end_place" field in the mutation.
func (m *ERPQuotationMutation) EndPlace() (r string, exists bool) {
	v := m.end_place
	if v == nil {
		return
	}
	return *v, true
}

// OldEndPlace returns the old "end_place" field's value of the ERPQuotation entity.
// If the ERPQuotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationMutation) OldEndPlace(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndPlace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndPlace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndPlace: %w", err)
	}
	return oldValue.EndPlace, nil
}

// ClearEndPlace clears the value of the "end_place" field.
func (m *ERPQuotationMutation) ClearEndPlace() {
	m.end_place = nil
	m.clearedFields[erpquotation.FieldEndPlace] = struct{}{}
}

// EndPlaceCleared returns if the "end_place" field was cleared in this mutation.
func (m *ERPQuotationMutation) EndPlaceCleared() bool {
	_, ok := m.clearedFields[erpquotation.FieldEndPlace]
	return ok
}

// ResetEndPlace resets all changes to the "end_place" field.
func (m *ERPQuotationMutation) ResetEndPlace() {
	m.end_place = nil
	delete(m.clearedFields, erpquotation.FieldEndPlace)
}

// SetTotalAmount sets the "total_amount" field.
func (m *ERPQuotationMutation) SetTotalAmount(f float64) {
	m.total_amount = &f
	m.addtotal_amount = nil
}

// TotalAmount returns the value of the "total_amount" field in the mutation.
func (m *ERPQuotationMutation) TotalAmount() (r float64, exists bool) {
	v := m.total_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAmount returns the old "total_amount" field's value of the ERPQuotation entity.
// If the ERPQuotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationMutation) OldTotalAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAmount: %w", err)
	}
	return oldValue.TotalAmount, nil
}

// AddTotalAmount adds f to the "total_amount" field.
func (m *ERPQuotationMutation) AddTotalAmount(f float64) {
	if m.addtotal_amount != nil {
		*m.addtotal_amount += f
	} else {
		m.addtotal_amount = &f
	}
}

// AddedTotalAmount returns the value that was added to the "total_amount" field in this mutation.
func (m *ERPQuotationMutation) AddedTotalAmount() (r float64, exists bool) {
	v := m.addtotal_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalAmount resets all changes to the "total_amount" field.
func (m *ERPQuotationMutation) ResetTotalAmount() {
	m.total_amount = nil
	m.addtotal_amount = nil
}

// SetStatus sets the "status" field.
func (m *ERPQuotationMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ERPQuotationMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ERPQuotation entity.
// If the ERPQuotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ERPQuotationMutation) ResetStatus() {
	m.status = nil
}

// SetAccepted sets the "accepted" field.
func (m *ERPQuotationMutation) SetAccepted(b bool) {
	m.accepted = &b
}

// Accepted returns the value of the "accepted" field in the mutation.
func (m *ERPQuotationMutation) Accepted() (r bool, exists bool) {
	v := m.accepted
	if v == nil {
		return
	}
	return *v, true
}

// OldAccepted returns the old "accepted" field's value of the ERPQuotation entity.
// If the ERPQuotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationMutation) OldAccepted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccepted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccepted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccepted: %w", err)
	}
	return oldValue.Accepted, nil
}

// ResetAccepted resets all changes to the "accepted" field.
func (m *ERPQuotationMutation) ResetAccepted() {
	m.accepted = nil
}

// SetAcceptedAt sets the "accepted_at" field.
func (m *ERPQuotationMutation) SetAcceptedAt(t time.Time) {
	m.accepted_at = &t
}

// AcceptedAt returns the value of the "accepted_at" field in the mutation.
func (m *ERPQuotationMutation) AcceptedAt() (r time.Time, exists bool) {
	v := m.accepted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAcceptedAt returns the old "accepted_at" field's value of the ERPQuotation entity.
// If the ERPQuotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationMutation) OldAcceptedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcceptedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcceptedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcceptedAt: %w", err)
	}
	return oldValue.AcceptedAt, nil
}

// ClearAcceptedAt clears the value of the "accepted_at" field.
func (m *ERPQuotationMutation) ClearAcceptedAt() {
	m.accepted_at = nil
	m.clearedFields[erpquotation.FieldAcceptedAt] = struct{}{}
}

// AcceptedAtCleared returns if the "accepted_at" field was cleared in this mutation.
func (m *ERPQuotationMutation) AcceptedAtCleared() bool {
	_, ok := m.clearedFields[erpquotation.FieldAcceptedAt]
	return ok
}

// ResetAcceptedAt resets all changes to the "accepted_at" field.
func (m *ERPQuotationMutation) ResetAcceptedAt() {
	m.accepted_at = nil
	delete(m.clearedFields, erpquotation.FieldAcceptedAt)
}

// SetRemark sets the "remark" field.
func (m *ERPQuotationMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ERPQuotationMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the ERPQuotation entity.
// If the ERPQuotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ERPQuotationMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[erpquotation.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ERPQuotationMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[erpquotation.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ERPQuotationMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, erpquotation.FieldRemark)
}

// SetCreatedByAdminID sets the "created_by_admin_id" field.
func (m *ERPQuotationMutation) SetCreatedByAdminID(i int) {
	m.created_by_admin_id = &i
	m.addcreated_by_admin_id = nil
}

// CreatedByAdminID returns the value of the "created_by_admin_id" field in the mutation.
func (m *ERPQuotationMutation) CreatedByAdminID() (r int, exists bool) {
	v := m.created_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedByAdminID returns the old "created_by_admin_id" field's value of the ERPQuotation entity.
// If the ERPQuotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationMutation) OldCreatedByAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedByAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedByAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedByAdminID: %w", err)
	}
	return oldValue.CreatedByAdminID, nil
}

// AddCreatedByAdminID adds i to the "created_by_admin_id" field.
func (m *ERPQuotationMutation) AddCreatedByAdminID(i int) {
	if m.addcreated_by_admin_id != nil {
		*m.addcreated_by_admin_id += i
	} else {
		m.addcreated_by_admin_id = &i
	}
}

// AddedCreatedByAdminID returns the value that was added to the "created_by_admin_id" field in this mutation.
func (m *ERPQuotationMutation) AddedCreatedByAdminID() (r int, exists bool) {
	v := m.addcreated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedByAdminID clears the value of the "created_by_admin_id" field.
func (m *ERPQuotationMutation) ClearCreatedByAdminID() {
	m.created_by_admin_id = nil
	m.addcreated_by_admin_id = nil
	m.clearedFields[erpquotation.FieldCreatedByAdminID] = struct{}{}
}

// CreatedByAdminIDCleared returns if the "created_by_admin_id" field was cleared in this mutation.
func (m *ERPQuotationMutation) CreatedByAdminIDCleared() bool {
	_, ok := m.clearedFields[erpquotation.FieldCreatedByAdminID]
	return ok
}

// ResetCreatedByAdminID resets all changes to the "created_by_admin_id" field.
func (m *ERPQuotationMutation) ResetCreatedByAdminID() {
	m.created_by_admin_id = nil
	m.addcreated_by_admin_id = nil
	delete(m.clearedFields, erpquotation.FieldCreatedByAdminID)
}

// SetUpdatedByAdminID sets the "updated_by_admin_id" field.
func (m *ERPQuotationMutation) SetUpdatedByAdminID(i int) {
	m.updated_by_admin_id = &i
	m.addupdated_by_admin_id = nil
}

// UpdatedByAdminID returns the value of the "updated_by_admin_id" field in the mutation.
func (m *ERPQuotationMutation) UpdatedByAdminID() (r int, exists bool) {
	v := m.updated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedByAdminID returns the old "updated_by_admin_id" field's value of the ERPQuotation entity.
// If the ERPQuotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationMutation) OldUpdatedByAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedByAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedByAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedByAdminID: %w", err)
	}
	return oldValue.UpdatedByAdminID, nil
}

// AddUpdatedByAdminID adds i to the "updated_by_admin_id" field.
func (m *ERPQuotationMutation) AddUpdatedByAdminID(i int) {
	if m.addupdated_by_admin_id != nil {
		*m.addupdated_by_admin_id += i
	} else {
		m.addupdated_by_admin_id = &i
	}
}

// AddedUpdatedByAdminID returns the value that was added to the "updated_by_admin_id" field in this mutation.
func (m *ERPQuotationMutation) AddedUpdatedByAdminID() (r int, exists bool) {
	v := m.addupdated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedByAdminID clears the value of the "updated_by_admin_id" field.
func (m *ERPQuotationMutation) ClearUpdatedByAdminID() {
	m.updated_by_admin_id = nil
	m.addupdated_by_admin_id = nil
	m.clearedFields[erpquotation.FieldUpdatedByAdminID] = struct{}{}
}

// UpdatedByAdminIDCleared returns if the "updated_by_admin_id" field was cleared in this mutation.
func (m *ERPQuotationMutation) UpdatedByAdminIDCleared() bool {
	_, ok := m.clearedFields[erpquotation.FieldUpdatedByAdminID]
	return ok
}

// ResetUpdatedByAdminID resets all changes to the "updated_by_admin_id" field.
func (m *ERPQuotationMutation) ResetUpdatedByAdminID() {
	m.updated_by_admin_id = nil
	m.addupdated_by_admin_id = nil
	delete(m.clearedFields, erpquotation.FieldUpdatedByAdminID)
}

// SetCreatedAt sets the "created_at" field.
func (m *ERPQuotationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ERPQuotationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ERPQuotation entity.
// If the ERPQuotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ERPQuotationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ERPQuotationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ERPQuotationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ERPQuotation entity.
// If the ERPQuotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ERPQuotationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ERPQuotationMutation builder.
func (m *ERPQuotationMutation) Where(ps ...predicate.ERPQuotation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ERPQuotationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ERPQuotationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ERPQuotation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ERPQuotationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ERPQuotationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ERPQuotation).
func (m *ERPQuotationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ERPQuotationMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.code != nil {
		fields = append(fields, erpquotation.FieldCode)
	}
	if m.customer_partner_id != nil {
		fields = append(fields, erpquotation.FieldCustomerPartnerID)
	}
	if m.customer_code != nil {
		fields = append(fields, erpquotation.FieldCustomerCode)
	}
	if m.quoted_date != nil {
		fields = append(fields, erpquotation.FieldQuotedDate)
	}
	if m.currency != nil {
		fields = append(fields, erpquotation.FieldCurrency)
	}
	if m.price_term != nil {
		fields = append(fields, erpquotation.FieldPriceTerm)
	}
	if m.payment_method != nil {
		fields = append(fields, erpquotation.FieldPaymentMethod)
	}
	if m.delivery_method != nil {
		fields = append(fields, erpquotation.FieldDeliveryMethod)
	}
	if m.start_place != nil {
		fields = append(fields, erpquotation.FieldStartPlace)
	}
	if m.end_place != nil {
		fields = append(fields, erpquotation.FieldEndPlace)
	}
	if m.total_amount != nil {
		fields = append(fields, erpquotation.FieldTotalAmount)
	}
	if m.status != nil {
		fields = append(fields, erpquotation.FieldStatus)
	}
	if m.accepted != nil {
		fields = append(fields, erpquotation.FieldAccepted)
	}
	if m.accepted_at != nil {
		fields = append(fields, erpquotation.FieldAcceptedAt)
	}
	if m.remark != nil {
		fields = append(fields, erpquotation.FieldRemark)
	}
	if m.created_by_admin_id != nil {
		fields = append(fields, erpquotation.FieldCreatedByAdminID)
	}
	if m.updated_by_admin_id != nil {
		fields = append(fields, erpquotation.FieldUpdatedByAdminID)
	}
	if m.created_at != nil {
		fields = append(fields, erpquotation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, erpquotation.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ERPQuotationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case erpquotation.FieldCode:
		return m.Code()
	case erpquotation.FieldCustomerPartnerID:
		return m.CustomerPartnerID()
	case erpquotation.FieldCustomerCode:
		return m.CustomerCode()
	case erpquotation.FieldQuotedDate:
		return m.QuotedDate()
	case erpquotation.FieldCurrency:
		return m.Currency()
	case erpquotation.FieldPriceTerm:
		return m.PriceTerm()
	case erpquotation.FieldPaymentMethod:
		return m.PaymentMethod()
	case erpquotation.FieldDeliveryMethod:
		return m.DeliveryMethod()
	case erpquotation.FieldStartPlace:
		return m.StartPlace()
	case erpquotation.FieldEndPlace:
		return m.EndPlace()
	case erpquotation.FieldTotalAmount:
		return m.TotalAmount()
	case erpquotation.FieldStatus:
		return m.Status()
	case erpquotation.FieldAccepted:
		return m.Accepted()
	case erpquotation.FieldAcceptedAt:
		return m.AcceptedAt()
	case erpquotation.FieldRemark:
		return m.Remark()
	case erpquotation.FieldCreatedByAdminID:
		return m.CreatedByAdminID()
	case erpquotation.FieldUpdatedByAdminID:
		return m.UpdatedByAdminID()
	case erpquotation.FieldCreatedAt:
		return m.CreatedAt()
	case erpquotation.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ERPQuotationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case erpquotation.FieldCode:
		return m.OldCode(ctx)
	case erpquotation.FieldCustomerPartnerID:
		return m.OldCustomerPartnerID(ctx)
	case erpquotation.FieldCustomerCode:
		return m.OldCustomerCode(ctx)
	case erpquotation.FieldQuotedDate:
		return m.OldQuotedDate(ctx)
	case erpquotation.FieldCurrency:
		return m.OldCurrency(ctx)
	case erpquotation.FieldPriceTerm:
		return m.OldPriceTerm(ctx)
	case erpquotation.FieldPaymentMethod:
		return m.OldPaymentMethod(ctx)
	case erpquotation.FieldDeliveryMethod:
		return m.OldDeliveryMethod(ctx)
	case erpquotation.FieldStartPlace:
		return m.OldStartPlace(ctx)
	case erpquotation.FieldEndPlace:
		return m.OldEndPlace(ctx)
	case erpquotation.FieldTotalAmount:
		return m.OldTotalAmount(ctx)
	case erpquotation.FieldStatus:
		return m.OldStatus(ctx)
	case erpquotation.FieldAccepted:
		return m.OldAccepted(ctx)
	case erpquotation.FieldAcceptedAt:
		return m.OldAcceptedAt(ctx)
	case erpquotation.FieldRemark:
		return m.OldRemark(ctx)
	case erpquotation.FieldCreatedByAdminID:
		return m.OldCreatedByAdminID(ctx)
	case erpquotation.FieldUpdatedByAdminID:
		return m.OldUpdatedByAdminID(ctx)
	case erpquotation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case erpquotation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ERPQuotation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPQuotationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case erpquotation.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case erpquotation.FieldCustomerPartnerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerPartnerID(v)
		return nil
	case erpquotation.FieldCustomerCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerCode(v)
		return nil
	case erpquotation.FieldQuotedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuotedDate(v)
		return nil
	case erpquotation.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case erpquotation.FieldPriceTerm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceTerm(v)
		return nil
	case erpquotation.FieldPaymentMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentMethod(v)
		return nil
	case erpquotation.FieldDeliveryMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryMethod(v)
		return nil
	case erpquotation.FieldStartPlace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartPlace(v)
		return nil
	case erpquotation.FieldEndPlace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndPlace(v)
		return nil
	case erpquotation.FieldTotalAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAmount(v)
		return nil
	case erpquotation.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case erpquotation.FieldAccepted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccepted(v)
		return nil
	case erpquotation.FieldAcceptedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcceptedAt(v)
		return nil
	case erpquotation.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case erpquotation.FieldCreatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedByAdminID(v)
		return nil
	case erpquotation.FieldUpdatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedByAdminID(v)
		return nil
	case erpquotation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case erpquotation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ERPQuotation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ERPQuotationMutation) AddedFields() []string {
	var fields []string
	if m.addcustomer_partner_id != nil {
		fields = append(fields, erpquotation.FieldCustomerPartnerID)
	}
	if m.addtotal_amount != nil {
		fields = append(fields, erpquotation.FieldTotalAmount)
	}
	if m.addcreated_by_admin_id != nil {
		fields = append(fields, erpquotation.FieldCreatedByAdminID)
	}
	if m.addupdated_by_admin_id != nil {
		fields = append(fields, erpquotation.FieldUpdatedByAdminID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ERPQuotationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case erpquotation.FieldCustomerPartnerID:
		return m.AddedCustomerPartnerID()
	case erpquotation.FieldTotalAmount:
		return m.AddedTotalAmount()
	case erpquotation.FieldCreatedByAdminID:
		return m.AddedCreatedByAdminID()
	case erpquotation.FieldUpdatedByAdminID:
		return m.AddedUpdatedByAdminID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPQuotationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case erpquotation.FieldCustomerPartnerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCustomerPartnerID(v)
		return nil
	case erpquotation.FieldTotalAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalAmount(v)
		return nil
	case erpquotation.FieldCreatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedByAdminID(v)
		return nil
	case erpquotation.FieldUpdatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedByAdminID(v)
		return nil
	}
	return fmt.Errorf("unknown ERPQuotation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ERPQuotationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(erpquotation.FieldCustomerPartnerID) {
		fields = append(fields, erpquotation.FieldCustomerPartnerID)
	}
	if m.FieldCleared(erpquotation.FieldCustomerCode) {
		fields = append(fields, erpquotation.FieldCustomerCode)
	}
	if m.FieldCleared(erpquotation.FieldPriceTerm) {
		fields = append(fields, erpquotation.FieldPriceTerm)
	}
	if m.FieldCleared(erpquotation.FieldPaymentMethod) {
		fields = append(fields, erpquotation.FieldPaymentMethod)
	}
	if m.FieldCleared(erpquotation.FieldDeliveryMethod) {
		fields = append(fields, erpquotation.FieldDeliveryMethod)
	}
	if m.FieldCleared(erpquotation.FieldStartPlace) {
		fields = append(fields, erpquotation.FieldStartPlace)
	}
	if m.FieldCleared(erpquotation.FieldEndPlace) {
		fields = append(fields, erpquotation.FieldEndPlace)
	}
	if m.FieldCleared(erpquotation.FieldAcceptedAt) {
		fields = append(fields, erpquotation.FieldAcceptedAt)
	}
	if m.FieldCleared(erpquotation.FieldRemark) {
		fields = append(fields, erpquotation.FieldRemark)
	}
	if m.FieldCleared(erpquotation.FieldCreatedByAdminID) {
		fields = append(fields, erpquotation.FieldCreatedByAdminID)
	}
	if m.FieldCleared(erpquotation.FieldUpdatedByAdminID) {
		fields = append(fields, erpquotation.FieldUpdatedByAdminID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ERPQuotationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ERPQuotationMutation) ClearField(name string) error {
	switch name {
	case erpquotation.FieldCustomerPartnerID:
		m.ClearCustomerPartnerID()
		return nil
	case erpquotation.FieldCustomerCode:
		m.ClearCustomerCode()
		return nil
	case erpquotation.FieldPriceTerm:
		m.ClearPriceTerm()
		return nil
	case erpquotation.FieldPaymentMethod:
		m.ClearPaymentMethod()
		return nil
	case erpquotation.FieldDeliveryMethod:
		m.ClearDeliveryMethod()
		return nil
	case erpquotation.FieldStartPlace:
		m.ClearStartPlace()
		return nil
	case erpquotation.FieldEndPlace:
		m.ClearEndPlace()
		return nil
	case erpquotation.FieldAcceptedAt:
		m.ClearAcceptedAt()
		return nil
	case erpquotation.FieldRemark:
		m.ClearRemark()
		return nil
	case erpquotation.FieldCreatedByAdminID:
		m.ClearCreatedByAdminID()
		return nil
	case erpquotation.FieldUpdatedByAdminID:
		m.ClearUpdatedByAdminID()
		return nil
	}
	return fmt.Errorf("unknown ERPQuotation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ERPQuotationMutation) ResetField(name string) error {
	switch name {
	case erpquotation.FieldCode:
		m.ResetCode()
		return nil
	case erpquotation.FieldCustomerPartnerID:
		m.ResetCustomerPartnerID()
		return nil
	case erpquotation.FieldCustomerCode:
		m.ResetCustomerCode()
		return nil
	case erpquotation.FieldQuotedDate:
		m.ResetQuotedDate()
		return nil
	case erpquotation.FieldCurrency:
		m.ResetCurrency()
		return nil
	case erpquotation.FieldPriceTerm:
		m.ResetPriceTerm()
		return nil
	case erpquotation.FieldPaymentMethod:
		m.ResetPaymentMethod()
		return nil
	case erpquotation.FieldDeliveryMethod:
		m.ResetDeliveryMethod()
		return nil
	case erpquotation.FieldStartPlace:
		m.ResetStartPlace()
		return nil
	case erpquotation.FieldEndPlace:
		m.ResetEndPlace()
		return nil
	case erpquotation.FieldTotalAmount:
		m.ResetTotalAmount()
		return nil
	case erpquotation.FieldStatus:
		m.ResetStatus()
		return nil
	case erpquotation.FieldAccepted:
		m.ResetAccepted()
		return nil
	case erpquotation.FieldAcceptedAt:
		m.ResetAcceptedAt()
		return nil
	case erpquotation.FieldRemark:
		m.ResetRemark()
		return nil
	case erpquotation.FieldCreatedByAdminID:
		m.ResetCreatedByAdminID()
		return nil
	case erpquotation.FieldUpdatedByAdminID:
		m.ResetUpdatedByAdminID()
		return nil
	case erpquotation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case erpquotation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPQuotation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ERPQuotationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ERPQuotationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ERPQuotationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ERPQuotationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ERPQuotationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ERPQuotationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ERPQuotationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ERPQuotation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ERPQuotationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ERPQuotation edge %s", name)
}

// ERPQuotationItemMutation represents an operation that mutates the ERPQuotationItem nodes in the graph.
type ERPQuotationItemMutation struct {
	config
	op              Op
	typ             string
	id              *int
	quotation_id    *int
	addquotation_id *int
	line_no         *int
	addline_no      *int
	product_id      *int
	addproduct_id   *int
	product_code    *string
	product_name    *string
	quantity        *float64
	addquantity     *float64
	unit_price      *float64
	addunit_price   *float64
	total_price     *float64
	addtotal_price  *float64
	remark          *string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*ERPQuotationItem, error)
	predicates      []predicate.ERPQuotationItem
}

var _ ent.Mutation = (*ERPQuotationItemMutation)(nil)

// erpquotationitemOption allows management of the mutation configuration using functional options.
type erpquotationitemOption func(*ERPQuotationItemMutation)

// newERPQuotationItemMutation creates new mutation for the ERPQuotationItem entity.
func newERPQuotationItemMutation(c config, op Op, opts ...erpquotationitemOption) *ERPQuotationItemMutation {
	m := &ERPQuotationItemMutation{
		config:        c,
		op:            op,
		typ:           TypeERPQuotationItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withERPQuotationItemID sets the ID field of the mutation.
func withERPQuotationItemID(id int) erpquotationitemOption {
	return func(m *ERPQuotationItemMutation) {
		var (
			err   error
			once  sync.Once
			value *ERPQuotationItem
		)
		m.oldValue = func(ctx context.Context) (*ERPQuotationItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ERPQuotationItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withERPQuotationItem sets the old ERPQuotationItem of the mutation.
func withERPQuotationItem(node *ERPQuotationItem) erpquotationitemOption {
	return func(m *ERPQuotationItemMutation) {
		m.oldValue = func(context.Context) (*ERPQuotationItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ERPQuotationItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ERPQuotationItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ERPQuotationItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ERPQuotationItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ERPQuotationItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuotationID sets the "quotation_id" field.
func (m *ERPQuotationItemMutation) SetQuotationID(i int) {
	m.quotation_id = &i
	m.addquotation_id = nil
}

// QuotationID returns the value of the "quotation_id" field in the mutation.
func (m *ERPQuotationItemMutation) QuotationID() (r int, exists bool) {
	v := m.quotation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldQuotationID returns the old "quotation_id" field's value of the ERPQuotationItem entity.
// If the ERPQuotationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationItemMutation) OldQuotationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuotationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuotationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuotationID: %w", err)
	}
	return oldValue.QuotationID, nil
}

// AddQuotationID adds i to the "quotation_id" field.
func (m *ERPQuotationItemMutation) AddQuotationID(i int) {
	if m.addquotation_id != nil {
		*m.addquotation_id += i
	} else {
		m.addquotation_id = &i
	}
}

// AddedQuotationID returns the value that was added to the "quotation_id" field in this mutation.
func (m *ERPQuotationItemMutation) AddedQuotationID() (r int, exists bool) {
	v := m.addquotation_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuotationID resets all changes to the "quotation_id" field.
func (m *ERPQuotationItemMutation) ResetQuotationID() {
	m.quotation_id = nil
	m.addquotation_id = nil
}

// SetLineNo sets the "line_no" field.
func (m *ERPQuotationItemMutation) SetLineNo(i int) {
	m.line_no = &i
	m.addline_no = nil
}

// LineNo returns the value of the "line_no" field in the mutation.
func (m *ERPQuotationItemMutation) LineNo() (r int, exists bool) {
	v := m.line_no
	if v == nil {
		return
	}
	return *v, true
}

// OldLineNo returns the old "line_no" field's value of the ERPQuotationItem entity.
// If the ERPQuotationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationItemMutation) OldLineNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLineNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLineNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLineNo: %w", err)
	}
	return oldValue.LineNo, nil
}

// AddLineNo adds i to the "line_no" field.
func (m *ERPQuotationItemMutation) AddLineNo(i int) {
	if m.addline_no != nil {
		*m.addline_no += i
	} else {
		m.addline_no = &i
	}
}

// AddedLineNo returns the value that was added to the "line_no" field in this mutation.
func (m *ERPQuotationItemMutation) AddedLineNo() (r int, exists bool) {
	v := m.addline_no
	if v == nil {
		return
	}
	return *v, true
}

// ResetLineNo resets all changes to the "line_no" field.
func (m *ERPQuotationItemMutation) ResetLineNo() {
	m.line_no = nil
	m.addline_no = nil
}

// SetProductID sets the "product_id" field.
func (m *ERPQuotationItemMutation) SetProductID(i int) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ERPQuotationItemMutation) ProductID() (r int, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the ERPQuotationItem entity.
// If the ERPQuotationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationItemMutation) OldProductID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *ERPQuotationItemMutation) AddProductID(i int) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *ERPQuotationItemMutation) AddedProductID() (r int, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductID clears the value of the "product_id" field.
func (m *ERPQuotationItemMutation) ClearProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	m.clearedFields[erpquotationitem.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *ERPQuotationItemMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[erpquotationitem.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ERPQuotationItemMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	delete(m.clearedFields, erpquotationitem.FieldProductID)
}

// SetProductCode sets the "product_code" field.
func (m *ERPQuotationItemMutation) SetProductCode(s string) {
	m.product_code = &s
}

// ProductCode returns the value of the "product_code" field in the mutation.
func (m *ERPQuotationItemMutation) ProductCode() (r string, exists bool) {
	v := m.product_code
	if v == nil {
		return
	}
	return *v, true
}

// OldProductCode returns the old "product_code" field's value of the ERPQuotationItem entity.
// If the ERPQuotationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationItemMutation) OldProductCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductCode: %w", err)
	}
	return oldValue.ProductCode, nil
}

// ClearProductCode clears the value of the "product_code" field.
func (m *ERPQuotationItemMutation) ClearProductCode() {
	m.product_code = nil
	m.clearedFields[erpquotationitem.FieldProductCode] = struct{}{}
}

// ProductCodeCleared returns if the "product_code" field was cleared in this mutation.
func (m *ERPQuotationItemMutation) ProductCodeCleared() bool {
	_, ok := m.clearedFields[erpquotationitem.FieldProductCode]
	return ok
}

// ResetProductCode resets all changes to the "product_code" field.
func (m *ERPQuotationItemMutation) ResetProductCode() {
	m.product_code = nil
	delete(m.clearedFields, erpquotationitem.FieldProductCode)
}

// SetProductName sets the "product_name" field.
func (m *ERPQuotationItemMutation) SetProductName(s string) {
	m.product_name = &s
}

// ProductName returns the value of the "product_name" field in the mutation.
func (m *ERPQuotationItemMutation) ProductName() (r string, exists bool) {
	v := m.product_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProductName returns the old "product_name" field's value of the ERPQuotationItem entity.
// If the ERPQuotationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationItemMutation) OldProductName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductName: %w", err)
	}
	return oldValue.ProductName, nil
}

// ClearProductName clears the value of the "product_name" field.
func (m *ERPQuotationItemMutation) ClearProductName() {
	m.product_name = nil
	m.clearedFields[erpquotationitem.FieldProductName] = struct{}{}
}

// ProductNameCleared returns if the "product_name" field was cleared in this mutation.
func (m *ERPQuotationItemMutation) ProductNameCleared() bool {
	_, ok := m.clearedFields[erpquotationitem.FieldProductName]
	return ok
}

// ResetProductName resets all changes to the "product_name" field.
func (m *ERPQuotationItemMutation) ResetProductName() {
	m.product_name = nil
	delete(m.clearedFields, erpquotationitem.FieldProductName)
}

// SetQuantity sets the "quantity" field.
func (m *ERPQuotationItemMutation) SetQuantity(f float64) {
	m.quantity = &f
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *ERPQuotationItemMutation) Quantity() (r float64, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the ERPQuotationItem entity.
// If the ERPQuotationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationItemMutation) OldQuantity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds f to the "quantity" field.
func (m *ERPQuotationItemMutation) AddQuantity(f float64) {
	if m.addquantity != nil {
		*m.addquantity += f
	} else {
		m.addquantity = &f
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *ERPQuotationItemMutation) AddedQuantity() (r float64, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *ERPQuotationItemMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetUnitPrice sets the "unit_price" field.
func (m *ERPQuotationItemMutation) SetUnitPrice(f float64) {
	m.unit_price = &f
	m.addunit_price = nil
}

// UnitPrice returns the value of the "unit_price" field in the mutation.
func (m *ERPQuotationItemMutation) UnitPrice() (r float64, exists bool) {
	v := m.unit_price
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitPrice returns the old "unit_price" field's value of the ERPQuotationItem entity.
// If the ERPQuotationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationItemMutation) OldUnitPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitPrice: %w", err)
	}
	return oldValue.UnitPrice, nil
}

// AddUnitPrice adds f to the "unit_price" field.
func (m *ERPQuotationItemMutation) AddUnitPrice(f float64) {
	if m.addunit_price != nil {
		*m.addunit_price += f
	} else {
		m.addunit_price = &f
	}
}

// AddedUnitPrice returns the value that was added to the "unit_price" field in this mutation.
func (m *ERPQuotationItemMutation) AddedUnitPrice() (r float64, exists bool) {
	v := m.addunit_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnitPrice resets all changes to the "unit_price" field.
func (m *ERPQuotationItemMutation) ResetUnitPrice() {
	m.unit_price = nil
	m.addunit_price = nil
}

// SetTotalPrice sets the "total_price" field.
func (m *ERPQuotationItemMutation) SetTotalPrice(f float64) {
	m.total_price = &f
	m.addtotal_price = nil
}

// TotalPrice returns the value of the "total_price" field in the mutation.
func (m *ERPQuotationItemMutation) TotalPrice() (r float64, exists bool) {
	v := m.total_price
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalPrice returns the old "total_price" field's value of the ERPQuotationItem entity.
// If the ERPQuotationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationItemMutation) OldTotalPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalPrice: %w", err)
	}
	return oldValue.TotalPrice, nil
}

// AddTotalPrice adds f to the "total_price" field.
func (m *ERPQuotationItemMutation) AddTotalPrice(f float64) {
	if m.addtotal_price != nil {
		*m.addtotal_price += f
	} else {
		m.addtotal_price = &f
	}
}

// AddedTotalPrice returns the value that was added to the "total_price" field in this mutation.
func (m *ERPQuotationItemMutation) AddedTotalPrice() (r float64, exists bool) {
	v := m.addtotal_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalPrice resets all changes to the "total_price" field.
func (m *ERPQuotationItemMutation) ResetTotalPrice() {
	m.total_price = nil
	m.addtotal_price = nil
}

// SetRemark sets the "remark" field.
func (m *ERPQuotationItemMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ERPQuotationItemMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the ERPQuotationItem entity.
// If the ERPQuotationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationItemMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ERPQuotationItemMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[erpquotationitem.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ERPQuotationItemMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[erpquotationitem.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ERPQuotationItemMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, erpquotationitem.FieldRemark)
}

// SetCreatedAt sets the "created_at" field.
func (m *ERPQuotationItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ERPQuotationItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ERPQuotationItem entity.
// If the ERPQuotationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ERPQuotationItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ERPQuotationItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ERPQuotationItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ERPQuotationItem entity.
// If the ERPQuotationItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPQuotationItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ERPQuotationItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ERPQuotationItemMutation builder.
func (m *ERPQuotationItemMutation) Where(ps ...predicate.ERPQuotationItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ERPQuotationItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ERPQuotationItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ERPQuotationItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ERPQuotationItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ERPQuotationItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ERPQuotationItem).
func (m *ERPQuotationItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ERPQuotationItemMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.quotation_id != nil {
		fields = append(fields, erpquotationitem.FieldQuotationID)
	}
	if m.line_no != nil {
		fields = append(fields, erpquotationitem.FieldLineNo)
	}
	if m.product_id != nil {
		fields = append(fields, erpquotationitem.FieldProductID)
	}
	if m.product_code != nil {
		fields = append(fields, erpquotationitem.FieldProductCode)
	}
	if m.product_name != nil {
		fields = append(fields, erpquotationitem.FieldProductName)
	}
	if m.quantity != nil {
		fields = append(fields, erpquotationitem.FieldQuantity)
	}
	if m.unit_price != nil {
		fields = append(fields, erpquotationitem.FieldUnitPrice)
	}
	if m.total_price != nil {
		fields = append(fields, erpquotationitem.FieldTotalPrice)
	}
	if m.remark != nil {
		fields = append(fields, erpquotationitem.FieldRemark)
	}
	if m.created_at != nil {
		fields = append(fields, erpquotationitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, erpquotationitem.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ERPQuotationItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case erpquotationitem.FieldQuotationID:
		return m.QuotationID()
	case erpquotationitem.FieldLineNo:
		return m.LineNo()
	case erpquotationitem.FieldProductID:
		return m.ProductID()
	case erpquotationitem.FieldProductCode:
		return m.ProductCode()
	case erpquotationitem.FieldProductName:
		return m.ProductName()
	case erpquotationitem.FieldQuantity:
		return m.Quantity()
	case erpquotationitem.FieldUnitPrice:
		return m.UnitPrice()
	case erpquotationitem.FieldTotalPrice:
		return m.TotalPrice()
	case erpquotationitem.FieldRemark:
		return m.Remark()
	case erpquotationitem.FieldCreatedAt:
		return m.CreatedAt()
	case erpquotationitem.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ERPQuotationItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case erpquotationitem.FieldQuotationID:
		return m.OldQuotationID(ctx)
	case erpquotationitem.FieldLineNo:
		return m.OldLineNo(ctx)
	case erpquotationitem.FieldProductID:
		return m.OldProductID(ctx)
	case erpquotationitem.FieldProductCode:
		return m.OldProductCode(ctx)
	case erpquotationitem.FieldProductName:
		return m.OldProductName(ctx)
	case erpquotationitem.FieldQuantity:
		return m.OldQuantity(ctx)
	case erpquotationitem.FieldUnitPrice:
		return m.OldUnitPrice(ctx)
	case erpquotationitem.FieldTotalPrice:
		return m.OldTotalPrice(ctx)
	case erpquotationitem.FieldRemark:
		return m.OldRemark(ctx)
	case erpquotationitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case erpquotationitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ERPQuotationItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPQuotationItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case erpquotationitem.FieldQuotationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuotationID(v)
		return nil
	case erpquotationitem.FieldLineNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLineNo(v)
		return nil
	case erpquotationitem.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case erpquotationitem.FieldProductCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductCode(v)
		return nil
	case erpquotationitem.FieldProductName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductName(v)
		return nil
	case erpquotationitem.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case erpquotationitem.FieldUnitPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitPrice(v)
		return nil
	case erpquotationitem.FieldTotalPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalPrice(v)
		return nil
	case erpquotationitem.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case erpquotationitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case erpquotationitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ERPQuotationItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ERPQuotationItemMutation) AddedFields() []string {
	var fields []string
	if m.addquotation_id != nil {
		fields = append(fields, erpquotationitem.FieldQuotationID)
	}
	if m.addline_no != nil {
		fields = append(fields, erpquotationitem.FieldLineNo)
	}
	if m.addproduct_id != nil {
		fields = append(fields, erpquotationitem.FieldProductID)
	}
	if m.addquantity != nil {
		fields = append(fields, erpquotationitem.FieldQuantity)
	}
	if m.addunit_price != nil {
		fields = append(fields, erpquotationitem.FieldUnitPrice)
	}
	if m.addtotal_price != nil {
		fields = append(fields, erpquotationitem.FieldTotalPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ERPQuotationItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case erpquotationitem.FieldQuotationID:
		return m.AddedQuotationID()
	case erpquotationitem.FieldLineNo:
		return m.AddedLineNo()
	case erpquotationitem.FieldProductID:
		return m.AddedProductID()
	case erpquotationitem.FieldQuantity:
		return m.AddedQuantity()
	case erpquotationitem.FieldUnitPrice:
		return m.AddedUnitPrice()
	case erpquotationitem.FieldTotalPrice:
		return m.AddedTotalPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPQuotationItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case erpquotationitem.FieldQuotationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuotationID(v)
		return nil
	case erpquotationitem.FieldLineNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLineNo(v)
		return nil
	case erpquotationitem.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case erpquotationitem.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case erpquotationitem.FieldUnitPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitPrice(v)
		return nil
	case erpquotationitem.FieldTotalPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalPrice(v)
		return nil
	}
	return fmt.Errorf("unknown ERPQuotationItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ERPQuotationItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(erpquotationitem.FieldProductID) {
		fields = append(fields, erpquotationitem.FieldProductID)
	}
	if m.FieldCleared(erpquotationitem.FieldProductCode) {
		fields = append(fields, erpquotationitem.FieldProductCode)
	}
	if m.FieldCleared(erpquotationitem.FieldProductName) {
		fields = append(fields, erpquotationitem.FieldProductName)
	}
	if m.FieldCleared(erpquotationitem.FieldRemark) {
		fields = append(fields, erpquotationitem.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ERPQuotationItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ERPQuotationItemMutation) ClearField(name string) error {
	switch name {
	case erpquotationitem.FieldProductID:
		m.ClearProductID()
		return nil
	case erpquotationitem.FieldProductCode:
		m.ClearProductCode()
		return nil
	case erpquotationitem.FieldProductName:
		m.ClearProductName()
		return nil
	case erpquotationitem.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown ERPQuotationItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ERPQuotationItemMutation) ResetField(name string) error {
	switch name {
	case erpquotationitem.FieldQuotationID:
		m.ResetQuotationID()
		return nil
	case erpquotationitem.FieldLineNo:
		m.ResetLineNo()
		return nil
	case erpquotationitem.FieldProductID:
		m.ResetProductID()
		return nil
	case erpquotationitem.FieldProductCode:
		m.ResetProductCode()
		return nil
	case erpquotationitem.FieldProductName:
		m.ResetProductName()
		return nil
	case erpquotationitem.FieldQuantity:
		m.ResetQuantity()
		return nil
	case erpquotationitem.FieldUnitPrice:
		m.ResetUnitPrice()
		return nil
	case erpquotationitem.FieldTotalPrice:
		m.ResetTotalPrice()
		return nil
	case erpquotationitem.FieldRemark:
		m.ResetRemark()
		return nil
	case erpquotationitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case erpquotationitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPQuotationItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ERPQuotationItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ERPQuotationItemMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ERPQuotationItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ERPQuotationItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ERPQuotationItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ERPQuotationItemMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ERPQuotationItemMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ERPQuotationItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ERPQuotationItemMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ERPQuotationItem edge %s", name)
}

// ERPSequenceMutation represents an operation that mutates the ERPSequence nodes in the graph.
type ERPSequenceMutation struct {
	config
	op               Op
	typ              string
	id               *int
	biz_type         *string
	current_value    *int64
	addcurrent_value *int64
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*ERPSequence, error)
	predicates       []predicate.ERPSequence
}

var _ ent.Mutation = (*ERPSequenceMutation)(nil)

// erpsequenceOption allows management of the mutation configuration using functional options.
type erpsequenceOption func(*ERPSequenceMutation)

// newERPSequenceMutation creates new mutation for the ERPSequence entity.
func newERPSequenceMutation(c config, op Op, opts ...erpsequenceOption) *ERPSequenceMutation {
	m := &ERPSequenceMutation{
		config:        c,
		op:            op,
		typ:           TypeERPSequence,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withERPSequenceID sets the ID field of the mutation.
func withERPSequenceID(id int) erpsequenceOption {
	return func(m *ERPSequenceMutation) {
		var (
			err   error
			once  sync.Once
			value *ERPSequence
		)
		m.oldValue = func(ctx context.Context) (*ERPSequence, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ERPSequence.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withERPSequence sets the old ERPSequence of the mutation.
func withERPSequence(node *ERPSequence) erpsequenceOption {
	return func(m *ERPSequenceMutation) {
		m.oldValue = func(context.Context) (*ERPSequence, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ERPSequenceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ERPSequenceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ERPSequenceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ERPSequenceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ERPSequence.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBizType sets the "biz_type" field.
func (m *ERPSequenceMutation) SetBizType(s string) {
	m.biz_type = &s
}

// BizType returns the value of the "biz_type" field in the mutation.
func (m *ERPSequenceMutation) BizType() (r string, exists bool) {
	v := m.biz_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBizType returns the old "biz_type" field's value of the ERPSequence entity.
// If the ERPSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPSequenceMutation) OldBizType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBizType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBizType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBizType: %w", err)
	}
	return oldValue.BizType, nil
}

// ResetBizType resets all changes to the "biz_type" field.
func (m *ERPSequenceMutation) ResetBizType() {
	m.biz_type = nil
}

// SetCurrentValue sets the "current_value" field.
func (m *ERPSequenceMutation) SetCurrentValue(i int64) {
	m.current_value = &i
	m.addcurrent_value = nil
}

// CurrentValue returns the value of the "current_value" field in the mutation.
func (m *ERPSequenceMutation) CurrentValue() (r int64, exists bool) {
	v := m.current_value
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentValue returns the old "current_value" field's value of the ERPSequence entity.
// If the ERPSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPSequenceMutation) OldCurrentValue(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentValue: %w", err)
	}
	return oldValue.CurrentValue, nil
}

// AddCurrentValue adds i to the "current_value" field.
func (m *ERPSequenceMutation) AddCurrentValue(i int64) {
	if m.addcurrent_value != nil {
		*m.addcurrent_value += i
	} else {
		m.addcurrent_value = &i
	}
}

// AddedCurrentValue returns the value that was added to the "current_value" field in this mutation.
func (m *ERPSequenceMutation) AddedCurrentValue() (r int64, exists bool) {
	v := m.addcurrent_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrentValue resets all changes to the "current_value" field.
func (m *ERPSequenceMutation) ResetCurrentValue() {
	m.current_value = nil
	m.addcurrent_value = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ERPSequenceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ERPSequenceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ERPSequence entity.
// If the ERPSequence object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPSequenceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ERPSequenceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ERPSequenceMutation builder.
func (m *ERPSequenceMutation) Where(ps ...predicate.ERPSequence) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ERPSequenceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ERPSequenceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ERPSequence, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ERPSequenceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ERPSequenceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ERPSequence).
func (m *ERPSequenceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ERPSequenceMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.biz_type != nil {
		fields = append(fields, erpsequence.FieldBizType)
	}
	if m.current_value != nil {
		fields = append(fields, erpsequence.FieldCurrentValue)
	}
	if m.updated_at != nil {
		fields = append(fields, erpsequence.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ERPSequenceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case erpsequence.FieldBizType:
		return m.BizType()
	case erpsequence.FieldCurrentValue:
		return m.CurrentValue()
	case erpsequence.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ERPSequenceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case erpsequence.FieldBizType:
		return m.OldBizType(ctx)
	case erpsequence.FieldCurrentValue:
		return m.OldCurrentValue(ctx)
	case erpsequence.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ERPSequence field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPSequenceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case erpsequence.FieldBizType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBizType(v)
		return nil
	case erpsequence.FieldCurrentValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentValue(v)
		return nil
	case erpsequence.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ERPSequence field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ERPSequenceMutation) AddedFields() []string {
	var fields []string
	if m.addcurrent_value != nil {
		fields = append(fields, erpsequence.FieldCurrentValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ERPSequenceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case erpsequence.FieldCurrentValue:
		return m.AddedCurrentValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPSequenceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case erpsequence.FieldCurrentValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentValue(v)
		return nil
	}
	return fmt.Errorf("unknown ERPSequence numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ERPSequenceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ERPSequenceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ERPSequenceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ERPSequence nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ERPSequenceMutation) ResetField(name string) error {
	switch name {
	case erpsequence.FieldBizType:
		m.ResetBizType()
		return nil
	case erpsequence.FieldCurrentValue:
		m.ResetCurrentValue()
		return nil
	case erpsequence.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPSequence field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ERPSequenceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ERPSequenceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ERPSequenceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ERPSequenceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ERPSequenceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ERPSequenceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ERPSequenceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ERPSequence unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ERPSequenceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ERPSequence edge %s", name)
}

// ERPSettlementMutation represents an operation that mutates the ERPSettlement nodes in the graph.
type ERPSettlementMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	code                   *string
	invoice_no             *string
	customer_name          *string
	currency               *string
	ship_date              *time.Time
	payment_cycle_days     *int
	addpayment_cycle_days  *int
	receivable_date        *time.Time
	amount                 *float64
	addamount              *float64
	received_amount        *float64
	addreceived_amount     *float64
	outstanding_amount     *float64
	addoutstanding_amount  *float64
	status                 *string
	source_shipment_code   *string
	created_by_admin_id    *int
	addcreated_by_admin_id *int
	updated_by_admin_id    *int
	addupdated_by_admin_id *int
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*ERPSettlement, error)
	predicates             []predicate.ERPSettlement
}

var _ ent.Mutation = (*ERPSettlementMutation)(nil)

// erpsettlementOption allows management of the mutation configuration using functional options.
type erpsettlementOption func(*ERPSettlementMutation)

// newERPSettlementMutation creates new mutation for the ERPSettlement entity.
func newERPSettlementMutation(c config, op Op, opts ...erpsettlementOption) *ERPSettlementMutation {
	m := &ERPSettlementMutation{
		config:        c,
		op:            op,
		typ:           TypeERPSettlement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withERPSettlementID sets the ID field of the mutation.
func withERPSettlementID(id int) erpsettlementOption {
	return func(m *ERPSettlementMutation) {
		var (
			err   error
			once  sync.Once
			value *ERPSettlement
		)
		m.oldValue = func(ctx context.Context) (*ERPSettlement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ERPSettlement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withERPSettlement sets the old ERPSettlement of the mutation.
func withERPSettlement(node *ERPSettlement) erpsettlementOption {
	return func(m *ERPSettlementMutation) {
		m.oldValue = func(context.Context) (*ERPSettlement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ERPSettlementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ERPSettlementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ERPSettlementMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ERPSettlementMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ERPSettlement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *ERPSettlementMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ERPSettlementMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the ERPSettlement entity.
// If the ERPSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPSettlementMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ERPSettlementMutation) ResetCode() {
	m.code = nil
}

// SetInvoiceNo sets the "invoice_no" field.
func (m *ERPSettlementMutation) SetInvoiceNo(s string) {
	m.invoice_no = &s
}

// InvoiceNo returns the value of the "invoice_no" field in the mutation.
func (m *ERPSettlementMutation) InvoiceNo() (r string, exists bool) {
	v := m.invoice_no
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceNo returns the old "invoice_no" field's value of the ERPSettlement entity.
// If the ERPSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPSettlementMutation) OldInvoiceNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceNo: %w", err)
	}
	return oldValue.InvoiceNo, nil
}

// ResetInvoiceNo resets all changes to the "invoice_no" field.
func (m *ERPSettlementMutation) ResetInvoiceNo() {
	m.invoice_no = nil
}

// SetCustomerName sets the "customer_name" field.
func (m *ERPSettlementMutation) SetCustomerName(s string) {
	m.customer_name = &s
}

// CustomerName returns the value of the "customer_name" field in the mutation.
func (m *ERPSettlementMutation) CustomerName() (r string, exists bool) {
	v := m.customer_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerName returns the old "customer_name" field's value of the ERPSettlement entity.
// If the ERPSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPSettlementMutation) OldCustomerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerName: %w", err)
	}
	return oldValue.CustomerName, nil
}

// ResetCustomerName resets all changes to the "customer_name" field.
func (m *ERPSettlementMutation) ResetCustomerName() {
	m.customer_name = nil
}

// SetCurrency sets the "currency" field.
func (m *ERPSettlementMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *ERPSettlementMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the ERPSettlement entity.
// If the ERPSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPSettlementMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *ERPSettlementMutation) ResetCurrency() {
	m.currency = nil
}

// SetShipDate sets the "ship_date" field.
func (m *ERPSettlementMutation) SetShipDate(t time.Time) {
	m.ship_date = &t
}

// ShipDate returns the value of the "ship_date" field in the mutation.
func (m *ERPSettlementMutation) ShipDate() (r time.Time, exists bool) {
	v := m.ship_date
	if v == nil {
		return
	}
	return *v, true
}

// OldShipDate returns the old "ship_date" field's value of the ERPSettlement entity.
// If the ERPSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPSettlementMutation) OldShipDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipDate: %w", err)
	}
	return oldValue.ShipDate, nil
}

// ResetShipDate resets all changes to the "ship_date" field.
func (m *ERPSettlementMutation) ResetShipDate() {
	m.ship_date = nil
}

// SetPaymentCycleDays sets the "payment_cycle_days" field.
func (m *ERPSettlementMutation) SetPaymentCycleDays(i int) {
	m.payment_cycle_days = &i
	m.addpayment_cycle_days = nil
}

// PaymentCycleDays returns the value of the "payment_cycle_days" field in the mutation.
func (m *ERPSettlementMutation) PaymentCycleDays() (r int, exists bool) {
	v := m.payment_cycle_days
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentCycleDays returns the old "payment_cycle_days" field's value of the ERPSettlement entity.
// If the ERPSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPSettlementMutation) OldPaymentCycleDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentCycleDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentCycleDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentCycleDays: %w", err)
	}
	return oldValue.PaymentCycleDays, nil
}

// AddPaymentCycleDays adds i to the "payment_cycle_days" field.
func (m *ERPSettlementMutation) AddPaymentCycleDays(i int) {
	if m.addpayment_cycle_days != nil {
		*m.addpayment_cycle_days += i
	} else {
		m.addpayment_cycle_days = &i
	}
}

// AddedPaymentCycleDays returns the value that was added to the "payment_cycle_days" field in this mutation.
func (m *ERPSettlementMutation) AddedPaymentCycleDays() (r int, exists bool) {
	v := m.addpayment_cycle_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetPaymentCycleDays resets all changes to the "payment_cycle_days" field.
func (m *ERPSettlementMutation) ResetPaymentCycleDays() {
	m.payment_cycle_days = nil
	m.addpayment_cycle_days = nil
}

// SetReceivableDate sets the "receivable_date" field.
func (m *ERPSettlementMutation) SetReceivableDate(t time.Time) {
	m.receivable_date = &t
}

// ReceivableDate returns the value of the "receivable_date" field in the mutation.
func (m *ERPSettlementMutation) ReceivableDate() (r time.Time, exists bool) {
	v := m.receivable_date
	if v == nil {
		return
	}
	return *v, true
}

// OldReceivableDate returns the old "receivable_date" field's value of the ERPSettlement entity.
// If the ERPSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPSettlementMutation) OldReceivableDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceivableDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceivableDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceivableDate: %w", err)
	}
	return oldValue.ReceivableDate, nil
}

// ResetReceivableDate resets all changes to the "receivable_date" field.
func (m *ERPSettlementMutation) ResetReceivableDate() {
	m.receivable_date = nil
}

// SetAmount sets the "amount" field.
func (m *ERPSettlementMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *ERPSettlementMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the ERPSettlement entity.
// If the ERPSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPSettlementMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *ERPSettlementMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *ERPSettlementMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *ERPSettlementMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetReceivedAmount sets the "received_amount" field.
func (m *ERPSettlementMutation) SetReceivedAmount(f float64) {
	m.received_amount = &f
	m.addreceived_amount = nil
}

// ReceivedAmount returns the value of the "received_amount" field in the mutation.
func (m *ERPSettlementMutation) ReceivedAmount() (r float64, exists bool) {
	v := m.received_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldReceivedAmount returns the old "received_amount" field's value of the ERPSettlement entity.
// If the ERPSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPSettlementMutation) OldReceivedAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceivedAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceivedAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceivedAmount: %w", err)
	}
	return oldValue.ReceivedAmount, nil
}

// AddReceivedAmount adds f to the "received_amount" field.
func (m *ERPSettlementMutation) AddReceivedAmount(f float64) {
	if m.addreceived_amount != nil {
		*m.addreceived_amount += f
	} else {
		m.addreceived_amount = &f
	}
}

// AddedReceivedAmount returns the value that was added to the "received_amount" field in this mutation.
func (m *ERPSettlementMutation) AddedReceivedAmount() (r float64, exists bool) {
	v := m.addreceived_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetReceivedAmount resets all changes to the "received_amount" field.
func (m *ERPSettlementMutation) ResetReceivedAmount() {
	m.received_amount = nil
	m.addreceived_amount = nil
}

// SetOutstandingAmount sets the "outstanding_amount" field.
func (m *ERPSettlementMutation) SetOutstandingAmount(f float64) {
	m.outstanding_amount = &f
	m.addoutstanding_amount = nil
}

// OutstandingAmount returns the value of the "outstanding_amount" field in the mutation.
func (m *ERPSettlementMutation) OutstandingAmount() (r float64, exists bool) {
	v := m.outstanding_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldOutstandingAmount returns the old "outstanding_amount" field's value of the ERPSettlement entity.
// If the ERPSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPSettlementMutation) OldOutstandingAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutstandingAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutstandingAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutstandingAmount: %w", err)
	}
	return oldValue.OutstandingAmount, nil
}

// AddOutstandingAmount adds f to the "outstanding_amount" field.
func (m *ERPSettlementMutation) AddOutstandingAmount(f float64) {
	if m.addoutstanding_amount != nil {
		*m.addoutstanding_amount += f
	} else {
		m.addoutstanding_amount = &f
	}
}

// AddedOutstandingAmount returns the value that was added to the "outstanding_amount" field in this mutation.
func (m *ERPSettlementMutation) AddedOutstandingAmount() (r float64, exists bool) {
	v := m.addoutstanding_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetOutstandingAmount resets all changes to the "outstanding_amount" field.
func (m *ERPSettlementMutation) ResetOutstandingAmount() {
	m.outstanding_amount = nil
	m.addoutstanding_amount = nil
}

// SetStatus sets the "status" field.
func (m *ERPSettlementMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ERPSettlementMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ERPSettlement entity.
// If the ERPSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPSettlementMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ERPSettlementMutation) ResetStatus() {
	m.status = nil
}

// SetSourceShipmentCode sets the "source_shipment_code" field.
func (m *ERPSettlementMutation) SetSourceShipmentCode(s string) {
	m.source_shipment_code = &s
}

// SourceShipmentCode returns the value of the "source_shipment_code" field in the mutation.
func (m *ERPSettlementMutation) SourceShipmentCode() (r string, exists bool) {
	v := m.source_shipment_code
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceShipmentCode returns the old "source_shipment_code" field's value of the ERPSettlement entity.
// If the ERPSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPSettlementMutation) OldSourceShipmentCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceShipmentCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceShipmentCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceShipmentCode: %w", err)
	}
	return oldValue.SourceShipmentCode, nil
}

// ClearSourceShipmentCode clears the value of the "source_shipment_code" field.
func (m *ERPSettlementMutation) ClearSourceShipmentCode() {
	m.source_shipment_code = nil
	m.clearedFields[erpsettlement.FieldSourceShipmentCode] = struct{}{}
}

// SourceShipmentCodeCleared returns if the "source_shipment_code" field was cleared in this mutation.
func (m *ERPSettlementMutation) SourceShipmentCodeCleared() bool {
	_, ok := m.clearedFields[erpsettlement.FieldSourceShipmentCode]
	return ok
}

// ResetSourceShipmentCode resets all changes to the "source_shipment_code" field.
func (m *ERPSettlementMutation) ResetSourceShipmentCode() {
	m.source_shipment_code = nil
	delete(m.clearedFields, erpsettlement.FieldSourceShipmentCode)
}

// SetCreatedByAdminID sets the "created_by_admin_id" field.
func (m *ERPSettlementMutation) SetCreatedByAdminID(i int) {
	m.created_by_admin_id = &i
	m.addcreated_by_admin_id = nil
}

// CreatedByAdminID returns the value of the "created_by_admin_id" field in the mutation.
func (m *ERPSettlementMutation) CreatedByAdminID() (r int, exists bool) {
	v := m.created_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedByAdminID returns the old "created_by_admin_id" field's value of the ERPSettlement entity.
// If the ERPSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPSettlementMutation) OldCreatedByAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedByAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedByAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedByAdminID: %w", err)
	}
	return oldValue.CreatedByAdminID, nil
}

// AddCreatedByAdminID adds i to the "created_by_admin_id" field.
func (m *ERPSettlementMutation) AddCreatedByAdminID(i int) {
	if m.addcreated_by_admin_id != nil {
		*m.addcreated_by_admin_id += i
	} else {
		m.addcreated_by_admin_id = &i
	}
}

// AddedCreatedByAdminID returns the value that was added to the "created_by_admin_id" field in this mutation.
func (m *ERPSettlementMutation) AddedCreatedByAdminID() (r int, exists bool) {
	v := m.addcreated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedByAdminID clears the value of the "created_by_admin_id" field.
func (m *ERPSettlementMutation) ClearCreatedByAdminID() {
	m.created_by_admin_id = nil
	m.addcreated_by_admin_id = nil
	m.clearedFields[erpsettlement.FieldCreatedByAdminID] = struct{}{}
}

// CreatedByAdminIDCleared returns if the "created_by_admin_id" field was cleared in this mutation.
func (m *ERPSettlementMutation) CreatedByAdminIDCleared() bool {
	_, ok := m.clearedFields[erpsettlement.FieldCreatedByAdminID]
	return ok
}

// ResetCreatedByAdminID resets all changes to the "created_by_admin_id" field.
func (m *ERPSettlementMutation) ResetCreatedByAdminID() {
	m.created_by_admin_id = nil
	m.addcreated_by_admin_id = nil
	delete(m.clearedFields, erpsettlement.FieldCreatedByAdminID)
}

// SetUpdatedByAdminID sets the "updated_by_admin_id" field.
func (m *ERPSettlementMutation) SetUpdatedByAdminID(i int) {
	m.updated_by_admin_id = &i
	m.addupdated_by_admin_id = nil
}

// UpdatedByAdminID returns the value of the "updated_by_admin_id" field in the mutation.
func (m *ERPSettlementMutation) UpdatedByAdminID() (r int, exists bool) {
	v := m.updated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedByAdminID returns the old "updated_by_admin_id" field's value of the ERPSettlement entity.
// If the ERPSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPSettlementMutation) OldUpdatedByAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedByAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedByAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedByAdminID: %w", err)
	}
	return oldValue.UpdatedByAdminID, nil
}

// AddUpdatedByAdminID adds i to the "updated_by_admin_id" field.
func (m *ERPSettlementMutation) AddUpdatedByAdminID(i int) {
	if m.addupdated_by_admin_id != nil {
		*m.addupdated_by_admin_id += i
	} else {
		m.addupdated_by_admin_id = &i
	}
}

// AddedUpdatedByAdminID returns the value that was added to the "updated_by_admin_id" field in this mutation.
func (m *ERPSettlementMutation) AddedUpdatedByAdminID() (r int, exists bool) {
	v := m.addupdated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedByAdminID clears the value of the "updated_by_admin_id" field.
func (m *ERPSettlementMutation) ClearUpdatedByAdminID() {
	m.updated_by_admin_id = nil
	m.addupdated_by_admin_id = nil
	m.clearedFields[erpsettlement.FieldUpdatedByAdminID] = struct{}{}
}

// UpdatedByAdminIDCleared returns if the "updated_by_admin_id" field was cleared in this mutation.
func (m *ERPSettlementMutation) UpdatedByAdminIDCleared() bool {
	_, ok := m.clearedFields[erpsettlement.FieldUpdatedByAdminID]
	return ok
}

// ResetUpdatedByAdminID resets all changes to the "updated_by_admin_id" field.
func (m *ERPSettlementMutation) ResetUpdatedByAdminID() {
	m.updated_by_admin_id = nil
	m.addupdated_by_admin_id = nil
	delete(m.clearedFields, erpsettlement.FieldUpdatedByAdminID)
}

// SetCreatedAt sets the "created_at" field.
func (m *ERPSettlementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ERPSettlementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ERPSettlement entity.
// If the ERPSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPSettlementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ERPSettlementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ERPSettlementMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ERPSettlementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ERPSettlement entity.
// If the ERPSettlement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPSettlementMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ERPSettlementMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ERPSettlementMutation builder.
func (m *ERPSettlementMutation) Where(ps ...predicate.ERPSettlement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ERPSettlementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ERPSettlementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ERPSettlement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ERPSettlementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ERPSettlementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ERPSettlement).
func (m *ERPSettlementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ERPSettlementMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.code != nil {
		fields = append(fields, erpsettlement.FieldCode)
	}
	if m.invoice_no != nil {
		fields = append(fields, erpsettlement.FieldInvoiceNo)
	}
	if m.customer_name != nil {
		fields = append(fields, erpsettlement.FieldCustomerName)
	}
	if m.currency != nil {
		fields = append(fields, erpsettlement.FieldCurrency)
	}
	if m.ship_date != nil {
		fields = append(fields, erpsettlement.FieldShipDate)
	}
	if m.payment_cycle_days != nil {
		fields = append(fields, erpsettlement.FieldPaymentCycleDays)
	}
	if m.receivable_date != nil {
		fields = append(fields, erpsettlement.FieldReceivableDate)
	}
	if m.amount != nil {
		fields = append(fields, erpsettlement.FieldAmount)
	}
	if m.received_amount != nil {
		fields = append(fields, erpsettlement.FieldReceivedAmount)
	}
	if m.outstanding_amount != nil {
		fields = append(fields, erpsettlement.FieldOutstandingAmount)
	}
	if m.status != nil {
		fields = append(fields, erpsettlement.FieldStatus)
	}
	if m.source_shipment_code != nil {
		fields = append(fields, erpsettlement.FieldSourceShipmentCode)
	}
	if m.created_by_admin_id != nil {
		fields = append(fields, erpsettlement.FieldCreatedByAdminID)
	}
	if m.updated_by_admin_id != nil {
		fields = append(fields, erpsettlement.FieldUpdatedByAdminID)
	}
	if m.created_at != nil {
		fields = append(fields, erpsettlement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, erpsettlement.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ERPSettlementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case erpsettlement.FieldCode:
		return m.Code()
	case erpsettlement.FieldInvoiceNo:
		return m.InvoiceNo()
	case erpsettlement.FieldCustomerName:
		return m.CustomerName()
	case erpsettlement.FieldCurrency:
		return m.Currency()
	case erpsettlement.FieldShipDate:
		return m.ShipDate()
	case erpsettlement.FieldPaymentCycleDays:
		return m.PaymentCycleDays()
	case erpsettlement.FieldReceivableDate:
		return m.ReceivableDate()
	case erpsettlement.FieldAmount:
		return m.Amount()
	case erpsettlement.FieldReceivedAmount:
		return m.ReceivedAmount()
	case erpsettlement.FieldOutstandingAmount:
		return m.OutstandingAmount()
	case erpsettlement.FieldStatus:
		return m.Status()
	case erpsettlement.FieldSourceShipmentCode:
		return m.SourceShipmentCode()
	case erpsettlement.FieldCreatedByAdminID:
		return m.CreatedByAdminID()
	case erpsettlement.FieldUpdatedByAdminID:
		return m.UpdatedByAdminID()
	case erpsettlement.FieldCreatedAt:
		return m.CreatedAt()
	case erpsettlement.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ERPSettlementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case erpsettlement.FieldCode:
		return m.OldCode(ctx)
	case erpsettlement.FieldInvoiceNo:
		return m.OldInvoiceNo(ctx)
	case erpsettlement.FieldCustomerName:
		return m.OldCustomerName(ctx)
	case erpsettlement.FieldCurrency:
		return m.OldCurrency(ctx)
	case erpsettlement.FieldShipDate:
		return m.OldShipDate(ctx)
	case erpsettlement.FieldPaymentCycleDays:
		return m.OldPaymentCycleDays(ctx)
	case erpsettlement.FieldReceivableDate:
		return m.OldReceivableDate(ctx)
	case erpsettlement.FieldAmount:
		return m.OldAmount(ctx)
	case erpsettlement.FieldReceivedAmount:
		return m.OldReceivedAmount(ctx)
	case erpsettlement.FieldOutstandingAmount:
		return m.OldOutstandingAmount(ctx)
	case erpsettlement.FieldStatus:
		return m.OldStatus(ctx)
	case erpsettlement.FieldSourceShipmentCode:
		return m.OldSourceShipmentCode(ctx)
	case erpsettlement.FieldCreatedByAdminID:
		return m.OldCreatedByAdminID(ctx)
	case erpsettlement.FieldUpdatedByAdminID:
		return m.OldUpdatedByAdminID(ctx)
	case erpsettlement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case erpsettlement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ERPSettlement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPSettlementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case erpsettlement.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case erpsettlement.FieldInvoiceNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceNo(v)
		return nil
	case erpsettlement.FieldCustomerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerName(v)
		return nil
	case erpsettlement.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case erpsettlement.FieldShipDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipDate(v)
		return nil
	case erpsettlement.FieldPaymentCycleDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentCycleDays(v)
		return nil
	case erpsettlement.FieldReceivableDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceivableDate(v)
		return nil
	case erpsettlement.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case erpsettlement.FieldReceivedAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceivedAmount(v)
		return nil
	case erpsettlement.FieldOutstandingAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutstandingAmount(v)
		return nil
	case erpsettlement.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case erpsettlement.FieldSourceShipmentCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceShipmentCode(v)
		return nil
	case erpsettlement.FieldCreatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedByAdminID(v)
		return nil
	case erpsettlement.FieldUpdatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedByAdminID(v)
		return nil
	case erpsettlement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case erpsettlement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ERPSettlement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ERPSettlementMutation) AddedFields() []string {
	var fields []string
	if m.addpayment_cycle_days != nil {
		fields = append(fields, erpsettlement.FieldPaymentCycleDays)
	}
	if m.addamount != nil {
		fields = append(fields, erpsettlement.FieldAmount)
	}
	if m.addreceived_amount != nil {
		fields = append(fields, erpsettlement.FieldReceivedAmount)
	}
	if m.addoutstanding_amount != nil {
		fields = append(fields, erpsettlement.FieldOutstandingAmount)
	}
	if m.addcreated_by_admin_id != nil {
		fields = append(fields, erpsettlement.FieldCreatedByAdminID)
	}
	if m.addupdated_by_admin_id != nil {
		fields = append(fields, erpsettlement.FieldUpdatedByAdminID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ERPSettlementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case erpsettlement.FieldPaymentCycleDays:
		return m.AddedPaymentCycleDays()
	case erpsettlement.FieldAmount:
		return m.AddedAmount()
	case erpsettlement.FieldReceivedAmount:
		return m.AddedReceivedAmount()
	case erpsettlement.FieldOutstandingAmount:
		return m.AddedOutstandingAmount()
	case erpsettlement.FieldCreatedByAdminID:
		return m.AddedCreatedByAdminID()
	case erpsettlement.FieldUpdatedByAdminID:
		return m.AddedUpdatedByAdminID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPSettlementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case erpsettlement.FieldPaymentCycleDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPaymentCycleDays(v)
		return nil
	case erpsettlement.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case erpsettlement.FieldReceivedAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReceivedAmount(v)
		return nil
	case erpsettlement.FieldOutstandingAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutstandingAmount(v)
		return nil
	case erpsettlement.FieldCreatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedByAdminID(v)
		return nil
	case erpsettlement.FieldUpdatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedByAdminID(v)
		return nil
	}
	return fmt.Errorf("unknown ERPSettlement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ERPSettlementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(erpsettlement.FieldSourceShipmentCode) {
		fields = append(fields, erpsettlement.FieldSourceShipmentCode)
	}
	if m.FieldCleared(erpsettlement.FieldCreatedByAdminID) {
		fields = append(fields, erpsettlement.FieldCreatedByAdminID)
	}
	if m.FieldCleared(erpsettlement.FieldUpdatedByAdminID) {
		fields = append(fields, erpsettlement.FieldUpdatedByAdminID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ERPSettlementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ERPSettlementMutation) ClearField(name string) error {
	switch name {
	case erpsettlement.FieldSourceShipmentCode:
		m.ClearSourceShipmentCode()
		return nil
	case erpsettlement.FieldCreatedByAdminID:
		m.ClearCreatedByAdminID()
		return nil
	case erpsettlement.FieldUpdatedByAdminID:
		m.ClearUpdatedByAdminID()
		return nil
	}
	return fmt.Errorf("unknown ERPSettlement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ERPSettlementMutation) ResetField(name string) error {
	switch name {
	case erpsettlement.FieldCode:
		m.ResetCode()
		return nil
	case erpsettlement.FieldInvoiceNo:
		m.ResetInvoiceNo()
		return nil
	case erpsettlement.FieldCustomerName:
		m.ResetCustomerName()
		return nil
	case erpsettlement.FieldCurrency:
		m.ResetCurrency()
		return nil
	case erpsettlement.FieldShipDate:
		m.ResetShipDate()
		return nil
	case erpsettlement.FieldPaymentCycleDays:
		m.ResetPaymentCycleDays()
		return nil
	case erpsettlement.FieldReceivableDate:
		m.ResetReceivableDate()
		return nil
	case erpsettlement.FieldAmount:
		m.ResetAmount()
		return nil
	case erpsettlement.FieldReceivedAmount:
		m.ResetReceivedAmount()
		return nil
	case erpsettlement.FieldOutstandingAmount:
		m.ResetOutstandingAmount()
		return nil
	case erpsettlement.FieldStatus:
		m.ResetStatus()
		return nil
	case erpsettlement.FieldSourceShipmentCode:
		m.ResetSourceShipmentCode()
		return nil
	case erpsettlement.FieldCreatedByAdminID:
		m.ResetCreatedByAdminID()
		return nil
	case erpsettlement.FieldUpdatedByAdminID:
		m.ResetUpdatedByAdminID()
		return nil
	case erpsettlement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case erpsettlement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPSettlement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ERPSettlementMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ERPSettlementMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ERPSettlementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ERPSettlementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ERPSettlementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ERPSettlementMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ERPSettlementMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ERPSettlement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ERPSettlementMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ERPSettlement edge %s", name)
}

// ERPShipmentDetailMutation represents an operation that mutates the ERPShipmentDetail nodes in the graph.
type ERPShipmentDetailMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	code                   *string
	export_sale_id         *int
	addexport_sale_id      *int
	source_export_code     *string
	customer_partner_id    *int
	addcustomer_partner_id *int
	customer_code          *string
	start_port             *string
	dest_port              *string
	ship_to_address        *string
	arrive_country         *string
	transport_type         *string
	sales_owner            *string
	warehouse_ship_date    *time.Time
	total_packages         *float64
	addtotal_packages      *float64
	total_amount           *float64
	addtotal_amount        *float64
	status                 *string
	remark                 *string
	created_by_admin_id    *int
	addcreated_by_admin_id *int
	updated_by_admin_id    *int
	addupdated_by_admin_id *int
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*ERPShipmentDetail, error)
	predicates             []predicate.ERPShipmentDetail
}

var _ ent.Mutation = (*ERPShipmentDetailMutation)(nil)

// erpshipmentdetailOption allows management of the mutation configuration using functional options.
type erpshipmentdetailOption func(*ERPShipmentDetailMutation)

// newERPShipmentDetailMutation creates new mutation for the ERPShipmentDetail entity.
func newERPShipmentDetailMutation(c config, op Op, opts ...erpshipmentdetailOption) *ERPShipmentDetailMutation {
	m := &ERPShipmentDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeERPShipmentDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withERPShipmentDetailID sets the ID field of the mutation.
func withERPShipmentDetailID(id int) erpshipmentdetailOption {
	return func(m *ERPShipmentDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *ERPShipmentDetail
		)
		m.oldValue = func(ctx context.Context) (*ERPShipmentDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ERPShipmentDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withERPShipmentDetail sets the old ERPShipmentDetail of the mutation.
func withERPShipmentDetail(node *ERPShipmentDetail) erpshipmentdetailOption {
	return func(m *ERPShipmentDetailMutation) {
		m.oldValue = func(context.Context) (*ERPShipmentDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ERPShipmentDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ERPShipmentDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ERPShipmentDetailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ERPShipmentDetailMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ERPShipmentDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *ERPShipmentDetailMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ERPShipmentDetailMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the ERPShipmentDetail entity.
// If the ERPShipmentDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ERPShipmentDetailMutation) ResetCode() {
	m.code = nil
}

// SetExportSaleID sets the "export_sale_id" field.
func (m *ERPShipmentDetailMutation) SetExportSaleID(i int) {
	m.export_sale_id = &i
	m.addexport_sale_id = nil
}

// ExportSaleID returns the value of the "export_sale_id" field in the mutation.
func (m *ERPShipmentDetailMutation) ExportSaleID() (r int, exists bool) {
	v := m.export_sale_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExportSaleID returns the old "export_sale_id" field's value of the ERPShipmentDetail entity.
// If the ERPShipmentDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailMutation) OldExportSaleID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExportSaleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExportSaleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExportSaleID: %w", err)
	}
	return oldValue.ExportSaleID, nil
}

// AddExportSaleID adds i to the "export_sale_id" field.
func (m *ERPShipmentDetailMutation) AddExportSaleID(i int) {
	if m.addexport_sale_id != nil {
		*m.addexport_sale_id += i
	} else {
		m.addexport_sale_id = &i
	}
}

// AddedExportSaleID returns the value that was added to the "export_sale_id" field in this mutation.
func (m *ERPShipmentDetailMutation) AddedExportSaleID() (r int, exists bool) {
	v := m.addexport_sale_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearExportSaleID clears the value of the "export_sale_id" field.
func (m *ERPShipmentDetailMutation) ClearExportSaleID() {
	m.export_sale_id = nil
	m.addexport_sale_id = nil
	m.clearedFields[erpshipmentdetail.FieldExportSaleID] = struct{}{}
}

// ExportSaleIDCleared returns if the "export_sale_id" field was cleared in this mutation.
func (m *ERPShipmentDetailMutation) ExportSaleIDCleared() bool {
	_, ok := m.clearedFields[erpshipmentdetail.FieldExportSaleID]
	return ok
}

// ResetExportSaleID resets all changes to the "export_sale_id" field.
func (m *ERPShipmentDetailMutation) ResetExportSaleID() {
	m.export_sale_id = nil
	m.addexport_sale_id = nil
	delete(m.clearedFields, erpshipmentdetail.FieldExportSaleID)
}

// SetSourceExportCode sets the "source_export_code" field.
func (m *ERPShipmentDetailMutation) SetSourceExportCode(s string) {
	m.source_export_code = &s
}

// SourceExportCode returns the value of the "source_export_code" field in the mutation.
func (m *ERPShipmentDetailMutation) SourceExportCode() (r string, exists bool) {
	v := m.source_export_code
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceExportCode returns the old "source_export_code" field's value of the ERPShipmentDetail entity.
// If the ERPShipmentDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailMutation) OldSourceExportCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceExportCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceExportCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceExportCode: %w", err)
	}
	return oldValue.SourceExportCode, nil
}

// ClearSourceExportCode clears the value of the "source_export_code" field.
func (m *ERPShipmentDetailMutation) ClearSourceExportCode() {
	m.source_export_code = nil
	m.clearedFields[erpshipmentdetail.FieldSourceExportCode] = struct{}{}
}

// SourceExportCodeCleared returns if the "source_export_code" field was cleared in this mutation.
func (m *ERPShipmentDetailMutation) SourceExportCodeCleared() bool {
	_, ok := m.clearedFields[erpshipmentdetail.FieldSourceExportCode]
	return ok
}

// ResetSourceExportCode resets all changes to the "source_export_code" field.
func (m *ERPShipmentDetailMutation) ResetSourceExportCode() {
	m.source_export_code = nil
	delete(m.clearedFields, erpshipmentdetail.FieldSourceExportCode)
}

// SetCustomerPartnerID sets the "customer_partner_id" field.
func (m *ERPShipmentDetailMutation) SetCustomerPartnerID(i int) {
	m.customer_partner_id = &i
	m.addcustomer_partner_id = nil
}

// CustomerPartnerID returns the value of the "customer_partner_id" field in the mutation.
func (m *ERPShipmentDetailMutation) CustomerPartnerID() (r int, exists bool) {
	v := m.customer_partner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerPartnerID returns the old "customer_partner_id" field's value of the ERPShipmentDetail entity.
// If the ERPShipmentDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailMutation) OldCustomerPartnerID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerPartnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerPartnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerPartnerID: %w", err)
	}
	return oldValue.CustomerPartnerID, nil
}

// AddCustomerPartnerID adds i to the "customer_partner_id" field.
func (m *ERPShipmentDetailMutation) AddCustomerPartnerID(i int) {
	if m.addcustomer_partner_id != nil {
		*m.addcustomer_partner_id += i
	} else {
		m.addcustomer_partner_id = &i
	}
}

// AddedCustomerPartnerID returns the value that was added to the "customer_partner_id" field in this mutation.
func (m *ERPShipmentDetailMutation) AddedCustomerPartnerID() (r int, exists bool) {
	v := m.addcustomer_partner_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCustomerPartnerID clears the value of the "customer_partner_id" field.
func (m *ERPShipmentDetailMutation) ClearCustomerPartnerID() {
	m.customer_partner_id = nil
	m.addcustomer_partner_id = nil
	m.clearedFields[erpshipmentdetail.FieldCustomerPartnerID] = struct{}{}
}

// CustomerPartnerIDCleared returns if the "customer_partner_id" field was cleared in this mutation.
func (m *ERPShipmentDetailMutation) CustomerPartnerIDCleared() bool {
	_, ok := m.clearedFields[erpshipmentdetail.FieldCustomerPartnerID]
	return ok
}

// ResetCustomerPartnerID resets all changes to the "customer_partner_id" field.
func (m *ERPShipmentDetailMutation) ResetCustomerPartnerID() {
	m.customer_partner_id = nil
	m.addcustomer_partner_id = nil
	delete(m.clearedFields, erpshipmentdetail.FieldCustomerPartnerID)
}

// SetCustomerCode sets the "customer_code" field.
func (m *ERPShipmentDetailMutation) SetCustomerCode(s string) {
	m.customer_code = &s
}

// CustomerCode returns the value of the "customer_code" field in the mutation.
func (m *ERPShipmentDetailMutation) CustomerCode() (r string, exists bool) {
	v := m.customer_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerCode returns the old "customer_code" field's value of the ERPShipmentDetail entity.
// If the ERPShipmentDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailMutation) OldCustomerCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerCode: %w", err)
	}
	return oldValue.CustomerCode, nil
}

// ClearCustomerCode clears the value of the "customer_code" field.
func (m *ERPShipmentDetailMutation) ClearCustomerCode() {
	m.customer_code = nil
	m.clearedFields[erpshipmentdetail.FieldCustomerCode] = struct{}{}
}

// CustomerCodeCleared returns if the "customer_code" field was cleared in this mutation.
func (m *ERPShipmentDetailMutation) CustomerCodeCleared() bool {
	_, ok := m.clearedFields[erpshipmentdetail.FieldCustomerCode]
	return ok
}

// ResetCustomerCode resets all changes to the "customer_code" field.
func (m *ERPShipmentDetailMutation) ResetCustomerCode() {
	m.customer_code = nil
	delete(m.clearedFields, erpshipmentdetail.FieldCustomerCode)
}

// SetStartPort sets the "start_port" field.
func (m *ERPShipmentDetailMutation) SetStartPort(s string) {
	m.start_port = &s
}

// StartPort returns the value of the "start_port" field in the mutation.
func (m *ERPShipmentDetailMutation) StartPort() (r string, exists bool) {
	v := m.start_port
	if v == nil {
		return
	}
	return *v, true
}

// OldStartPort returns the old "start_port" field's value of the ERPShipmentDetail entity.
// If the ERPShipmentDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailMutation) OldStartPort(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartPort: %w", err)
	}
	return oldValue.StartPort, nil
}

// ClearStartPort clears the value of the "start_port" field.
func (m *ERPShipmentDetailMutation) ClearStartPort() {
	m.start_port = nil
	m.clearedFields[erpshipmentdetail.FieldStartPort] = struct{}{}
}

// StartPortCleared returns if the "start_port" field was cleared in this mutation.
func (m *ERPShipmentDetailMutation) StartPortCleared() bool {
	_, ok := m.clearedFields[erpshipmentdetail.FieldStartPort]
	return ok
}

// ResetStartPort resets all changes to the "start_port" field.
func (m *ERPShipmentDetailMutation) ResetStartPort() {
	m.start_port = nil
	delete(m.clearedFields, erpshipmentdetail.FieldStartPort)
}

// SetDestPort sets the "dest_port" field.
func (m *ERPShipmentDetailMutation) SetDestPort(s string) {
	m.dest_port = &s
}

// DestPort returns the value of the "dest_port" field in the mutation.
func (m *ERPShipmentDetailMutation) DestPort() (r string, exists bool) {
	v := m.dest_port
	if v == nil {
		return
	}
	return *v, true
}

// OldDestPort returns the old "dest_port" field's value of the ERPShipmentDetail entity.
// If the ERPShipmentDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailMutation) OldDestPort(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDestPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDestPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestPort: %w", err)
	}
	return oldValue.DestPort, nil
}

// ClearDestPort clears the value of the "dest_port" field.
func (m *ERPShipmentDetailMutation) ClearDestPort() {
	m.dest_port = nil
	m.clearedFields[erpshipmentdetail.FieldDestPort] = struct{}{}
}

// DestPortCleared returns if the "dest_port" field was cleared in this mutation.
func (m *ERPShipmentDetailMutation) DestPortCleared() bool {
	_, ok := m.clearedFields[erpshipmentdetail.FieldDestPort]
	return ok
}

// ResetDestPort resets all changes to the "dest_port" field.
func (m *ERPShipmentDetailMutation) ResetDestPort() {
	m.dest_port = nil
	delete(m.clearedFields, erpshipmentdetail.FieldDestPort)
}

// SetShipToAddress sets the "ship_to_address" field.
func (m *ERPShipmentDetailMutation) SetShipToAddress(s string) {
	m.ship_to_address = &s
}

// ShipToAddress returns the value of the "ship_to_address" field in the mutation.
func (m *ERPShipmentDetailMutation) ShipToAddress() (r string, exists bool) {
	v := m.ship_to_address
	if v == nil {
		return
	}
	return *v, true
}

// OldShipToAddress returns the old "ship_to_address" field's value of the ERPShipmentDetail entity.
// If the ERPShipmentDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailMutation) OldShipToAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipToAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipToAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipToAddress: %w", err)
	}
	return oldValue.ShipToAddress, nil
}

// ClearShipToAddress clears the value of the "ship_to_address" field.
func (m *ERPShipmentDetailMutation) ClearShipToAddress() {
	m.ship_to_address = nil
	m.clearedFields[erpshipmentdetail.FieldShipToAddress] = struct{}{}
}

// ShipToAddressCleared returns if the "ship_to_address" field was cleared in this mutation.
func (m *ERPShipmentDetailMutation) ShipToAddressCleared() bool {
	_, ok := m.clearedFields[erpshipmentdetail.FieldShipToAddress]
	return ok
}

// ResetShipToAddress resets all changes to the "ship_to_address" field.
func (m *ERPShipmentDetailMutation) ResetShipToAddress() {
	m.ship_to_address = nil
	delete(m.clearedFields, erpshipmentdetail.FieldShipToAddress)
}

// SetArriveCountry sets the "arrive_country" field.
func (m *ERPShipmentDetailMutation) SetArriveCountry(s string) {
	m.arrive_country = &s
}

// ArriveCountry returns the value of the "arrive_country" field in the mutation.
func (m *ERPShipmentDetailMutation) ArriveCountry() (r string, exists bool) {
	v := m.arrive_country
	if v == nil {
		return
	}
	return *v, true
}

// OldArriveCountry returns the old "arrive_country" field's value of the ERPShipmentDetail entity.
// If the ERPShipmentDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailMutation) OldArriveCountry(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArriveCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArriveCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArriveCountry: %w", err)
	}
	return oldValue.ArriveCountry, nil
}

// ClearArriveCountry clears the value of the "arrive_country" field.
func (m *ERPShipmentDetailMutation) ClearArriveCountry() {
	m.arrive_country = nil
	m.clearedFields[erpshipmentdetail.FieldArriveCountry] = struct{}{}
}

// ArriveCountryCleared returns if the "arrive_country" field was cleared in this mutation.
func (m *ERPShipmentDetailMutation) ArriveCountryCleared() bool {
	_, ok := m.clearedFields[erpshipmentdetail.FieldArriveCountry]
	return ok
}

// ResetArriveCountry resets all changes to the "arrive_country" field.
func (m *ERPShipmentDetailMutation) ResetArriveCountry() {
	m.arrive_country = nil
	delete(m.clearedFields, erpshipmentdetail.FieldArriveCountry)
}

// SetTransportType sets the "transport_type" field.
func (m *ERPShipmentDetailMutation) SetTransportType(s string) {
	m.transport_type = &s
}

// TransportType returns the value of the "transport_type" field in the mutation.
func (m *ERPShipmentDetailMutation) TransportType() (r string, exists bool) {
	v := m.transport_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTransportType returns the old "transport_type" field's value of the ERPShipmentDetail entity.
// If the ERPShipmentDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailMutation) OldTransportType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransportType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransportType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransportType: %w", err)
	}
	return oldValue.TransportType, nil
}

// ClearTransportType clears the value of the "transport_type" field.
func (m *ERPShipmentDetailMutation) ClearTransportType() {
	m.transport_type = nil
	m.clearedFields[erpshipmentdetail.FieldTransportType] = struct{}{}
}

// TransportTypeCleared returns if the "transport_type" field was cleared in this mutation.
func (m *ERPShipmentDetailMutation) TransportTypeCleared() bool {
	_, ok := m.clearedFields[erpshipmentdetail.FieldTransportType]
	return ok
}

// ResetTransportType resets all changes to the "transport_type" field.
func (m *ERPShipmentDetailMutation) ResetTransportType() {
	m.transport_type = nil
	delete(m.clearedFields, erpshipmentdetail.FieldTransportType)
}

// SetSalesOwner sets the "sales_owner" field.
func (m *ERPShipmentDetailMutation) SetSalesOwner(s string) {
	m.sales_owner = &s
}

// SalesOwner returns the value of the "sales_owner" field in the mutation.
func (m *ERPShipmentDetailMutation) SalesOwner() (r string, exists bool) {
	v := m.sales_owner
	if v == nil {
		return
	}
	return *v, true
}

// OldSalesOwner returns the old "sales_owner" field's value of the ERPShipmentDetail entity.
// If the ERPShipmentDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailMutation) OldSalesOwner(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalesOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalesOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalesOwner: %w", err)
	}
	return oldValue.SalesOwner, nil
}

// ClearSalesOwner clears the value of the "sales_owner" field.
func (m *ERPShipmentDetailMutation) ClearSalesOwner() {
	m.sales_owner = nil
	m.clearedFields[erpshipmentdetail.FieldSalesOwner] = struct{}{}
}

// SalesOwnerCleared returns if the "sales_owner" field was cleared in this mutation.
func (m *ERPShipmentDetailMutation) SalesOwnerCleared() bool {
	_, ok := m.clearedFields[erpshipmentdetail.FieldSalesOwner]
	return ok
}

// ResetSalesOwner resets all changes to the "sales_owner" field.
func (m *ERPShipmentDetailMutation) ResetSalesOwner() {
	m.sales_owner = nil
	delete(m.clearedFields, erpshipmentdetail.FieldSalesOwner)
}

// SetWarehouseShipDate sets the "warehouse_ship_date" field.
func (m *ERPShipmentDetailMutation) SetWarehouseShipDate(t time.Time) {
	m.warehouse_ship_date = &t
}

// WarehouseShipDate returns the value of the "warehouse_ship_date" field in the mutation.
func (m *ERPShipmentDetailMutation) WarehouseShipDate() (r time.Time, exists bool) {
	v := m.warehouse_ship_date
	if v == nil {
		return
	}
	return *v, true
}

// OldWarehouseShipDate returns the old "warehouse_ship_date" field's value of the ERPShipmentDetail entity.
// If the ERPShipmentDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailMutation) OldWarehouseShipDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWarehouseShipDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWarehouseShipDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWarehouseShipDate: %w", err)
	}
	return oldValue.WarehouseShipDate, nil
}

// ResetWarehouseShipDate resets all changes to the "warehouse_ship_date" field.
func (m *ERPShipmentDetailMutation) ResetWarehouseShipDate() {
	m.warehouse_ship_date = nil
}

// SetTotalPackages sets the "total_packages" field.
func (m *ERPShipmentDetailMutation) SetTotalPackages(f float64) {
	m.total_packages = &f
	m.addtotal_packages = nil
}

// TotalPackages returns the value of the "total_packages" field in the mutation.
func (m *ERPShipmentDetailMutation) TotalPackages() (r float64, exists bool) {
	v := m.total_packages
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalPackages returns the old "total_packages" field's value of the ERPShipmentDetail entity.
// If the ERPShipmentDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailMutation) OldTotalPackages(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalPackages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalPackages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalPackages: %w", err)
	}
	return oldValue.TotalPackages, nil
}

// AddTotalPackages adds f to the "total_packages" field.
func (m *ERPShipmentDetailMutation) AddTotalPackages(f float64) {
	if m.addtotal_packages != nil {
		*m.addtotal_packages += f
	} else {
		m.addtotal_packages = &f
	}
}

// AddedTotalPackages returns the value that was added to the "total_packages" field in this mutation.
func (m *ERPShipmentDetailMutation) AddedTotalPackages() (r float64, exists bool) {
	v := m.addtotal_packages
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalPackages resets all changes to the "total_packages" field.
func (m *ERPShipmentDetailMutation) ResetTotalPackages() {
	m.total_packages = nil
	m.addtotal_packages = nil
}

// SetTotalAmount sets the "total_amount" field.
func (m *ERPShipmentDetailMutation) SetTotalAmount(f float64) {
	m.total_amount = &f
	m.addtotal_amount = nil
}

// TotalAmount returns the value of the "total_amount" field in the mutation.
func (m *ERPShipmentDetailMutation) TotalAmount() (r float64, exists bool) {
	v := m.total_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAmount returns the old "total_amount" field's value of the ERPShipmentDetail entity.
// If the ERPShipmentDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailMutation) OldTotalAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAmount: %w", err)
	}
	return oldValue.TotalAmount, nil
}

// AddTotalAmount adds f to the "total_amount" field.
func (m *ERPShipmentDetailMutation) AddTotalAmount(f float64) {
	if m.addtotal_amount != nil {
		*m.addtotal_amount += f
	} else {
		m.addtotal_amount = &f
	}
}

// AddedTotalAmount returns the value that was added to the "total_amount" field in this mutation.
func (m *ERPShipmentDetailMutation) AddedTotalAmount() (r float64, exists bool) {
	v := m.addtotal_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalAmount resets all changes to the "total_amount" field.
func (m *ERPShipmentDetailMutation) ResetTotalAmount() {
	m.total_amount = nil
	m.addtotal_amount = nil
}

// SetStatus sets the "status" field.
func (m *ERPShipmentDetailMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ERPShipmentDetailMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ERPShipmentDetail entity.
// If the ERPShipmentDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ERPShipmentDetailMutation) ResetStatus() {
	m.status = nil
}

// SetRemark sets the "remark" field.
func (m *ERPShipmentDetailMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ERPShipmentDetailMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the ERPShipmentDetail entity.
// If the ERPShipmentDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ERPShipmentDetailMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[erpshipmentdetail.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ERPShipmentDetailMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[erpshipmentdetail.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ERPShipmentDetailMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, erpshipmentdetail.FieldRemark)
}

// SetCreatedByAdminID sets the "created_by_admin_id" field.
func (m *ERPShipmentDetailMutation) SetCreatedByAdminID(i int) {
	m.created_by_admin_id = &i
	m.addcreated_by_admin_id = nil
}

// CreatedByAdminID returns the value of the "created_by_admin_id" field in the mutation.
func (m *ERPShipmentDetailMutation) CreatedByAdminID() (r int, exists bool) {
	v := m.created_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedByAdminID returns the old "created_by_admin_id" field's value of the ERPShipmentDetail entity.
// If the ERPShipmentDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailMutation) OldCreatedByAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedByAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedByAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedByAdminID: %w", err)
	}
	return oldValue.CreatedByAdminID, nil
}

// AddCreatedByAdminID adds i to the "created_by_admin_id" field.
func (m *ERPShipmentDetailMutation) AddCreatedByAdminID(i int) {
	if m.addcreated_by_admin_id != nil {
		*m.addcreated_by_admin_id += i
	} else {
		m.addcreated_by_admin_id = &i
	}
}

// AddedCreatedByAdminID returns the value that was added to the "created_by_admin_id" field in this mutation.
func (m *ERPShipmentDetailMutation) AddedCreatedByAdminID() (r int, exists bool) {
	v := m.addcreated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedByAdminID clears the value of the "created_by_admin_id" field.
func (m *ERPShipmentDetailMutation) ClearCreatedByAdminID() {
	m.created_by_admin_id = nil
	m.addcreated_by_admin_id = nil
	m.clearedFields[erpshipmentdetail.FieldCreatedByAdminID] = struct{}{}
}

// CreatedByAdminIDCleared returns if the "created_by_admin_id" field was cleared in this mutation.
func (m *ERPShipmentDetailMutation) CreatedByAdminIDCleared() bool {
	_, ok := m.clearedFields[erpshipmentdetail.FieldCreatedByAdminID]
	return ok
}

// ResetCreatedByAdminID resets all changes to the "created_by_admin_id" field.
func (m *ERPShipmentDetailMutation) ResetCreatedByAdminID() {
	m.created_by_admin_id = nil
	m.addcreated_by_admin_id = nil
	delete(m.clearedFields, erpshipmentdetail.FieldCreatedByAdminID)
}

// SetUpdatedByAdminID sets the "updated_by_admin_id" field.
func (m *ERPShipmentDetailMutation) SetUpdatedByAdminID(i int) {
	m.updated_by_admin_id = &i
	m.addupdated_by_admin_id = nil
}

// UpdatedByAdminID returns the value of the "updated_by_admin_id" field in the mutation.
func (m *ERPShipmentDetailMutation) UpdatedByAdminID() (r int, exists bool) {
	v := m.updated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedByAdminID returns the old "updated_by_admin_id" field's value of the ERPShipmentDetail entity.
// If the ERPShipmentDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailMutation) OldUpdatedByAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedByAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedByAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedByAdminID: %w", err)
	}
	return oldValue.UpdatedByAdminID, nil
}

// AddUpdatedByAdminID adds i to the "updated_by_admin_id" field.
func (m *ERPShipmentDetailMutation) AddUpdatedByAdminID(i int) {
	if m.addupdated_by_admin_id != nil {
		*m.addupdated_by_admin_id += i
	} else {
		m.addupdated_by_admin_id = &i
	}
}

// AddedUpdatedByAdminID returns the value that was added to the "updated_by_admin_id" field in this mutation.
func (m *ERPShipmentDetailMutation) AddedUpdatedByAdminID() (r int, exists bool) {
	v := m.addupdated_by_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedByAdminID clears the value of the "updated_by_admin_id" field.
func (m *ERPShipmentDetailMutation) ClearUpdatedByAdminID() {
	m.updated_by_admin_id = nil
	m.addupdated_by_admin_id = nil
	m.clearedFields[erpshipmentdetail.FieldUpdatedByAdminID] = struct{}{}
}

// UpdatedByAdminIDCleared returns if the "updated_by_admin_id" field was cleared in this mutation.
func (m *ERPShipmentDetailMutation) UpdatedByAdminIDCleared() bool {
	_, ok := m.clearedFields[erpshipmentdetail.FieldUpdatedByAdminID]
	return ok
}

// ResetUpdatedByAdminID resets all changes to the "updated_by_admin_id" field.
func (m *ERPShipmentDetailMutation) ResetUpdatedByAdminID() {
	m.updated_by_admin_id = nil
	m.addupdated_by_admin_id = nil
	delete(m.clearedFields, erpshipmentdetail.FieldUpdatedByAdminID)
}

// SetCreatedAt sets the "created_at" field.
func (m *ERPShipmentDetailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ERPShipmentDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ERPShipmentDetail entity.
// If the ERPShipmentDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ERPShipmentDetailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ERPShipmentDetailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ERPShipmentDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ERPShipmentDetail entity.
// If the ERPShipmentDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ERPShipmentDetailMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ERPShipmentDetailMutation builder.
func (m *ERPShipmentDetailMutation) Where(ps ...predicate.ERPShipmentDetail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ERPShipmentDetailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ERPShipmentDetailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ERPShipmentDetail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ERPShipmentDetailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ERPShipmentDetailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ERPShipmentDetail).
func (m *ERPShipmentDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ERPShipmentDetailMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.code != nil {
		fields = append(fields, erpshipmentdetail.FieldCode)
	}
	if m.export_sale_id != nil {
		fields = append(fields, erpshipmentdetail.FieldExportSaleID)
	}
	if m.source_export_code != nil {
		fields = append(fields, erpshipmentdetail.FieldSourceExportCode)
	}
	if m.customer_partner_id != nil {
		fields = append(fields, erpshipmentdetail.FieldCustomerPartnerID)
	}
	if m.customer_code != nil {
		fields = append(fields, erpshipmentdetail.FieldCustomerCode)
	}
	if m.start_port != nil {
		fields = append(fields, erpshipmentdetail.FieldStartPort)
	}
	if m.dest_port != nil {
		fields = append(fields, erpshipmentdetail.FieldDestPort)
	}
	if m.ship_to_address != nil {
		fields = append(fields, erpshipmentdetail.FieldShipToAddress)
	}
	if m.arrive_country != nil {
		fields = append(fields, erpshipmentdetail.FieldArriveCountry)
	}
	if m.transport_type != nil {
		fields = append(fields, erpshipmentdetail.FieldTransportType)
	}
	if m.sales_owner != nil {
		fields = append(fields, erpshipmentdetail.FieldSalesOwner)
	}
	if m.warehouse_ship_date != nil {
		fields = append(fields, erpshipmentdetail.FieldWarehouseShipDate)
	}
	if m.total_packages != nil {
		fields = append(fields, erpshipmentdetail.FieldTotalPackages)
	}
	if m.total_amount != nil {
		fields = append(fields, erpshipmentdetail.FieldTotalAmount)
	}
	if m.status != nil {
		fields = append(fields, erpshipmentdetail.FieldStatus)
	}
	if m.remark != nil {
		fields = append(fields, erpshipmentdetail.FieldRemark)
	}
	if m.created_by_admin_id != nil {
		fields = append(fields, erpshipmentdetail.FieldCreatedByAdminID)
	}
	if m.updated_by_admin_id != nil {
		fields = append(fields, erpshipmentdetail.FieldUpdatedByAdminID)
	}
	if m.created_at != nil {
		fields = append(fields, erpshipmentdetail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, erpshipmentdetail.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ERPShipmentDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case erpshipmentdetail.FieldCode:
		return m.Code()
	case erpshipmentdetail.FieldExportSaleID:
		return m.ExportSaleID()
	case erpshipmentdetail.FieldSourceExportCode:
		return m.SourceExportCode()
	case erpshipmentdetail.FieldCustomerPartnerID:
		return m.CustomerPartnerID()
	case erpshipmentdetail.FieldCustomerCode:
		return m.CustomerCode()
	case erpshipmentdetail.FieldStartPort:
		return m.StartPort()
	case erpshipmentdetail.FieldDestPort:
		return m.DestPort()
	case erpshipmentdetail.FieldShipToAddress:
		return m.ShipToAddress()
	case erpshipmentdetail.FieldArriveCountry:
		return m.ArriveCountry()
	case erpshipmentdetail.FieldTransportType:
		return m.TransportType()
	case erpshipmentdetail.FieldSalesOwner:
		return m.SalesOwner()
	case erpshipmentdetail.FieldWarehouseShipDate:
		return m.WarehouseShipDate()
	case erpshipmentdetail.FieldTotalPackages:
		return m.TotalPackages()
	case erpshipmentdetail.FieldTotalAmount:
		return m.TotalAmount()
	case erpshipmentdetail.FieldStatus:
		return m.Status()
	case erpshipmentdetail.FieldRemark:
		return m.Remark()
	case erpshipmentdetail.FieldCreatedByAdminID:
		return m.CreatedByAdminID()
	case erpshipmentdetail.FieldUpdatedByAdminID:
		return m.UpdatedByAdminID()
	case erpshipmentdetail.FieldCreatedAt:
		return m.CreatedAt()
	case erpshipmentdetail.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ERPShipmentDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case erpshipmentdetail.FieldCode:
		return m.OldCode(ctx)
	case erpshipmentdetail.FieldExportSaleID:
		return m.OldExportSaleID(ctx)
	case erpshipmentdetail.FieldSourceExportCode:
		return m.OldSourceExportCode(ctx)
	case erpshipmentdetail.FieldCustomerPartnerID:
		return m.OldCustomerPartnerID(ctx)
	case erpshipmentdetail.FieldCustomerCode:
		return m.OldCustomerCode(ctx)
	case erpshipmentdetail.FieldStartPort:
		return m.OldStartPort(ctx)
	case erpshipmentdetail.FieldDestPort:
		return m.OldDestPort(ctx)
	case erpshipmentdetail.FieldShipToAddress:
		return m.OldShipToAddress(ctx)
	case erpshipmentdetail.FieldArriveCountry:
		return m.OldArriveCountry(ctx)
	case erpshipmentdetail.FieldTransportType:
		return m.OldTransportType(ctx)
	case erpshipmentdetail.FieldSalesOwner:
		return m.OldSalesOwner(ctx)
	case erpshipmentdetail.FieldWarehouseShipDate:
		return m.OldWarehouseShipDate(ctx)
	case erpshipmentdetail.FieldTotalPackages:
		return m.OldTotalPackages(ctx)
	case erpshipmentdetail.FieldTotalAmount:
		return m.OldTotalAmount(ctx)
	case erpshipmentdetail.FieldStatus:
		return m.OldStatus(ctx)
	case erpshipmentdetail.FieldRemark:
		return m.OldRemark(ctx)
	case erpshipmentdetail.FieldCreatedByAdminID:
		return m.OldCreatedByAdminID(ctx)
	case erpshipmentdetail.FieldUpdatedByAdminID:
		return m.OldUpdatedByAdminID(ctx)
	case erpshipmentdetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case erpshipmentdetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ERPShipmentDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPShipmentDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case erpshipmentdetail.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case erpshipmentdetail.FieldExportSaleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExportSaleID(v)
		return nil
	case erpshipmentdetail.FieldSourceExportCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceExportCode(v)
		return nil
	case erpshipmentdetail.FieldCustomerPartnerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerPartnerID(v)
		return nil
	case erpshipmentdetail.FieldCustomerCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerCode(v)
		return nil
	case erpshipmentdetail.FieldStartPort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartPort(v)
		return nil
	case erpshipmentdetail.FieldDestPort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestPort(v)
		return nil
	case erpshipmentdetail.FieldShipToAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipToAddress(v)
		return nil
	case erpshipmentdetail.FieldArriveCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArriveCountry(v)
		return nil
	case erpshipmentdetail.FieldTransportType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransportType(v)
		return nil
	case erpshipmentdetail.FieldSalesOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalesOwner(v)
		return nil
	case erpshipmentdetail.FieldWarehouseShipDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWarehouseShipDate(v)
		return nil
	case erpshipmentdetail.FieldTotalPackages:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalPackages(v)
		return nil
	case erpshipmentdetail.FieldTotalAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAmount(v)
		return nil
	case erpshipmentdetail.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case erpshipmentdetail.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case erpshipmentdetail.FieldCreatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedByAdminID(v)
		return nil
	case erpshipmentdetail.FieldUpdatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedByAdminID(v)
		return nil
	case erpshipmentdetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case erpshipmentdetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ERPShipmentDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ERPShipmentDetailMutation) AddedFields() []string {
	var fields []string
	if m.addexport_sale_id != nil {
		fields = append(fields, erpshipmentdetail.FieldExportSaleID)
	}
	if m.addcustomer_partner_id != nil {
		fields = append(fields, erpshipmentdetail.FieldCustomerPartnerID)
	}
	if m.addtotal_packages != nil {
		fields = append(fields, erpshipmentdetail.FieldTotalPackages)
	}
	if m.addtotal_amount != nil {
		fields = append(fields, erpshipmentdetail.FieldTotalAmount)
	}
	if m.addcreated_by_admin_id != nil {
		fields = append(fields, erpshipmentdetail.FieldCreatedByAdminID)
	}
	if m.addupdated_by_admin_id != nil {
		fields = append(fields, erpshipmentdetail.FieldUpdatedByAdminID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ERPShipmentDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case erpshipmentdetail.FieldExportSaleID:
		return m.AddedExportSaleID()
	case erpshipmentdetail.FieldCustomerPartnerID:
		return m.AddedCustomerPartnerID()
	case erpshipmentdetail.FieldTotalPackages:
		return m.AddedTotalPackages()
	case erpshipmentdetail.FieldTotalAmount:
		return m.AddedTotalAmount()
	case erpshipmentdetail.FieldCreatedByAdminID:
		return m.AddedCreatedByAdminID()
	case erpshipmentdetail.FieldUpdatedByAdminID:
		return m.AddedUpdatedByAdminID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPShipmentDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case erpshipmentdetail.FieldExportSaleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExportSaleID(v)
		return nil
	case erpshipmentdetail.FieldCustomerPartnerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCustomerPartnerID(v)
		return nil
	case erpshipmentdetail.FieldTotalPackages:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalPackages(v)
		return nil
	case erpshipmentdetail.FieldTotalAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalAmount(v)
		return nil
	case erpshipmentdetail.FieldCreatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedByAdminID(v)
		return nil
	case erpshipmentdetail.FieldUpdatedByAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedByAdminID(v)
		return nil
	}
	return fmt.Errorf("unknown ERPShipmentDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ERPShipmentDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(erpshipmentdetail.FieldExportSaleID) {
		fields = append(fields, erpshipmentdetail.FieldExportSaleID)
	}
	if m.FieldCleared(erpshipmentdetail.FieldSourceExportCode) {
		fields = append(fields, erpshipmentdetail.FieldSourceExportCode)
	}
	if m.FieldCleared(erpshipmentdetail.FieldCustomerPartnerID) {
		fields = append(fields, erpshipmentdetail.FieldCustomerPartnerID)
	}
	if m.FieldCleared(erpshipmentdetail.FieldCustomerCode) {
		fields = append(fields, erpshipmentdetail.FieldCustomerCode)
	}
	if m.FieldCleared(erpshipmentdetail.FieldStartPort) {
		fields = append(fields, erpshipmentdetail.FieldStartPort)
	}
	if m.FieldCleared(erpshipmentdetail.FieldDestPort) {
		fields = append(fields, erpshipmentdetail.FieldDestPort)
	}
	if m.FieldCleared(erpshipmentdetail.FieldShipToAddress) {
		fields = append(fields, erpshipmentdetail.FieldShipToAddress)
	}
	if m.FieldCleared(erpshipmentdetail.FieldArriveCountry) {
		fields = append(fields, erpshipmentdetail.FieldArriveCountry)
	}
	if m.FieldCleared(erpshipmentdetail.FieldTransportType) {
		fields = append(fields, erpshipmentdetail.FieldTransportType)
	}
	if m.FieldCleared(erpshipmentdetail.FieldSalesOwner) {
		fields = append(fields, erpshipmentdetail.FieldSalesOwner)
	}
	if m.FieldCleared(erpshipmentdetail.FieldRemark) {
		fields = append(fields, erpshipmentdetail.FieldRemark)
	}
	if m.FieldCleared(erpshipmentdetail.FieldCreatedByAdminID) {
		fields = append(fields, erpshipmentdetail.FieldCreatedByAdminID)
	}
	if m.FieldCleared(erpshipmentdetail.FieldUpdatedByAdminID) {
		fields = append(fields, erpshipmentdetail.FieldUpdatedByAdminID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ERPShipmentDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ERPShipmentDetailMutation) ClearField(name string) error {
	switch name {
	case erpshipmentdetail.FieldExportSaleID:
		m.ClearExportSaleID()
		return nil
	case erpshipmentdetail.FieldSourceExportCode:
		m.ClearSourceExportCode()
		return nil
	case erpshipmentdetail.FieldCustomerPartnerID:
		m.ClearCustomerPartnerID()
		return nil
	case erpshipmentdetail.FieldCustomerCode:
		m.ClearCustomerCode()
		return nil
	case erpshipmentdetail.FieldStartPort:
		m.ClearStartPort()
		return nil
	case erpshipmentdetail.FieldDestPort:
		m.ClearDestPort()
		return nil
	case erpshipmentdetail.FieldShipToAddress:
		m.ClearShipToAddress()
		return nil
	case erpshipmentdetail.FieldArriveCountry:
		m.ClearArriveCountry()
		return nil
	case erpshipmentdetail.FieldTransportType:
		m.ClearTransportType()
		return nil
	case erpshipmentdetail.FieldSalesOwner:
		m.ClearSalesOwner()
		return nil
	case erpshipmentdetail.FieldRemark:
		m.ClearRemark()
		return nil
	case erpshipmentdetail.FieldCreatedByAdminID:
		m.ClearCreatedByAdminID()
		return nil
	case erpshipmentdetail.FieldUpdatedByAdminID:
		m.ClearUpdatedByAdminID()
		return nil
	}
	return fmt.Errorf("unknown ERPShipmentDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ERPShipmentDetailMutation) ResetField(name string) error {
	switch name {
	case erpshipmentdetail.FieldCode:
		m.ResetCode()
		return nil
	case erpshipmentdetail.FieldExportSaleID:
		m.ResetExportSaleID()
		return nil
	case erpshipmentdetail.FieldSourceExportCode:
		m.ResetSourceExportCode()
		return nil
	case erpshipmentdetail.FieldCustomerPartnerID:
		m.ResetCustomerPartnerID()
		return nil
	case erpshipmentdetail.FieldCustomerCode:
		m.ResetCustomerCode()
		return nil
	case erpshipmentdetail.FieldStartPort:
		m.ResetStartPort()
		return nil
	case erpshipmentdetail.FieldDestPort:
		m.ResetDestPort()
		return nil
	case erpshipmentdetail.FieldShipToAddress:
		m.ResetShipToAddress()
		return nil
	case erpshipmentdetail.FieldArriveCountry:
		m.ResetArriveCountry()
		return nil
	case erpshipmentdetail.FieldTransportType:
		m.ResetTransportType()
		return nil
	case erpshipmentdetail.FieldSalesOwner:
		m.ResetSalesOwner()
		return nil
	case erpshipmentdetail.FieldWarehouseShipDate:
		m.ResetWarehouseShipDate()
		return nil
	case erpshipmentdetail.FieldTotalPackages:
		m.ResetTotalPackages()
		return nil
	case erpshipmentdetail.FieldTotalAmount:
		m.ResetTotalAmount()
		return nil
	case erpshipmentdetail.FieldStatus:
		m.ResetStatus()
		return nil
	case erpshipmentdetail.FieldRemark:
		m.ResetRemark()
		return nil
	case erpshipmentdetail.FieldCreatedByAdminID:
		m.ResetCreatedByAdminID()
		return nil
	case erpshipmentdetail.FieldUpdatedByAdminID:
		m.ResetUpdatedByAdminID()
		return nil
	case erpshipmentdetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case erpshipmentdetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPShipmentDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ERPShipmentDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ERPShipmentDetailMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ERPShipmentDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ERPShipmentDetailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ERPShipmentDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ERPShipmentDetailMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ERPShipmentDetailMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ERPShipmentDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ERPShipmentDetailMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ERPShipmentDetail edge %s", name)
}

// ERPShipmentDetailItemMutation represents an operation that mutates the ERPShipmentDetailItem nodes in the graph.
type ERPShipmentDetailItemMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	shipment_detail_id    *int
	addshipment_detail_id *int
	line_no               *int
	addline_no            *int
	product_id            *int
	addproduct_id         *int
	product_code          *string
	product_model         *string
	pack_detail           *string
	quantity              *float64
	addquantity           *float64
	unit_price            *float64
	addunit_price         *float64
	total_price           *float64
	addtotal_price        *float64
	net_weight            *float64
	addnet_weight         *float64
	gross_weight          *float64
	addgross_weight       *float64
	volume                *float64
	addvolume             *float64
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*ERPShipmentDetailItem, error)
	predicates            []predicate.ERPShipmentDetailItem
}

var _ ent.Mutation = (*ERPShipmentDetailItemMutation)(nil)

// erpshipmentdetailitemOption allows management of the mutation configuration using functional options.
type erpshipmentdetailitemOption func(*ERPShipmentDetailItemMutation)

// newERPShipmentDetailItemMutation creates new mutation for the ERPShipmentDetailItem entity.
func newERPShipmentDetailItemMutation(c config, op Op, opts ...erpshipmentdetailitemOption) *ERPShipmentDetailItemMutation {
	m := &ERPShipmentDetailItemMutation{
		config:        c,
		op:            op,
		typ:           TypeERPShipmentDetailItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withERPShipmentDetailItemID sets the ID field of the mutation.
func withERPShipmentDetailItemID(id int) erpshipmentdetailitemOption {
	return func(m *ERPShipmentDetailItemMutation) {
		var (
			err   error
			once  sync.Once
			value *ERPShipmentDetailItem
		)
		m.oldValue = func(ctx context.Context) (*ERPShipmentDetailItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ERPShipmentDetailItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withERPShipmentDetailItem sets the old ERPShipmentDetailItem of the mutation.
func withERPShipmentDetailItem(node *ERPShipmentDetailItem) erpshipmentdetailitemOption {
	return func(m *ERPShipmentDetailItemMutation) {
		m.oldValue = func(context.Context) (*ERPShipmentDetailItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ERPShipmentDetailItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ERPShipmentDetailItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ERPShipmentDetailItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ERPShipmentDetailItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ERPShipmentDetailItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetShipmentDetailID sets the "shipment_detail_id" field.
func (m *ERPShipmentDetailItemMutation) SetShipmentDetailID(i int) {
	m.shipment_detail_id = &i
	m.addshipment_detail_id = nil
}

// ShipmentDetailID returns the value of the "shipment_detail_id" field in the mutation.
func (m *ERPShipmentDetailItemMutation) ShipmentDetailID() (r int, exists bool) {
	v := m.shipment_detail_id
	if v == nil {
		return
	}
	return *v, true
}

// OldShipmentDetailID returns the old "shipment_detail_id" field's value of the ERPShipmentDetailItem entity.
// If the ERPShipmentDetailItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailItemMutation) OldShipmentDetailID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipmentDetailID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipmentDetailID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipmentDetailID: %w", err)
	}
	return oldValue.ShipmentDetailID, nil
}

// AddShipmentDetailID adds i to the "shipment_detail_id" field.
func (m *ERPShipmentDetailItemMutation) AddShipmentDetailID(i int) {
	if m.addshipment_detail_id != nil {
		*m.addshipment_detail_id += i
	} else {
		m.addshipment_detail_id = &i
	}
}

// AddedShipmentDetailID returns the value that was added to the "shipment_detail_id" field in this mutation.
func (m *ERPShipmentDetailItemMutation) AddedShipmentDetailID() (r int, exists bool) {
	v := m.addshipment_detail_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetShipmentDetailID resets all changes to the "shipment_detail_id" field.
func (m *ERPShipmentDetailItemMutation) ResetShipmentDetailID() {
	m.shipment_detail_id = nil
	m.addshipment_detail_id = nil
}

// SetLineNo sets the "line_no" field.
func (m *ERPShipmentDetailItemMutation) SetLineNo(i int) {
	m.line_no = &i
	m.addline_no = nil
}

// LineNo returns the value of the "line_no" field in the mutation.
func (m *ERPShipmentDetailItemMutation) LineNo() (r int, exists bool) {
	v := m.line_no
	if v == nil {
		return
	}
	return *v, true
}

// OldLineNo returns the old "line_no" field's value of the ERPShipmentDetailItem entity.
// If the ERPShipmentDetailItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailItemMutation) OldLineNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLineNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLineNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLineNo: %w", err)
	}
	return oldValue.LineNo, nil
}

// AddLineNo adds i to the "line_no" field.
func (m *ERPShipmentDetailItemMutation) AddLineNo(i int) {
	if m.addline_no != nil {
		*m.addline_no += i
	} else {
		m.addline_no = &i
	}
}

// AddedLineNo returns the value that was added to the "line_no" field in this mutation.
func (m *ERPShipmentDetailItemMutation) AddedLineNo() (r int, exists bool) {
	v := m.addline_no
	if v == nil {
		return
	}
	return *v, true
}

// ResetLineNo resets all changes to the "line_no" field.
func (m *ERPShipmentDetailItemMutation) ResetLineNo() {
	m.line_no = nil
	m.addline_no = nil
}

// SetProductID sets the "product_id" field.
func (m *ERPShipmentDetailItemMutation) SetProductID(i int) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ERPShipmentDetailItemMutation) ProductID() (r int, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the ERPShipmentDetailItem entity.
// If the ERPShipmentDetailItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailItemMutation) OldProductID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *ERPShipmentDetailItemMutation) AddProductID(i int) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *ERPShipmentDetailItemMutation) AddedProductID() (r int, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductID clears the value of the "product_id" field.
func (m *ERPShipmentDetailItemMutation) ClearProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	m.clearedFields[erpshipmentdetailitem.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *ERPShipmentDetailItemMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[erpshipmentdetailitem.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ERPShipmentDetailItemMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	delete(m.clearedFields, erpshipmentdetailitem.FieldProductID)
}

// SetProductCode sets the "product_code" field.
func (m *ERPShipmentDetailItemMutation) SetProductCode(s string) {
	m.product_code = &s
}

// ProductCode returns the value of the "product_code" field in the mutation.
func (m *ERPShipmentDetailItemMutation) ProductCode() (r string, exists bool) {
	v := m.product_code
	if v == nil {
		return
	}
	return *v, true
}

// OldProductCode returns the old "product_code" field's value of the ERPShipmentDetailItem entity.
// If the ERPShipmentDetailItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailItemMutation) OldProductCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductCode: %w", err)
	}
	return oldValue.ProductCode, nil
}

// ClearProductCode clears the value of the "product_code" field.
func (m *ERPShipmentDetailItemMutation) ClearProductCode() {
	m.product_code = nil
	m.clearedFields[erpshipmentdetailitem.FieldProductCode] = struct{}{}
}

// ProductCodeCleared returns if the "product_code" field was cleared in this mutation.
func (m *ERPShipmentDetailItemMutation) ProductCodeCleared() bool {
	_, ok := m.clearedFields[erpshipmentdetailitem.FieldProductCode]
	return ok
}

// ResetProductCode resets all changes to the "product_code" field.
func (m *ERPShipmentDetailItemMutation) ResetProductCode() {
	m.product_code = nil
	delete(m.clearedFields, erpshipmentdetailitem.FieldProductCode)
}

// SetProductModel sets the "product_model" field.
func (m *ERPShipmentDetailItemMutation) SetProductModel(s string) {
	m.product_model = &s
}

// ProductModel returns the value of the "product_model" field in the mutation.
func (m *ERPShipmentDetailItemMutation) ProductModel() (r string, exists bool) {
	v := m.product_model
	if v == nil {
		return
	}
	return *v, true
}

// OldProductModel returns the old "product_model" field's value of the ERPShipmentDetailItem entity.
// If the ERPShipmentDetailItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailItemMutation) OldProductModel(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductModel: %w", err)
	}
	return oldValue.ProductModel, nil
}

// ClearProductModel clears the value of the "product_model" field.
func (m *ERPShipmentDetailItemMutation) ClearProductModel() {
	m.product_model = nil
	m.clearedFields[erpshipmentdetailitem.FieldProductModel] = struct{}{}
}

// ProductModelCleared returns if the "product_model" field was cleared in this mutation.
func (m *ERPShipmentDetailItemMutation) ProductModelCleared() bool {
	_, ok := m.clearedFields[erpshipmentdetailitem.FieldProductModel]
	return ok
}

// ResetProductModel resets all changes to the "product_model" field.
func (m *ERPShipmentDetailItemMutation) ResetProductModel() {
	m.product_model = nil
	delete(m.clearedFields, erpshipmentdetailitem.FieldProductModel)
}

// SetPackDetail sets the "pack_detail" field.
func (m *ERPShipmentDetailItemMutation) SetPackDetail(s string) {
	m.pack_detail = &s
}

// PackDetail returns the value of the "pack_detail" field in the mutation.
func (m *ERPShipmentDetailItemMutation) PackDetail() (r string, exists bool) {
	v := m.pack_detail
	if v == nil {
		return
	}
	return *v, true
}

// OldPackDetail returns the old "pack_detail" field's value of the ERPShipmentDetailItem entity.
// If the ERPShipmentDetailItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailItemMutation) OldPackDetail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackDetail: %w", err)
	}
	return oldValue.PackDetail, nil
}

// ClearPackDetail clears the value of the "pack_detail" field.
func (m *ERPShipmentDetailItemMutation) ClearPackDetail() {
	m.pack_detail = nil
	m.clearedFields[erpshipmentdetailitem.FieldPackDetail] = struct{}{}
}

// PackDetailCleared returns if the "pack_detail" field was cleared in this mutation.
func (m *ERPShipmentDetailItemMutation) PackDetailCleared() bool {
	_, ok := m.clearedFields[erpshipmentdetailitem.FieldPackDetail]
	return ok
}

// ResetPackDetail resets all changes to the "pack_detail" field.
func (m *ERPShipmentDetailItemMutation) ResetPackDetail() {
	m.pack_detail = nil
	delete(m.clearedFields, erpshipmentdetailitem.FieldPackDetail)
}

// SetQuantity sets the "quantity" field.
func (m *ERPShipmentDetailItemMutation) SetQuantity(f float64) {
	m.quantity = &f
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *ERPShipmentDetailItemMutation) Quantity() (r float64, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the ERPShipmentDetailItem entity.
// If the ERPShipmentDetailItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailItemMutation) OldQuantity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds f to the "quantity" field.
func (m *ERPShipmentDetailItemMutation) AddQuantity(f float64) {
	if m.addquantity != nil {
		*m.addquantity += f
	} else {
		m.addquantity = &f
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *ERPShipmentDetailItemMutation) AddedQuantity() (r float64, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *ERPShipmentDetailItemMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetUnitPrice sets the "unit_price" field.
func (m *ERPShipmentDetailItemMutation) SetUnitPrice(f float64) {
	m.unit_price = &f
	m.addunit_price = nil
}

// UnitPrice returns the value of the "unit_price" field in the mutation.
func (m *ERPShipmentDetailItemMutation) UnitPrice() (r float64, exists bool) {
	v := m.unit_price
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitPrice returns the old "unit_price" field's value of the ERPShipmentDetailItem entity.
// If the ERPShipmentDetailItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailItemMutation) OldUnitPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitPrice: %w", err)
	}
	return oldValue.UnitPrice, nil
}

// AddUnitPrice adds f to the "unit_price" field.
func (m *ERPShipmentDetailItemMutation) AddUnitPrice(f float64) {
	if m.addunit_price != nil {
		*m.addunit_price += f
	} else {
		m.addunit_price = &f
	}
}

// AddedUnitPrice returns the value that was added to the "unit_price" field in this mutation.
func (m *ERPShipmentDetailItemMutation) AddedUnitPrice() (r float64, exists bool) {
	v := m.addunit_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnitPrice resets all changes to the "unit_price" field.
func (m *ERPShipmentDetailItemMutation) ResetUnitPrice() {
	m.unit_price = nil
	m.addunit_price = nil
}

// SetTotalPrice sets the "total_price" field.
func (m *ERPShipmentDetailItemMutation) SetTotalPrice(f float64) {
	m.total_price = &f
	m.addtotal_price = nil
}

// TotalPrice returns the value of the "total_price" field in the mutation.
func (m *ERPShipmentDetailItemMutation) TotalPrice() (r float64, exists bool) {
	v := m.total_price
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalPrice returns the old "total_price" field's value of the ERPShipmentDetailItem entity.
// If the ERPShipmentDetailItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailItemMutation) OldTotalPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalPrice: %w", err)
	}
	return oldValue.TotalPrice, nil
}

// AddTotalPrice adds f to the "total_price" field.
func (m *ERPShipmentDetailItemMutation) AddTotalPrice(f float64) {
	if m.addtotal_price != nil {
		*m.addtotal_price += f
	} else {
		m.addtotal_price = &f
	}
}

// AddedTotalPrice returns the value that was added to the "total_price" field in this mutation.
func (m *ERPShipmentDetailItemMutation) AddedTotalPrice() (r float64, exists bool) {
	v := m.addtotal_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalPrice resets all changes to the "total_price" field.
func (m *ERPShipmentDetailItemMutation) ResetTotalPrice() {
	m.total_price = nil
	m.addtotal_price = nil
}

// SetNetWeight sets the "net_weight" field.
func (m *ERPShipmentDetailItemMutation) SetNetWeight(f float64) {
	m.net_weight = &f
	m.addnet_weight = nil
}

// NetWeight returns the value of the "net_weight" field in the mutation.
func (m *ERPShipmentDetailItemMutation) NetWeight() (r float64, exists bool) {
	v := m.net_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldNetWeight returns the old "net_weight" field's value of the ERPShipmentDetailItem entity.
// If the ERPShipmentDetailItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailItemMutation) OldNetWeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNetWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNetWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetWeight: %w", err)
	}
	return oldValue.NetWeight, nil
}

// AddNetWeight adds f to the "net_weight" field.
func (m *ERPShipmentDetailItemMutation) AddNetWeight(f float64) {
	if m.addnet_weight != nil {
		*m.addnet_weight += f
	} else {
		m.addnet_weight = &f
	}
}

// AddedNetWeight returns the value that was added to the "net_weight" field in this mutation.
func (m *ERPShipmentDetailItemMutation) AddedNetWeight() (r float64, exists bool) {
	v := m.addnet_weight
	if v == nil {
		return
	}
	return *v, true
}

// ResetNetWeight resets all changes to the "net_weight" field.
func (m *ERPShipmentDetailItemMutation) ResetNetWeight() {
	m.net_weight = nil
	m.addnet_weight = nil
}

// SetGrossWeight sets the "gross_weight" field.
func (m *ERPShipmentDetailItemMutation) SetGrossWeight(f float64) {
	m.gross_weight = &f
	m.addgross_weight = nil
}

// GrossWeight returns the value of the "gross_weight" field in the mutation.
func (m *ERPShipmentDetailItemMutation) GrossWeight() (r float64, exists bool) {
	v := m.gross_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldGrossWeight returns the old "gross_weight" field's value of the ERPShipmentDetailItem entity.
// If the ERPShipmentDetailItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailItemMutation) OldGrossWeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrossWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrossWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrossWeight: %w", err)
	}
	return oldValue.GrossWeight, nil
}

// AddGrossWeight adds f to the "gross_weight" field.
func (m *ERPShipmentDetailItemMutation) AddGrossWeight(f float64) {
	if m.addgross_weight != nil {
		*m.addgross_weight += f
	} else {
		m.addgross_weight = &f
	}
}

// AddedGrossWeight returns the value that was added to the "gross_weight" field in this mutation.
func (m *ERPShipmentDetailItemMutation) AddedGrossWeight() (r float64, exists bool) {
	v := m.addgross_weight
	if v == nil {
		return
	}
	return *v, true
}

// ResetGrossWeight resets all changes to the "gross_weight" field.
func (m *ERPShipmentDetailItemMutation) ResetGrossWeight() {
	m.gross_weight = nil
	m.addgross_weight = nil
}

// SetVolume sets the "volume" field.
func (m *ERPShipmentDetailItemMutation) SetVolume(f float64) {
	m.volume = &f
	m.addvolume = nil
}

// Volume returns the value of the "volume" field in the mutation.
func (m *ERPShipmentDetailItemMutation) Volume() (r float64, exists bool) {
	v := m.volume
	if v == nil {
		return
	}
	return *v, true
}

// OldVolume returns the old "volume" field's value of the ERPShipmentDetailItem entity.
// If the ERPShipmentDetailItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailItemMutation) OldVolume(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVolume is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVolume requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVolume: %w", err)
	}
	return oldValue.Volume, nil
}

// AddVolume adds f to the "volume" field.
func (m *ERPShipmentDetailItemMutation) AddVolume(f float64) {
	if m.addvolume != nil {
		*m.addvolume += f
	} else {
		m.addvolume = &f
	}
}

// AddedVolume returns the value that was added to the "volume" field in this mutation.
func (m *ERPShipmentDetailItemMutation) AddedVolume() (r float64, exists bool) {
	v := m.addvolume
	if v == nil {
		return
	}
	return *v, true
}

// ResetVolume resets all changes to the "volume" field.
func (m *ERPShipmentDetailItemMutation) ResetVolume() {
	m.volume = nil
	m.addvolume = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ERPShipmentDetailItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ERPShipmentDetailItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ERPShipmentDetailItem entity.
// If the ERPShipmentDetailItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ERPShipmentDetailItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ERPShipmentDetailItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ERPShipmentDetailItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ERPShipmentDetailItem entity.
// If the ERPShipmentDetailItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPShipmentDetailItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ERPShipmentDetailItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ERPShipmentDetailItemMutation builder.
func (m *ERPShipmentDetailItemMutation) Where(ps ...predicate.ERPShipmentDetailItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ERPShipmentDetailItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ERPShipmentDetailItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ERPShipmentDetailItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ERPShipmentDetailItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ERPShipmentDetailItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ERPShipmentDetailItem).
func (m *ERPShipmentDetailItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ERPShipmentDetailItemMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.shipment_detail_id != nil {
		fields = append(fields, erpshipmentdetailitem.FieldShipmentDetailID)
	}
	if m.line_no != nil {
		fields = append(fields, erpshipmentdetailitem.FieldLineNo)
	}
	if m.product_id != nil {
		fields = append(fields, erpshipmentdetailitem.FieldProductID)
	}
	if m.product_code != nil {
		fields = append(fields, erpshipmentdetailitem.FieldProductCode)
	}
	if m.product_model != nil {
		fields = append(fields, erpshipmentdetailitem.FieldProductModel)
	}
	if m.pack_detail != nil {
		fields = append(fields, erpshipmentdetailitem.FieldPackDetail)
	}
	if m.quantity != nil {
		fields = append(fields, erpshipmentdetailitem.FieldQuantity)
	}
	if m.unit_price != nil {
		fields = append(fields, erpshipmentdetailitem.FieldUnitPrice)
	}
	if m.total_price != nil {
		fields = append(fields, erpshipmentdetailitem.FieldTotalPrice)
	}
	if m.net_weight != nil {
		fields = append(fields, erpshipmentdetailitem.FieldNetWeight)
	}
	if m.gross_weight != nil {
		fields = append(fields, erpshipmentdetailitem.FieldGrossWeight)
	}
	if m.volume != nil {
		fields = append(fields, erpshipmentdetailitem.FieldVolume)
	}
	if m.created_at != nil {
		fields = append(fields, erpshipmentdetailitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, erpshipmentdetailitem.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ERPShipmentDetailItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case erpshipmentdetailitem.FieldShipmentDetailID:
		return m.ShipmentDetailID()
	case erpshipmentdetailitem.FieldLineNo:
		return m.LineNo()
	case erpshipmentdetailitem.FieldProductID:
		return m.ProductID()
	case erpshipmentdetailitem.FieldProductCode:
		return m.ProductCode()
	case erpshipmentdetailitem.FieldProductModel:
		return m.ProductModel()
	case erpshipmentdetailitem.FieldPackDetail:
		return m.PackDetail()
	case erpshipmentdetailitem.FieldQuantity:
		return m.Quantity()
	case erpshipmentdetailitem.FieldUnitPrice:
		return m.UnitPrice()
	case erpshipmentdetailitem.FieldTotalPrice:
		return m.TotalPrice()
	case erpshipmentdetailitem.FieldNetWeight:
		return m.NetWeight()
	case erpshipmentdetailitem.FieldGrossWeight:
		return m.GrossWeight()
	case erpshipmentdetailitem.FieldVolume:
		return m.Volume()
	case erpshipmentdetailitem.FieldCreatedAt:
		return m.CreatedAt()
	case erpshipmentdetailitem.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ERPShipmentDetailItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case erpshipmentdetailitem.FieldShipmentDetailID:
		return m.OldShipmentDetailID(ctx)
	case erpshipmentdetailitem.FieldLineNo:
		return m.OldLineNo(ctx)
	case erpshipmentdetailitem.FieldProductID:
		return m.OldProductID(ctx)
	case erpshipmentdetailitem.FieldProductCode:
		return m.OldProductCode(ctx)
	case erpshipmentdetailitem.FieldProductModel:
		return m.OldProductModel(ctx)
	case erpshipmentdetailitem.FieldPackDetail:
		return m.OldPackDetail(ctx)
	case erpshipmentdetailitem.FieldQuantity:
		return m.OldQuantity(ctx)
	case erpshipmentdetailitem.FieldUnitPrice:
		return m.OldUnitPrice(ctx)
	case erpshipmentdetailitem.FieldTotalPrice:
		return m.OldTotalPrice(ctx)
	case erpshipmentdetailitem.FieldNetWeight:
		return m.OldNetWeight(ctx)
	case erpshipmentdetailitem.FieldGrossWeight:
		return m.OldGrossWeight(ctx)
	case erpshipmentdetailitem.FieldVolume:
		return m.OldVolume(ctx)
	case erpshipmentdetailitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case erpshipmentdetailitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ERPShipmentDetailItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPShipmentDetailItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case erpshipmentdetailitem.FieldShipmentDetailID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipmentDetailID(v)
		return nil
	case erpshipmentdetailitem.FieldLineNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLineNo(v)
		return nil
	case erpshipmentdetailitem.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case erpshipmentdetailitem.FieldProductCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductCode(v)
		return nil
	case erpshipmentdetailitem.FieldProductModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductModel(v)
		return nil
	case erpshipmentdetailitem.FieldPackDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackDetail(v)
		return nil
	case erpshipmentdetailitem.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case erpshipmentdetailitem.FieldUnitPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitPrice(v)
		return nil
	case erpshipmentdetailitem.FieldTotalPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalPrice(v)
		return nil
	case erpshipmentdetailitem.FieldNetWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetWeight(v)
		return nil
	case erpshipmentdetailitem.FieldGrossWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrossWeight(v)
		return nil
	case erpshipmentdetailitem.FieldVolume:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVolume(v)
		return nil
	case erpshipmentdetailitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case erpshipmentdetailitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ERPShipmentDetailItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ERPShipmentDetailItemMutation) AddedFields() []string {
	var fields []string
	if m.addshipment_detail_id != nil {
		fields = append(fields, erpshipmentdetailitem.FieldShipmentDetailID)
	}
	if m.addline_no != nil {
		fields = append(fields, erpshipmentdetailitem.FieldLineNo)
	}
	if m.addproduct_id != nil {
		fields = append(fields, erpshipmentdetailitem.FieldProductID)
	}
	if m.addquantity != nil {
		fields = append(fields, erpshipmentdetailitem.FieldQuantity)
	}
	if m.addunit_price != nil {
		fields = append(fields, erpshipmentdetailitem.FieldUnitPrice)
	}
	if m.addtotal_price != nil {
		fields = append(fields, erpshipmentdetailitem.FieldTotalPrice)
	}
	if m.addnet_weight != nil {
		fields = append(fields, erpshipmentdetailitem.FieldNetWeight)
	}
	if m.addgross_weight != nil {
		fields = append(fields, erpshipmentdetailitem.FieldGrossWeight)
	}
	if m.addvolume != nil {
		fields = append(fields, erpshipmentdetailitem.FieldVolume)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ERPShipmentDetailItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case erpshipmentdetailitem.FieldShipmentDetailID:
		return m.AddedShipmentDetailID()
	case erpshipmentdetailitem.FieldLineNo:
		return m.AddedLineNo()
	case erpshipmentdetailitem.FieldProductID:
		return m.AddedProductID()
	case erpshipmentdetailitem.FieldQuantity:
		return m.AddedQuantity()
	case erpshipmentdetailitem.FieldUnitPrice:
		return m.AddedUnitPrice()
	case erpshipmentdetailitem.FieldTotalPrice:
		return m.AddedTotalPrice()
	case erpshipmentdetailitem.FieldNetWeight:
		return m.AddedNetWeight()
	case erpshipmentdetailitem.FieldGrossWeight:
		return m.AddedGrossWeight()
	case erpshipmentdetailitem.FieldVolume:
		return m.AddedVolume()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPShipmentDetailItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case erpshipmentdetailitem.FieldShipmentDetailID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShipmentDetailID(v)
		return nil
	case erpshipmentdetailitem.FieldLineNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLineNo(v)
		return nil
	case erpshipmentdetailitem.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case erpshipmentdetailitem.FieldQuantity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case erpshipmentdetailitem.FieldUnitPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitPrice(v)
		return nil
	case erpshipmentdetailitem.FieldTotalPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalPrice(v)
		return nil
	case erpshipmentdetailitem.FieldNetWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNetWeight(v)
		return nil
	case erpshipmentdetailitem.FieldGrossWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGrossWeight(v)
		return nil
	case erpshipmentdetailitem.FieldVolume:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVolume(v)
		return nil
	}
	return fmt.Errorf("unknown ERPShipmentDetailItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ERPShipmentDetailItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(erpshipmentdetailitem.FieldProductID) {
		fields = append(fields, erpshipmentdetailitem.FieldProductID)
	}
	if m.FieldCleared(erpshipmentdetailitem.FieldProductCode) {
		fields = append(fields, erpshipmentdetailitem.FieldProductCode)
	}
	if m.FieldCleared(erpshipmentdetailitem.FieldProductModel) {
		fields = append(fields, erpshipmentdetailitem.FieldProductModel)
	}
	if m.FieldCleared(erpshipmentdetailitem.FieldPackDetail) {
		fields = append(fields, erpshipmentdetailitem.FieldPackDetail)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ERPShipmentDetailItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ERPShipmentDetailItemMutation) ClearField(name string) error {
	switch name {
	case erpshipmentdetailitem.FieldProductID:
		m.ClearProductID()
		return nil
	case erpshipmentdetailitem.FieldProductCode:
		m.ClearProductCode()
		return nil
	case erpshipmentdetailitem.FieldProductModel:
		m.ClearProductModel()
		return nil
	case erpshipmentdetailitem.FieldPackDetail:
		m.ClearPackDetail()
		return nil
	}
	return fmt.Errorf("unknown ERPShipmentDetailItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ERPShipmentDetailItemMutation) ResetField(name string) error {
	switch name {
	case erpshipmentdetailitem.FieldShipmentDetailID:
		m.ResetShipmentDetailID()
		return nil
	case erpshipmentdetailitem.FieldLineNo:
		m.ResetLineNo()
		return nil
	case erpshipmentdetailitem.FieldProductID:
		m.ResetProductID()
		return nil
	case erpshipmentdetailitem.FieldProductCode:
		m.ResetProductCode()
		return nil
	case erpshipmentdetailitem.FieldProductModel:
		m.ResetProductModel()
		return nil
	case erpshipmentdetailitem.FieldPackDetail:
		m.ResetPackDetail()
		return nil
	case erpshipmentdetailitem.FieldQuantity:
		m.ResetQuantity()
		return nil
	case erpshipmentdetailitem.FieldUnitPrice:
		m.ResetUnitPrice()
		return nil
	case erpshipmentdetailitem.FieldTotalPrice:
		m.ResetTotalPrice()
		return nil
	case erpshipmentdetailitem.FieldNetWeight:
		m.ResetNetWeight()
		return nil
	case erpshipmentdetailitem.FieldGrossWeight:
		m.ResetGrossWeight()
		return nil
	case erpshipmentdetailitem.FieldVolume:
		m.ResetVolume()
		return nil
	case erpshipmentdetailitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case erpshipmentdetailitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPShipmentDetailItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ERPShipmentDetailItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ERPShipmentDetailItemMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ERPShipmentDetailItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ERPShipmentDetailItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ERPShipmentDetailItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ERPShipmentDetailItemMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ERPShipmentDetailItemMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ERPShipmentDetailItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ERPShipmentDetailItemMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ERPShipmentDetailItem edge %s", name)
}

// ERPStockBalanceMutation represents an operation that mutates the ERPStockBalance nodes in the graph.
type ERPStockBalanceMutation struct {
	config
	op               Op
	typ              string
	id               *int
	product_code     *string
	warehouse_id     *int
	addwarehouse_id  *int
	location_id      *int
	addlocation_id   *int
	lot_no           *string
	available_qty    *float64
	addavailable_qty *float64
	locked_qty       *float64
	addlocked_qty    *float64
	version          *int64
	addversion       *int64
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*ERPStockBalance, error)
	predicates       []predicate.ERPStockBalance
}

var _ ent.Mutation = (*ERPStockBalanceMutation)(nil)

// erpstockbalanceOption allows management of the mutation configuration using functional options.
type erpstockbalanceOption func(*ERPStockBalanceMutation)

// newERPStockBalanceMutation creates new mutation for the ERPStockBalance entity.
func newERPStockBalanceMutation(c config, op Op, opts ...erpstockbalanceOption) *ERPStockBalanceMutation {
	m := &ERPStockBalanceMutation{
		config:        c,
		op:            op,
		typ:           TypeERPStockBalance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withERPStockBalanceID sets the ID field of the mutation.
func withERPStockBalanceID(id int) erpstockbalanceOption {
	return func(m *ERPStockBalanceMutation) {
		var (
			err   error
			once  sync.Once
			value *ERPStockBalance
		)
		m.oldValue = func(ctx context.Context) (*ERPStockBalance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ERPStockBalance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withERPStockBalance sets the old ERPStockBalance of the mutation.
func withERPStockBalance(node *ERPStockBalance) erpstockbalanceOption {
	return func(m *ERPStockBalanceMutation) {
		m.oldValue = func(context.Context) (*ERPStockBalance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ERPStockBalanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ERPStockBalanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ERPStockBalanceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ERPStockBalanceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ERPStockBalance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProductCode sets the "product_code" field.
func (m *ERPStockBalanceMutation) SetProductCode(s string) {
	m.product_code = &s
}

// ProductCode returns the value of the "product_code" field in the mutation.
func (m *ERPStockBalanceMutation) ProductCode() (r string, exists bool) {
	v := m.product_code
	if v == nil {
		return
	}
	return *v, true
}

// OldProductCode returns the old "product_code" field's value of the ERPStockBalance entity.
// If the ERPStockBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPStockBalanceMutation) OldProductCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductCode: %w", err)
	}
	return oldValue.ProductCode, nil
}

// ResetProductCode resets all changes to the "product_code" field.
func (m *ERPStockBalanceMutation) ResetProductCode() {
	m.product_code = nil
}

// SetWarehouseID sets the "warehouse_id" field.
func (m *ERPStockBalanceMutation) SetWarehouseID(i int) {
	m.warehouse_id = &i
	m.addwarehouse_id = nil
}

// WarehouseID returns the value of the "warehouse_id" field in the mutation.
func (m *ERPStockBalanceMutation) WarehouseID() (r int, exists bool) {
	v := m.warehouse_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWarehouseID returns the old "warehouse_id" field's value of the ERPStockBalance entity.
// If the ERPStockBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPStockBalanceMutation) OldWarehouseID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWarehouseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWarehouseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWarehouseID: %w", err)
	}
	return oldValue.WarehouseID, nil
}

// AddWarehouseID adds i to the "warehouse_id" field.
func (m *ERPStockBalanceMutation) AddWarehouseID(i int) {
	if m.addwarehouse_id != nil {
		*m.addwarehouse_id += i
	} else {
		m.addwarehouse_id = &i
	}
}

// AddedWarehouseID returns the value that was added to the "warehouse_id" field in this mutation.
func (m *ERPStockBalanceMutation) AddedWarehouseID() (r int, exists bool) {
	v := m.addwarehouse_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetWarehouseID resets all changes to the "warehouse_id" field.
func (m *ERPStockBalanceMutation) ResetWarehouseID() {
	m.warehouse_id = nil
	m.addwarehouse_id = nil
}

// SetLocationID sets the "location_id" field.
func (m *ERPStockBalanceMutation) SetLocationID(i int) {
	m.location_id = &i
	m.addlocation_id = nil
}

// LocationID returns the value of the "location_id" field in the mutation.
func (m *ERPStockBalanceMutation) LocationID() (r int, exists bool) {
	v := m.location_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationID returns the old "location_id" field's value of the ERPStockBalance entity.
// If the ERPStockBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPStockBalanceMutation) OldLocationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationID: %w", err)
	}
	return oldValue.LocationID, nil
}

// AddLocationID adds i to the "location_id" field.
func (m *ERPStockBalanceMutation) AddLocationID(i int) {
	if m.addlocation_id != nil {
		*m.addlocation_id += i
	} else {
		m.addlocation_id = &i
	}
}

// AddedLocationID returns the value that was added to the "location_id" field in this mutation.
func (m *ERPStockBalanceMutation) AddedLocationID() (r int, exists bool) {
	v := m.addlocation_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetLocationID resets all changes to the "location_id" field.
func (m *ERPStockBalanceMutation) ResetLocationID() {
	m.location_id = nil
	m.addlocation_id = nil
}

// SetLotNo sets the "lot_no" field.
func (m *ERPStockBalanceMutation) SetLotNo(s string) {
	m.lot_no = &s
}

// LotNo returns the value of the "lot_no" field in the mutation.
func (m *ERPStockBalanceMutation) LotNo() (r string, exists bool) {
	v := m.lot_no
	if v == nil {
		return
	}
	return *v, true
}

// OldLotNo returns the old "lot_no" field's value of the ERPStockBalance entity.
// If the ERPStockBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPStockBalanceMutation) OldLotNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLotNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLotNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLotNo: %w", err)
	}
	return oldValue.LotNo, nil
}

// ResetLotNo resets all changes to the "lot_no" field.
func (m *ERPStockBalanceMutation) ResetLotNo() {
	m.lot_no = nil
}

// SetAvailableQty sets the "available_qty" field.
func (m *ERPStockBalanceMutation) SetAvailableQty(f float64) {
	m.available_qty = &f
	m.addavailable_qty = nil
}

// AvailableQty returns the value of the "available_qty" field in the mutation.
func (m *ERPStockBalanceMutation) AvailableQty() (r float64, exists bool) {
	v := m.available_qty
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailableQty returns the old "available_qty" field's value of the ERPStockBalance entity.
// If the ERPStockBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPStockBalanceMutation) OldAvailableQty(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailableQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailableQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailableQty: %w", err)
	}
	return oldValue.AvailableQty, nil
}

// AddAvailableQty adds f to the "available_qty" field.
func (m *ERPStockBalanceMutation) AddAvailableQty(f float64) {
	if m.addavailable_qty != nil {
		*m.addavailable_qty += f
	} else {
		m.addavailable_qty = &f
	}
}

// AddedAvailableQty returns the value that was added to the "available_qty" field in this mutation.
func (m *ERPStockBalanceMutation) AddedAvailableQty() (r float64, exists bool) {
	v := m.addavailable_qty
	if v == nil {
		return
	}
	return *v, true
}

// ResetAvailableQty resets all changes to the "available_qty" field.
func (m *ERPStockBalanceMutation) ResetAvailableQty() {
	m.available_qty = nil
	m.addavailable_qty = nil
}

// SetLockedQty sets the "locked_qty" field.
func (m *ERPStockBalanceMutation) SetLockedQty(f float64) {
	m.locked_qty = &f
	m.addlocked_qty = nil
}

// LockedQty returns the value of the "locked_qty" field in the mutation.
func (m *ERPStockBalanceMutation) LockedQty() (r float64, exists bool) {
	v := m.locked_qty
	if v == nil {
		return
	}
	return *v, true
}

// OldLockedQty returns the old "locked_qty" field's value of the ERPStockBalance entity.
// If the ERPStockBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPStockBalanceMutation) OldLockedQty(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLockedQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLockedQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLockedQty: %w", err)
	}
	return oldValue.LockedQty, nil
}

// AddLockedQty adds f to the "locked_qty" field.
func (m *ERPStockBalanceMutation) AddLockedQty(f float64) {
	if m.addlocked_qty != nil {
		*m.addlocked_qty += f
	} else {
		m.addlocked_qty = &f
	}
}

// AddedLockedQty returns the value that was added to the "locked_qty" field in this mutation.
func (m *ERPStockBalanceMutation) AddedLockedQty() (r float64, exists bool) {
	v := m.addlocked_qty
	if v == nil {
		return
	}
	return *v, true
}

// ResetLockedQty resets all changes to the "locked_qty" field.
func (m *ERPStockBalanceMutation) ResetLockedQty() {
	m.locked_qty = nil
	m.addlocked_qty = nil
}

// SetVersion sets the "version" field.
func (m *ERPStockBalanceMutation) SetVersion(i int64) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ERPStockBalanceMutation) Version() (r int64, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ERPStockBalance entity.
// If the ERPStockBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPStockBalanceMutation) OldVersion(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ERPStockBalanceMutation) AddVersion(i int64) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ERPStockBalanceMutation) AddedVersion() (r int64, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *ERPStockBalanceMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ERPStockBalanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ERPStockBalanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ERPStockBalance entity.
// If the ERPStockBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPStockBalanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ERPStockBalanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ERPStockBalanceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ERPStockBalanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ERPStockBalance entity.
// If the ERPStockBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPStockBalanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ERPStockBalanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ERPStockBalanceMutation builder.
func (m *ERPStockBalanceMutation) Where(ps ...predicate.ERPStockBalance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ERPStockBalanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ERPStockBalanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ERPStockBalance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ERPStockBalanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ERPStockBalanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ERPStockBalance).
func (m *ERPStockBalanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ERPStockBalanceMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.product_code != nil {
		fields = append(fields, erpstockbalance.FieldProductCode)
	}
	if m.warehouse_id != nil {
		fields = append(fields, erpstockbalance.FieldWarehouseID)
	}
	if m.location_id != nil {
		fields = append(fields, erpstockbalance.FieldLocationID)
	}
	if m.lot_no != nil {
		fields = append(fields, erpstockbalance.FieldLotNo)
	}
	if m.available_qty != nil {
		fields = append(fields, erpstockbalance.FieldAvailableQty)
	}
	if m.locked_qty != nil {
		fields = append(fields, erpstockbalance.FieldLockedQty)
	}
	if m.version != nil {
		fields = append(fields, erpstockbalance.FieldVersion)
	}
	if m.created_at != nil {
		fields = append(fields, erpstockbalance.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, erpstockbalance.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ERPStockBalanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case erpstockbalance.FieldProductCode:
		return m.ProductCode()
	case erpstockbalance.FieldWarehouseID:
		return m.WarehouseID()
	case erpstockbalance.FieldLocationID:
		return m.LocationID()
	case erpstockbalance.FieldLotNo:
		return m.LotNo()
	case erpstockbalance.FieldAvailableQty:
		return m.AvailableQty()
	case erpstockbalance.FieldLockedQty:
		return m.LockedQty()
	case erpstockbalance.FieldVersion:
		return m.Version()
	case erpstockbalance.FieldCreatedAt:
		return m.CreatedAt()
	case erpstockbalance.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ERPStockBalanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case erpstockbalance.FieldProductCode:
		return m.OldProductCode(ctx)
	case erpstockbalance.FieldWarehouseID:
		return m.OldWarehouseID(ctx)
	case erpstockbalance.FieldLocationID:
		return m.OldLocationID(ctx)
	case erpstockbalance.FieldLotNo:
		return m.OldLotNo(ctx)
	case erpstockbalance.FieldAvailableQty:
		return m.OldAvailableQty(ctx)
	case erpstockbalance.FieldLockedQty:
		return m.OldLockedQty(ctx)
	case erpstockbalance.FieldVersion:
		return m.OldVersion(ctx)
	case erpstockbalance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case erpstockbalance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ERPStockBalance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPStockBalanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case erpstockbalance.FieldProductCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductCode(v)
		return nil
	case erpstockbalance.FieldWarehouseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWarehouseID(v)
		return nil
	case erpstockbalance.FieldLocationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationID(v)
		return nil
	case erpstockbalance.FieldLotNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLotNo(v)
		return nil
	case erpstockbalance.FieldAvailableQty:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailableQty(v)
		return nil
	case erpstockbalance.FieldLockedQty:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLockedQty(v)
		return nil
	case erpstockbalance.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case erpstockbalance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case erpstockbalance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ERPStockBalance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ERPStockBalanceMutation) AddedFields() []string {
	var fields []string
	if m.addwarehouse_id != nil {
		fields = append(fields, erpstockbalance.FieldWarehouseID)
	}
	if m.addlocation_id != nil {
		fields = append(fields, erpstockbalance.FieldLocationID)
	}
	if m.addavailable_qty != nil {
		fields = append(fields, erpstockbalance.FieldAvailableQty)
	}
	if m.addlocked_qty != nil {
		fields = append(fields, erpstockbalance.FieldLockedQty)
	}
	if m.addversion != nil {
		fields = append(fields, erpstockbalance.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ERPStockBalanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case erpstockbalance.FieldWarehouseID:
		return m.AddedWarehouseID()
	case erpstockbalance.FieldLocationID:
		return m.AddedLocationID()
	case erpstockbalance.FieldAvailableQty:
		return m.AddedAvailableQty()
	case erpstockbalance.FieldLockedQty:
		return m.AddedLockedQty()
	case erpstockbalance.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPStockBalanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case erpstockbalance.FieldWarehouseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWarehouseID(v)
		return nil
	case erpstockbalance.FieldLocationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLocationID(v)
		return nil
	case erpstockbalance.FieldAvailableQty:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvailableQty(v)
		return nil
	case erpstockbalance.FieldLockedQty:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLockedQty(v)
		return nil
	case erpstockbalance.FieldVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown ERPStockBalance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ERPStockBalanceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ERPStockBalanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ERPStockBalanceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ERPStockBalance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ERPStockBalanceMutation) ResetField(name string) error {
	switch name {
	case erpstockbalance.FieldProductCode:
		m.ResetProductCode()
		return nil
	case erpstockbalance.FieldWarehouseID:
		m.ResetWarehouseID()
		return nil
	case erpstockbalance.FieldLocationID:
		m.ResetLocationID()
		return nil
	case erpstockbalance.FieldLotNo:
		m.ResetLotNo()
		return nil
	case erpstockbalance.FieldAvailableQty:
		m.ResetAvailableQty()
		return nil
	case erpstockbalance.FieldLockedQty:
		m.ResetLockedQty()
		return nil
	case erpstockbalance.FieldVersion:
		m.ResetVersion()
		return nil
	case erpstockbalance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case erpstockbalance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPStockBalance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ERPStockBalanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ERPStockBalanceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ERPStockBalanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ERPStockBalanceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ERPStockBalanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ERPStockBalanceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ERPStockBalanceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ERPStockBalance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ERPStockBalanceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ERPStockBalance edge %s", name)
}

// ERPStockTransactionMutation represents an operation that mutates the ERPStockTransaction nodes in the graph.
type ERPStockTransactionMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	biz_type                *string
	biz_code                *string
	biz_line_no             *int
	addbiz_line_no          *int
	product_code            *string
	warehouse_id            *int
	addwarehouse_id         *int
	location_id             *int
	addlocation_id          *int
	lot_no                  *string
	delta_qty               *float64
	adddelta_qty            *float64
	before_available_qty    *float64
	addbefore_available_qty *float64
	after_available_qty     *float64
	addafter_available_qty  *float64
	operator_admin_id       *int
	addoperator_admin_id    *int
	occurred_at             *time.Time
	created_at              *time.Time
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*ERPStockTransaction, error)
	predicates              []predicate.ERPStockTransaction
}

var _ ent.Mutation = (*ERPStockTransactionMutation)(nil)

// erpstocktransactionOption allows management of the mutation configuration using functional options.
type erpstocktransactionOption func(*ERPStockTransactionMutation)

// newERPStockTransactionMutation creates new mutation for the ERPStockTransaction entity.
func newERPStockTransactionMutation(c config, op Op, opts ...erpstocktransactionOption) *ERPStockTransactionMutation {
	m := &ERPStockTransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeERPStockTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withERPStockTransactionID sets the ID field of the mutation.
func withERPStockTransactionID(id int) erpstocktransactionOption {
	return func(m *ERPStockTransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *ERPStockTransaction
		)
		m.oldValue = func(ctx context.Context) (*ERPStockTransaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ERPStockTransaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withERPStockTransaction sets the old ERPStockTransaction of the mutation.
func withERPStockTransaction(node *ERPStockTransaction) erpstocktransactionOption {
	return func(m *ERPStockTransactionMutation) {
		m.oldValue = func(context.Context) (*ERPStockTransaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ERPStockTransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ERPStockTransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ERPStockTransactionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ERPStockTransactionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ERPStockTransaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBizType sets the "biz_type" field.
func (m *ERPStockTransactionMutation) SetBizType(s string) {
	m.biz_type = &s
}

// BizType returns the value of the "biz_type" field in the mutation.
func (m *ERPStockTransactionMutation) BizType() (r string, exists bool) {
	v := m.biz_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBizType returns the old "biz_type" field's value of the ERPStockTransaction entity.
// If the ERPStockTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPStockTransactionMutation) OldBizType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBizType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBizType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBizType: %w", err)
	}
	return oldValue.BizType, nil
}

// ResetBizType resets all changes to the "biz_type" field.
func (m *ERPStockTransactionMutation) ResetBizType() {
	m.biz_type = nil
}

// SetBizCode sets the "biz_code" field.
func (m *ERPStockTransactionMutation) SetBizCode(s string) {
	m.biz_code = &s
}

// BizCode returns the value of the "biz_code" field in the mutation.
func (m *ERPStockTransactionMutation) BizCode() (r string, exists bool) {
	v := m.biz_code
	if v == nil {
		return
	}
	return *v, true
}

// OldBizCode returns the old "biz_code" field's value of the ERPStockTransaction entity.
// If the ERPStockTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPStockTransactionMutation) OldBizCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBizCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBizCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBizCode: %w", err)
	}
	return oldValue.BizCode, nil
}

// ResetBizCode resets all changes to the "biz_code" field.
func (m *ERPStockTransactionMutation) ResetBizCode() {
	m.biz_code = nil
}

// SetBizLineNo sets the "biz_line_no" field.
func (m *ERPStockTransactionMutation) SetBizLineNo(i int) {
	m.biz_line_no = &i
	m.addbiz_line_no = nil
}

// BizLineNo returns the value of the "biz_line_no" field in the mutation.
func (m *ERPStockTransactionMutation) BizLineNo() (r int, exists bool) {
	v := m.biz_line_no
	if v == nil {
		return
	}
	return *v, true
}

// OldBizLineNo returns the old "biz_line_no" field's value of the ERPStockTransaction entity.
// If the ERPStockTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPStockTransactionMutation) OldBizLineNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBizLineNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBizLineNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBizLineNo: %w", err)
	}
	return oldValue.BizLineNo, nil
}

// AddBizLineNo adds i to the "biz_line_no" field.
func (m *ERPStockTransactionMutation) AddBizLineNo(i int) {
	if m.addbiz_line_no != nil {
		*m.addbiz_line_no += i
	} else {
		m.addbiz_line_no = &i
	}
}

// AddedBizLineNo returns the value that was added to the "biz_line_no" field in this mutation.
func (m *ERPStockTransactionMutation) AddedBizLineNo() (r int, exists bool) {
	v := m.addbiz_line_no
	if v == nil {
		return
	}
	return *v, true
}

// ResetBizLineNo resets all changes to the "biz_line_no" field.
func (m *ERPStockTransactionMutation) ResetBizLineNo() {
	m.biz_line_no = nil
	m.addbiz_line_no = nil
}

// SetProductCode sets the "product_code" field.
func (m *ERPStockTransactionMutation) SetProductCode(s string) {
	m.product_code = &s
}

// ProductCode returns the value of the "product_code" field in the mutation.
func (m *ERPStockTransactionMutation) ProductCode() (r string, exists bool) {
	v := m.product_code
	if v == nil {
		return
	}
	return *v, true
}

// OldProductCode returns the old "product_code" field's value of the ERPStockTransaction entity.
// If the ERPStockTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPStockTransactionMutation) OldProductCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductCode: %w", err)
	}
	return oldValue.ProductCode, nil
}

// ResetProductCode resets all changes to the "product_code" field.
func (m *ERPStockTransactionMutation) ResetProductCode() {
	m.product_code = nil
}

// SetWarehouseID sets the "warehouse_id" field.
func (m *ERPStockTransactionMutation) SetWarehouseID(i int) {
	m.warehouse_id = &i
	m.addwarehouse_id = nil
}

// WarehouseID returns the value of the "warehouse_id" field in the mutation.
func (m *ERPStockTransactionMutation) WarehouseID() (r int, exists bool) {
	v := m.warehouse_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWarehouseID returns the old "warehouse_id" field's value of the ERPStockTransaction entity.
// If the ERPStockTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPStockTransactionMutation) OldWarehouseID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWarehouseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWarehouseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWarehouseID: %w", err)
	}
	return oldValue.WarehouseID, nil
}

// AddWarehouseID adds i to the "warehouse_id" field.
func (m *ERPStockTransactionMutation) AddWarehouseID(i int) {
	if m.addwarehouse_id != nil {
		*m.addwarehouse_id += i
	} else {
		m.addwarehouse_id = &i
	}
}

// AddedWarehouseID returns the value that was added to the "warehouse_id" field in this mutation.
func (m *ERPStockTransactionMutation) AddedWarehouseID() (r int, exists bool) {
	v := m.addwarehouse_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetWarehouseID resets all changes to the "warehouse_id" field.
func (m *ERPStockTransactionMutation) ResetWarehouseID() {
	m.warehouse_id = nil
	m.addwarehouse_id = nil
}

// SetLocationID sets the "location_id" field.
func (m *ERPStockTransactionMutation) SetLocationID(i int) {
	m.location_id = &i
	m.addlocation_id = nil
}

// LocationID returns the value of the "location_id" field in the mutation.
func (m *ERPStockTransactionMutation) LocationID() (r int, exists bool) {
	v := m.location_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationID returns the old "location_id" field's value of the ERPStockTransaction entity.
// If the ERPStockTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPStockTransactionMutation) OldLocationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationID: %w", err)
	}
	return oldValue.LocationID, nil
}

// AddLocationID adds i to the "location_id" field.
func (m *ERPStockTransactionMutation) AddLocationID(i int) {
	if m.addlocation_id != nil {
		*m.addlocation_id += i
	} else {
		m.addlocation_id = &i
	}
}

// AddedLocationID returns the value that was added to the "location_id" field in this mutation.
func (m *ERPStockTransactionMutation) AddedLocationID() (r int, exists bool) {
	v := m.addlocation_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetLocationID resets all changes to the "location_id" field.
func (m *ERPStockTransactionMutation) ResetLocationID() {
	m.location_id = nil
	m.addlocation_id = nil
}

// SetLotNo sets the "lot_no" field.
func (m *ERPStockTransactionMutation) SetLotNo(s string) {
	m.lot_no = &s
}

// LotNo returns the value of the "lot_no" field in the mutation.
func (m *ERPStockTransactionMutation) LotNo() (r string, exists bool) {
	v := m.lot_no
	if v == nil {
		return
	}
	return *v, true
}

// OldLotNo returns the old "lot_no" field's value of the ERPStockTransaction entity.
// If the ERPStockTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPStockTransactionMutation) OldLotNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLotNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLotNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLotNo: %w", err)
	}
	return oldValue.LotNo, nil
}

// ResetLotNo resets all changes to the "lot_no" field.
func (m *ERPStockTransactionMutation) ResetLotNo() {
	m.lot_no = nil
}

// SetDeltaQty sets the "delta_qty" field.
func (m *ERPStockTransactionMutation) SetDeltaQty(f float64) {
	m.delta_qty = &f
	m.adddelta_qty = nil
}

// DeltaQty returns the value of the "delta_qty" field in the mutation.
func (m *ERPStockTransactionMutation) DeltaQty() (r float64, exists bool) {
	v := m.delta_qty
	if v == nil {
		return
	}
	return *v, true
}

// OldDeltaQty returns the old "delta_qty" field's value of the ERPStockTransaction entity.
// If the ERPStockTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPStockTransactionMutation) OldDeltaQty(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeltaQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeltaQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeltaQty: %w", err)
	}
	return oldValue.DeltaQty, nil
}

// AddDeltaQty adds f to the "delta_qty" field.
func (m *ERPStockTransactionMutation) AddDeltaQty(f float64) {
	if m.adddelta_qty != nil {
		*m.adddelta_qty += f
	} else {
		m.adddelta_qty = &f
	}
}

// AddedDeltaQty returns the value that was added to the "delta_qty" field in this mutation.
func (m *ERPStockTransactionMutation) AddedDeltaQty() (r float64, exists bool) {
	v := m.adddelta_qty
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeltaQty resets all changes to the "delta_qty" field.
func (m *ERPStockTransactionMutation) ResetDeltaQty() {
	m.delta_qty = nil
	m.adddelta_qty = nil
}

// SetBeforeAvailableQty sets the "before_available_qty" field.
func (m *ERPStockTransactionMutation) SetBeforeAvailableQty(f float64) {
	m.before_available_qty = &f
	m.addbefore_available_qty = nil
}

// BeforeAvailableQty returns the value of the "before_available_qty" field in the mutation.
func (m *ERPStockTransactionMutation) BeforeAvailableQty() (r float64, exists bool) {
	v := m.before_available_qty
	if v == nil {
		return
	}
	return *v, true
}

// OldBeforeAvailableQty returns the old "before_available_qty" field's value of the ERPStockTransaction entity.
// If the ERPStockTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPStockTransactionMutation) OldBeforeAvailableQty(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeforeAvailableQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeforeAvailableQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeforeAvailableQty: %w", err)
	}
	return oldValue.BeforeAvailableQty, nil
}

// AddBeforeAvailableQty adds f to the "before_available_qty" field.
func (m *ERPStockTransactionMutation) AddBeforeAvailableQty(f float64) {
	if m.addbefore_available_qty != nil {
		*m.addbefore_available_qty += f
	} else {
		m.addbefore_available_qty = &f
	}
}

// AddedBeforeAvailableQty returns the value that was added to the "before_available_qty" field in this mutation.
func (m *ERPStockTransactionMutation) AddedBeforeAvailableQty() (r float64, exists bool) {
	v := m.addbefore_available_qty
	if v == nil {
		return
	}
	return *v, true
}

// ResetBeforeAvailableQty resets all changes to the "before_available_qty" field.
func (m *ERPStockTransactionMutation) ResetBeforeAvailableQty() {
	m.before_available_qty = nil
	m.addbefore_available_qty = nil
}

// SetAfterAvailableQty sets the "after_available_qty" field.
func (m *ERPStockTransactionMutation) SetAfterAvailableQty(f float64) {
	m.after_available_qty = &f
	m.addafter_available_qty = nil
}

// AfterAvailableQty returns the value of the "after_available_qty" field in the mutation.
func (m *ERPStockTransactionMutation) AfterAvailableQty() (r float64, exists bool) {
	v := m.after_available_qty
	if v == nil {
		return
	}
	return *v, true
}

// OldAfterAvailableQty returns the old "after_available_qty" field's value of the ERPStockTransaction entity.
// If the ERPStockTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPStockTransactionMutation) OldAfterAvailableQty(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAfterAvailableQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAfterAvailableQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAfterAvailableQty: %w", err)
	}
	return oldValue.AfterAvailableQty, nil
}

// AddAfterAvailableQty adds f to the "after_available_qty" field.
func (m *ERPStockTransactionMutation) AddAfterAvailableQty(f float64) {
	if m.addafter_available_qty != nil {
		*m.addafter_available_qty += f
	} else {
		m.addafter_available_qty = &f
	}
}

// AddedAfterAvailableQty returns the value that was added to the "after_available_qty" field in this mutation.
func (m *ERPStockTransactionMutation) AddedAfterAvailableQty() (r float64, exists bool) {
	v := m.addafter_available_qty
	if v == nil {
		return
	}
	return *v, true
}

// ResetAfterAvailableQty resets all changes to the "after_available_qty" field.
func (m *ERPStockTransactionMutation) ResetAfterAvailableQty() {
	m.after_available_qty = nil
	m.addafter_available_qty = nil
}

// SetOperatorAdminID sets the "operator_admin_id" field.
func (m *ERPStockTransactionMutation) SetOperatorAdminID(i int) {
	m.operator_admin_id = &i
	m.addoperator_admin_id = nil
}

// OperatorAdminID returns the value of the "operator_admin_id" field in the mutation.
func (m *ERPStockTransactionMutation) OperatorAdminID() (r int, exists bool) {
	v := m.operator_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorAdminID returns the old "operator_admin_id" field's value of the ERPStockTransaction entity.
// If the ERPStockTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPStockTransactionMutation) OldOperatorAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorAdminID: %w", err)
	}
	return oldValue.OperatorAdminID, nil
}

// AddOperatorAdminID adds i to the "operator_admin_id" field.
func (m *ERPStockTransactionMutation) AddOperatorAdminID(i int) {
	if m.addoperator_admin_id != nil {
		*m.addoperator_admin_id += i
	} else {
		m.addoperator_admin_id = &i
	}
}

// AddedOperatorAdminID returns the value that was added to the "operator_admin_id" field in this mutation.
func (m *ERPStockTransactionMutation) AddedOperatorAdminID() (r int, exists bool) {
	v := m.addoperator_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOperatorAdminID clears the value of the "operator_admin_id" field.
func (m *ERPStockTransactionMutation) ClearOperatorAdminID() {
	m.operator_admin_id = nil
	m.addoperator_admin_id = nil
	m.clearedFields[erpstocktransaction.FieldOperatorAdminID] = struct{}{}
}

// OperatorAdminIDCleared returns if the "operator_admin_id" field was cleared in this mutation.
func (m *ERPStockTransactionMutation) OperatorAdminIDCleared() bool {
	_, ok := m.clearedFields[erpstocktransaction.FieldOperatorAdminID]
	return ok
}

// ResetOperatorAdminID resets all changes to the "operator_admin_id" field.
func (m *ERPStockTransactionMutation) ResetOperatorAdminID() {
	m.operator_admin_id = nil
	m.addoperator_admin_id = nil
	delete(m.clearedFields, erpstocktransaction.FieldOperatorAdminID)
}

// SetOccurredAt sets the "occurred_at" field.
func (m *ERPStockTransactionMutation) SetOccurredAt(t time.Time) {
	m.occurred_at = &t
}

// OccurredAt returns the value of the "occurred_at" field in the mutation.
func (m *ERPStockTransactionMutation) OccurredAt() (r time.Time, exists bool) {
	v := m.occurred_at
	if v == nil {
		return
	}
	return *v, true
}

// OldOccurredAt returns the old "occurred_at" field's value of the ERPStockTransaction entity.
// If the ERPStockTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPStockTransactionMutation) OldOccurredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOccurredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOccurredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOccurredAt: %w", err)
	}
	return oldValue.OccurredAt, nil
}

// ResetOccurredAt resets all changes to the "occurred_at" field.
func (m *ERPStockTransactionMutation) ResetOccurredAt() {
	m.occurred_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ERPStockTransactionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ERPStockTransactionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ERPStockTransaction entity.
// If the ERPStockTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPStockTransactionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ERPStockTransactionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the ERPStockTransactionMutation builder.
func (m *ERPStockTransactionMutation) Where(ps ...predicate.ERPStockTransaction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ERPStockTransactionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ERPStockTransactionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ERPStockTransaction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ERPStockTransactionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ERPStockTransactionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ERPStockTransaction).
func (m *ERPStockTransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ERPStockTransactionMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.biz_type != nil {
		fields = append(fields, erpstocktransaction.FieldBizType)
	}
	if m.biz_code != nil {
		fields = append(fields, erpstocktransaction.FieldBizCode)
	}
	if m.biz_line_no != nil {
		fields = append(fields, erpstocktransaction.FieldBizLineNo)
	}
	if m.product_code != nil {
		fields = append(fields, erpstocktransaction.FieldProductCode)
	}
	if m.warehouse_id != nil {
		fields = append(fields, erpstocktransaction.FieldWarehouseID)
	}
	if m.location_id != nil {
		fields = append(fields, erpstocktransaction.FieldLocationID)
	}
	if m.lot_no != nil {
		fields = append(fields, erpstocktransaction.FieldLotNo)
	}
	if m.delta_qty != nil {
		fields = append(fields, erpstocktransaction.FieldDeltaQty)
	}
	if m.before_available_qty != nil {
		fields = append(fields, erpstocktransaction.FieldBeforeAvailableQty)
	}
	if m.after_available_qty != nil {
		fields = append(fields, erpstocktransaction.FieldAfterAvailableQty)
	}
	if m.operator_admin_id != nil {
		fields = append(fields, erpstocktransaction.FieldOperatorAdminID)
	}
	if m.occurred_at != nil {
		fields = append(fields, erpstocktransaction.FieldOccurredAt)
	}
	if m.created_at != nil {
		fields = append(fields, erpstocktransaction.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ERPStockTransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case erpstocktransaction.FieldBizType:
		return m.BizType()
	case erpstocktransaction.FieldBizCode:
		return m.BizCode()
	case erpstocktransaction.FieldBizLineNo:
		return m.BizLineNo()
	case erpstocktransaction.FieldProductCode:
		return m.ProductCode()
	case erpstocktransaction.FieldWarehouseID:
		return m.WarehouseID()
	case erpstocktransaction.FieldLocationID:
		return m.LocationID()
	case erpstocktransaction.FieldLotNo:
		return m.LotNo()
	case erpstocktransaction.FieldDeltaQty:
		return m.DeltaQty()
	case erpstocktransaction.FieldBeforeAvailableQty:
		return m.BeforeAvailableQty()
	case erpstocktransaction.FieldAfterAvailableQty:
		return m.AfterAvailableQty()
	case erpstocktransaction.FieldOperatorAdminID:
		return m.OperatorAdminID()
	case erpstocktransaction.FieldOccurredAt:
		return m.OccurredAt()
	case erpstocktransaction.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ERPStockTransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case erpstocktransaction.FieldBizType:
		return m.OldBizType(ctx)
	case erpstocktransaction.FieldBizCode:
		return m.OldBizCode(ctx)
	case erpstocktransaction.FieldBizLineNo:
		return m.OldBizLineNo(ctx)
	case erpstocktransaction.FieldProductCode:
		return m.OldProductCode(ctx)
	case erpstocktransaction.FieldWarehouseID:
		return m.OldWarehouseID(ctx)
	case erpstocktransaction.FieldLocationID:
		return m.OldLocationID(ctx)
	case erpstocktransaction.FieldLotNo:
		return m.OldLotNo(ctx)
	case erpstocktransaction.FieldDeltaQty:
		return m.OldDeltaQty(ctx)
	case erpstocktransaction.FieldBeforeAvailableQty:
		return m.OldBeforeAvailableQty(ctx)
	case erpstocktransaction.FieldAfterAvailableQty:
		return m.OldAfterAvailableQty(ctx)
	case erpstocktransaction.FieldOperatorAdminID:
		return m.OldOperatorAdminID(ctx)
	case erpstocktransaction.FieldOccurredAt:
		return m.OldOccurredAt(ctx)
	case erpstocktransaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ERPStockTransaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPStockTransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case erpstocktransaction.FieldBizType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBizType(v)
		return nil
	case erpstocktransaction.FieldBizCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBizCode(v)
		return nil
	case erpstocktransaction.FieldBizLineNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBizLineNo(v)
		return nil
	case erpstocktransaction.FieldProductCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductCode(v)
		return nil
	case erpstocktransaction.FieldWarehouseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWarehouseID(v)
		return nil
	case erpstocktransaction.FieldLocationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationID(v)
		return nil
	case erpstocktransaction.FieldLotNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLotNo(v)
		return nil
	case erpstocktransaction.FieldDeltaQty:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeltaQty(v)
		return nil
	case erpstocktransaction.FieldBeforeAvailableQty:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeforeAvailableQty(v)
		return nil
	case erpstocktransaction.FieldAfterAvailableQty:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAfterAvailableQty(v)
		return nil
	case erpstocktransaction.FieldOperatorAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorAdminID(v)
		return nil
	case erpstocktransaction.FieldOccurredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOccurredAt(v)
		return nil
	case erpstocktransaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ERPStockTransaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ERPStockTransactionMutation) AddedFields() []string {
	var fields []string
	if m.addbiz_line_no != nil {
		fields = append(fields, erpstocktransaction.FieldBizLineNo)
	}
	if m.addwarehouse_id != nil {
		fields = append(fields, erpstocktransaction.FieldWarehouseID)
	}
	if m.addlocation_id != nil {
		fields = append(fields, erpstocktransaction.FieldLocationID)
	}
	if m.adddelta_qty != nil {
		fields = append(fields, erpstocktransaction.FieldDeltaQty)
	}
	if m.addbefore_available_qty != nil {
		fields = append(fields, erpstocktransaction.FieldBeforeAvailableQty)
	}
	if m.addafter_available_qty != nil {
		fields = append(fields, erpstocktransaction.FieldAfterAvailableQty)
	}
	if m.addoperator_admin_id != nil {
		fields = append(fields, erpstocktransaction.FieldOperatorAdminID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ERPStockTransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case erpstocktransaction.FieldBizLineNo:
		return m.AddedBizLineNo()
	case erpstocktransaction.FieldWarehouseID:
		return m.AddedWarehouseID()
	case erpstocktransaction.FieldLocationID:
		return m.AddedLocationID()
	case erpstocktransaction.FieldDeltaQty:
		return m.AddedDeltaQty()
	case erpstocktransaction.FieldBeforeAvailableQty:
		return m.AddedBeforeAvailableQty()
	case erpstocktransaction.FieldAfterAvailableQty:
		return m.AddedAfterAvailableQty()
	case erpstocktransaction.FieldOperatorAdminID:
		return m.AddedOperatorAdminID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPStockTransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case erpstocktransaction.FieldBizLineNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBizLineNo(v)
		return nil
	case erpstocktransaction.FieldWarehouseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWarehouseID(v)
		return nil
	case erpstocktransaction.FieldLocationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLocationID(v)
		return nil
	case erpstocktransaction.FieldDeltaQty:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeltaQty(v)
		return nil
	case erpstocktransaction.FieldBeforeAvailableQty:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBeforeAvailableQty(v)
		return nil
	case erpstocktransaction.FieldAfterAvailableQty:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAfterAvailableQty(v)
		return nil
	case erpstocktransaction.FieldOperatorAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperatorAdminID(v)
		return nil
	}
	return fmt.Errorf("unknown ERPStockTransaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ERPStockTransactionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(erpstocktransaction.FieldOperatorAdminID) {
		fields = append(fields, erpstocktransaction.FieldOperatorAdminID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ERPStockTransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ERPStockTransactionMutation) ClearField(name string) error {
	switch name {
	case erpstocktransaction.FieldOperatorAdminID:
		m.ClearOperatorAdminID()
		return nil
	}
	return fmt.Errorf("unknown ERPStockTransaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ERPStockTransactionMutation) ResetField(name string) error {
	switch name {
	case erpstocktransaction.FieldBizType:
		m.ResetBizType()
		return nil
	case erpstocktransaction.FieldBizCode:
		m.ResetBizCode()
		return nil
	case erpstocktransaction.FieldBizLineNo:
		m.ResetBizLineNo()
		return nil
	case erpstocktransaction.FieldProductCode:
		m.ResetProductCode()
		return nil
	case erpstocktransaction.FieldWarehouseID:
		m.ResetWarehouseID()
		return nil
	case erpstocktransaction.FieldLocationID:
		m.ResetLocationID()
		return nil
	case erpstocktransaction.FieldLotNo:
		m.ResetLotNo()
		return nil
	case erpstocktransaction.FieldDeltaQty:
		m.ResetDeltaQty()
		return nil
	case erpstocktransaction.FieldBeforeAvailableQty:
		m.ResetBeforeAvailableQty()
		return nil
	case erpstocktransaction.FieldAfterAvailableQty:
		m.ResetAfterAvailableQty()
		return nil
	case erpstocktransaction.FieldOperatorAdminID:
		m.ResetOperatorAdminID()
		return nil
	case erpstocktransaction.FieldOccurredAt:
		m.ResetOccurredAt()
		return nil
	case erpstocktransaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPStockTransaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ERPStockTransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ERPStockTransactionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ERPStockTransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ERPStockTransactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ERPStockTransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ERPStockTransactionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ERPStockTransactionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ERPStockTransaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ERPStockTransactionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ERPStockTransaction edge %s", name)
}

// ERPWarehouseMutation represents an operation that mutates the ERPWarehouse nodes in the graph.
type ERPWarehouseMutation struct {
	config
	op            Op
	typ           string
	id            *int
	code          *string
	name          *string
	disabled      *bool
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ERPWarehouse, error)
	predicates    []predicate.ERPWarehouse
}

var _ ent.Mutation = (*ERPWarehouseMutation)(nil)

// erpwarehouseOption allows management of the mutation configuration using functional options.
type erpwarehouseOption func(*ERPWarehouseMutation)

// newERPWarehouseMutation creates new mutation for the ERPWarehouse entity.
func newERPWarehouseMutation(c config, op Op, opts ...erpwarehouseOption) *ERPWarehouseMutation {
	m := &ERPWarehouseMutation{
		config:        c,
		op:            op,
		typ:           TypeERPWarehouse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withERPWarehouseID sets the ID field of the mutation.
func withERPWarehouseID(id int) erpwarehouseOption {
	return func(m *ERPWarehouseMutation) {
		var (
			err   error
			once  sync.Once
			value *ERPWarehouse
		)
		m.oldValue = func(ctx context.Context) (*ERPWarehouse, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ERPWarehouse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withERPWarehouse sets the old ERPWarehouse of the mutation.
func withERPWarehouse(node *ERPWarehouse) erpwarehouseOption {
	return func(m *ERPWarehouseMutation) {
		m.oldValue = func(context.Context) (*ERPWarehouse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ERPWarehouseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ERPWarehouseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ERPWarehouseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ERPWarehouseMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ERPWarehouse.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *ERPWarehouseMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ERPWarehouseMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the ERPWarehouse entity.
// If the ERPWarehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWarehouseMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ERPWarehouseMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *ERPWarehouseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ERPWarehouseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ERPWarehouse entity.
// If the ERPWarehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWarehouseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ERPWarehouseMutation) ResetName() {
	m.name = nil
}

// SetDisabled sets the "disabled" field.
func (m *ERPWarehouseMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *ERPWarehouseMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the ERPWarehouse entity.
// If the ERPWarehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWarehouseMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *ERPWarehouseMutation) ResetDisabled() {
	m.disabled = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ERPWarehouseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ERPWarehouseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ERPWarehouse entity.
// If the ERPWarehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWarehouseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ERPWarehouseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ERPWarehouseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ERPWarehouseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ERPWarehouse entity.
// If the ERPWarehouse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWarehouseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ERPWarehouseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ERPWarehouseMutation builder.
func (m *ERPWarehouseMutation) Where(ps ...predicate.ERPWarehouse) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ERPWarehouseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ERPWarehouseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ERPWarehouse, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ERPWarehouseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ERPWarehouseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ERPWarehouse).
func (m *ERPWarehouseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ERPWarehouseMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.code != nil {
		fields = append(fields, erpwarehouse.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, erpwarehouse.FieldName)
	}
	if m.disabled != nil {
		fields = append(fields, erpwarehouse.FieldDisabled)
	}
	if m.created_at != nil {
		fields = append(fields, erpwarehouse.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, erpwarehouse.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ERPWarehouseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case erpwarehouse.FieldCode:
		return m.Code()
	case erpwarehouse.FieldName:
		return m.Name()
	case erpwarehouse.FieldDisabled:
		return m.Disabled()
	case erpwarehouse.FieldCreatedAt:
		return m.CreatedAt()
	case erpwarehouse.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ERPWarehouseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case erpwarehouse.FieldCode:
		return m.OldCode(ctx)
	case erpwarehouse.FieldName:
		return m.OldName(ctx)
	case erpwarehouse.FieldDisabled:
		return m.OldDisabled(ctx)
	case erpwarehouse.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case erpwarehouse.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ERPWarehouse field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPWarehouseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case erpwarehouse.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case erpwarehouse.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case erpwarehouse.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case erpwarehouse.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case erpwarehouse.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ERPWarehouse field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ERPWarehouseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ERPWarehouseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPWarehouseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ERPWarehouse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ERPWarehouseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ERPWarehouseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ERPWarehouseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ERPWarehouse nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ERPWarehouseMutation) ResetField(name string) error {
	switch name {
	case erpwarehouse.FieldCode:
		m.ResetCode()
		return nil
	case erpwarehouse.FieldName:
		m.ResetName()
		return nil
	case erpwarehouse.FieldDisabled:
		m.ResetDisabled()
		return nil
	case erpwarehouse.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case erpwarehouse.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPWarehouse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ERPWarehouseMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ERPWarehouseMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ERPWarehouseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ERPWarehouseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ERPWarehouseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ERPWarehouseMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ERPWarehouseMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ERPWarehouse unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ERPWarehouseMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ERPWarehouse edge %s", name)
}

// ERPWorkflowActionLogMutation represents an operation that mutates the ERPWorkflowActionLog nodes in the graph.
type ERPWorkflowActionLogMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	workflow_instance_id    *int
	addworkflow_instance_id *int
	workflow_task_id        *int
	addworkflow_task_id     *int
	action                  *string
	from_status             *string
	to_status               *string
	operator_admin_id       *int
	addoperator_admin_id    *int
	remark                  *string
	created_at              *time.Time
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*ERPWorkflowActionLog, error)
	predicates              []predicate.ERPWorkflowActionLog
}

var _ ent.Mutation = (*ERPWorkflowActionLogMutation)(nil)

// erpworkflowactionlogOption allows management of the mutation configuration using functional options.
type erpworkflowactionlogOption func(*ERPWorkflowActionLogMutation)

// newERPWorkflowActionLogMutation creates new mutation for the ERPWorkflowActionLog entity.
func newERPWorkflowActionLogMutation(c config, op Op, opts ...erpworkflowactionlogOption) *ERPWorkflowActionLogMutation {
	m := &ERPWorkflowActionLogMutation{
		config:        c,
		op:            op,
		typ:           TypeERPWorkflowActionLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withERPWorkflowActionLogID sets the ID field of the mutation.
func withERPWorkflowActionLogID(id int) erpworkflowactionlogOption {
	return func(m *ERPWorkflowActionLogMutation) {
		var (
			err   error
			once  sync.Once
			value *ERPWorkflowActionLog
		)
		m.oldValue = func(ctx context.Context) (*ERPWorkflowActionLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ERPWorkflowActionLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withERPWorkflowActionLog sets the old ERPWorkflowActionLog of the mutation.
func withERPWorkflowActionLog(node *ERPWorkflowActionLog) erpworkflowactionlogOption {
	return func(m *ERPWorkflowActionLogMutation) {
		m.oldValue = func(context.Context) (*ERPWorkflowActionLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ERPWorkflowActionLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ERPWorkflowActionLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ERPWorkflowActionLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ERPWorkflowActionLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ERPWorkflowActionLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWorkflowInstanceID sets the "workflow_instance_id" field.
func (m *ERPWorkflowActionLogMutation) SetWorkflowInstanceID(i int) {
	m.workflow_instance_id = &i
	m.addworkflow_instance_id = nil
}

// WorkflowInstanceID returns the value of the "workflow_instance_id" field in the mutation.
func (m *ERPWorkflowActionLogMutation) WorkflowInstanceID() (r int, exists bool) {
	v := m.workflow_instance_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowInstanceID returns the old "workflow_instance_id" field's value of the ERPWorkflowActionLog entity.
// If the ERPWorkflowActionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWorkflowActionLogMutation) OldWorkflowInstanceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowInstanceID: %w", err)
	}
	return oldValue.WorkflowInstanceID, nil
}

// AddWorkflowInstanceID adds i to the "workflow_instance_id" field.
func (m *ERPWorkflowActionLogMutation) AddWorkflowInstanceID(i int) {
	if m.addworkflow_instance_id != nil {
		*m.addworkflow_instance_id += i
	} else {
		m.addworkflow_instance_id = &i
	}
}

// AddedWorkflowInstanceID returns the value that was added to the "workflow_instance_id" field in this mutation.
func (m *ERPWorkflowActionLogMutation) AddedWorkflowInstanceID() (r int, exists bool) {
	v := m.addworkflow_instance_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetWorkflowInstanceID resets all changes to the "workflow_instance_id" field.
func (m *ERPWorkflowActionLogMutation) ResetWorkflowInstanceID() {
	m.workflow_instance_id = nil
	m.addworkflow_instance_id = nil
}

// SetWorkflowTaskID sets the "workflow_task_id" field.
func (m *ERPWorkflowActionLogMutation) SetWorkflowTaskID(i int) {
	m.workflow_task_id = &i
	m.addworkflow_task_id = nil
}

// WorkflowTaskID returns the value of the "workflow_task_id" field in the mutation.
func (m *ERPWorkflowActionLogMutation) WorkflowTaskID() (r int, exists bool) {
	v := m.workflow_task_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowTaskID returns the old "workflow_task_id" field's value of the ERPWorkflowActionLog entity.
// If the ERPWorkflowActionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWorkflowActionLogMutation) OldWorkflowTaskID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowTaskID: %w", err)
	}
	return oldValue.WorkflowTaskID, nil
}

// AddWorkflowTaskID adds i to the "workflow_task_id" field.
func (m *ERPWorkflowActionLogMutation) AddWorkflowTaskID(i int) {
	if m.addworkflow_task_id != nil {
		*m.addworkflow_task_id += i
	} else {
		m.addworkflow_task_id = &i
	}
}

// AddedWorkflowTaskID returns the value that was added to the "workflow_task_id" field in this mutation.
func (m *ERPWorkflowActionLogMutation) AddedWorkflowTaskID() (r int, exists bool) {
	v := m.addworkflow_task_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearWorkflowTaskID clears the value of the "workflow_task_id" field.
func (m *ERPWorkflowActionLogMutation) ClearWorkflowTaskID() {
	m.workflow_task_id = nil
	m.addworkflow_task_id = nil
	m.clearedFields[erpworkflowactionlog.FieldWorkflowTaskID] = struct{}{}
}

// WorkflowTaskIDCleared returns if the "workflow_task_id" field was cleared in this mutation.
func (m *ERPWorkflowActionLogMutation) WorkflowTaskIDCleared() bool {
	_, ok := m.clearedFields[erpworkflowactionlog.FieldWorkflowTaskID]
	return ok
}

// ResetWorkflowTaskID resets all changes to the "workflow_task_id" field.
func (m *ERPWorkflowActionLogMutation) ResetWorkflowTaskID() {
	m.workflow_task_id = nil
	m.addworkflow_task_id = nil
	delete(m.clearedFields, erpworkflowactionlog.FieldWorkflowTaskID)
}

// SetAction sets the "action" field.
func (m *ERPWorkflowActionLogMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *ERPWorkflowActionLogMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the ERPWorkflowActionLog entity.
// If the ERPWorkflowActionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWorkflowActionLogMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *ERPWorkflowActionLogMutation) ResetAction() {
	m.action = nil
}

// SetFromStatus sets the "from_status" field.
func (m *ERPWorkflowActionLogMutation) SetFromStatus(s string) {
	m.from_status = &s
}

// FromStatus returns the value of the "from_status" field in the mutation.
func (m *ERPWorkflowActionLogMutation) FromStatus() (r string, exists bool) {
	v := m.from_status
	if v == nil {
		return
	}
	return *v, true
}

// OldFromStatus returns the old "from_status" field's value of the ERPWorkflowActionLog entity.
// If the ERPWorkflowActionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWorkflowActionLogMutation) OldFromStatus(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromStatus: %w", err)
	}
	return oldValue.FromStatus, nil
}

// ClearFromStatus clears the value of the "from_status" field.
func (m *ERPWorkflowActionLogMutation) ClearFromStatus() {
	m.from_status = nil
	m.clearedFields[erpworkflowactionlog.FieldFromStatus] = struct{}{}
}

// FromStatusCleared returns if the "from_status" field was cleared in this mutation.
func (m *ERPWorkflowActionLogMutation) FromStatusCleared() bool {
	_, ok := m.clearedFields[erpworkflowactionlog.FieldFromStatus]
	return ok
}

// ResetFromStatus resets all changes to the "from_status" field.
func (m *ERPWorkflowActionLogMutation) ResetFromStatus() {
	m.from_status = nil
	delete(m.clearedFields, erpworkflowactionlog.FieldFromStatus)
}

// SetToStatus sets the "to_status" field.
func (m *ERPWorkflowActionLogMutation) SetToStatus(s string) {
	m.to_status = &s
}

// ToStatus returns the value of the "to_status" field in the mutation.
func (m *ERPWorkflowActionLogMutation) ToStatus() (r string, exists bool) {
	v := m.to_status
	if v == nil {
		return
	}
	return *v, true
}

// OldToStatus returns the old "to_status" field's value of the ERPWorkflowActionLog entity.
// If the ERPWorkflowActionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWorkflowActionLogMutation) OldToStatus(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToStatus: %w", err)
	}
	return oldValue.ToStatus, nil
}

// ClearToStatus clears the value of the "to_status" field.
func (m *ERPWorkflowActionLogMutation) ClearToStatus() {
	m.to_status = nil
	m.clearedFields[erpworkflowactionlog.FieldToStatus] = struct{}{}
}

// ToStatusCleared returns if the "to_status" field was cleared in this mutation.
func (m *ERPWorkflowActionLogMutation) ToStatusCleared() bool {
	_, ok := m.clearedFields[erpworkflowactionlog.FieldToStatus]
	return ok
}

// ResetToStatus resets all changes to the "to_status" field.
func (m *ERPWorkflowActionLogMutation) ResetToStatus() {
	m.to_status = nil
	delete(m.clearedFields, erpworkflowactionlog.FieldToStatus)
}

// SetOperatorAdminID sets the "operator_admin_id" field.
func (m *ERPWorkflowActionLogMutation) SetOperatorAdminID(i int) {
	m.operator_admin_id = &i
	m.addoperator_admin_id = nil
}

// OperatorAdminID returns the value of the "operator_admin_id" field in the mutation.
func (m *ERPWorkflowActionLogMutation) OperatorAdminID() (r int, exists bool) {
	v := m.operator_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOperatorAdminID returns the old "operator_admin_id" field's value of the ERPWorkflowActionLog entity.
// If the ERPWorkflowActionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWorkflowActionLogMutation) OldOperatorAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperatorAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperatorAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperatorAdminID: %w", err)
	}
	return oldValue.OperatorAdminID, nil
}

// AddOperatorAdminID adds i to the "operator_admin_id" field.
func (m *ERPWorkflowActionLogMutation) AddOperatorAdminID(i int) {
	if m.addoperator_admin_id != nil {
		*m.addoperator_admin_id += i
	} else {
		m.addoperator_admin_id = &i
	}
}

// AddedOperatorAdminID returns the value that was added to the "operator_admin_id" field in this mutation.
func (m *ERPWorkflowActionLogMutation) AddedOperatorAdminID() (r int, exists bool) {
	v := m.addoperator_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOperatorAdminID clears the value of the "operator_admin_id" field.
func (m *ERPWorkflowActionLogMutation) ClearOperatorAdminID() {
	m.operator_admin_id = nil
	m.addoperator_admin_id = nil
	m.clearedFields[erpworkflowactionlog.FieldOperatorAdminID] = struct{}{}
}

// OperatorAdminIDCleared returns if the "operator_admin_id" field was cleared in this mutation.
func (m *ERPWorkflowActionLogMutation) OperatorAdminIDCleared() bool {
	_, ok := m.clearedFields[erpworkflowactionlog.FieldOperatorAdminID]
	return ok
}

// ResetOperatorAdminID resets all changes to the "operator_admin_id" field.
func (m *ERPWorkflowActionLogMutation) ResetOperatorAdminID() {
	m.operator_admin_id = nil
	m.addoperator_admin_id = nil
	delete(m.clearedFields, erpworkflowactionlog.FieldOperatorAdminID)
}

// SetRemark sets the "remark" field.
func (m *ERPWorkflowActionLogMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ERPWorkflowActionLogMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the ERPWorkflowActionLog entity.
// If the ERPWorkflowActionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWorkflowActionLogMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ERPWorkflowActionLogMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[erpworkflowactionlog.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ERPWorkflowActionLogMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[erpworkflowactionlog.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ERPWorkflowActionLogMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, erpworkflowactionlog.FieldRemark)
}

// SetCreatedAt sets the "created_at" field.
func (m *ERPWorkflowActionLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ERPWorkflowActionLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ERPWorkflowActionLog entity.
// If the ERPWorkflowActionLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWorkflowActionLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ERPWorkflowActionLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the ERPWorkflowActionLogMutation builder.
func (m *ERPWorkflowActionLogMutation) Where(ps ...predicate.ERPWorkflowActionLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ERPWorkflowActionLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ERPWorkflowActionLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ERPWorkflowActionLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ERPWorkflowActionLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ERPWorkflowActionLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ERPWorkflowActionLog).
func (m *ERPWorkflowActionLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ERPWorkflowActionLogMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.workflow_instance_id != nil {
		fields = append(fields, erpworkflowactionlog.FieldWorkflowInstanceID)
	}
	if m.workflow_task_id != nil {
		fields = append(fields, erpworkflowactionlog.FieldWorkflowTaskID)
	}
	if m.action != nil {
		fields = append(fields, erpworkflowactionlog.FieldAction)
	}
	if m.from_status != nil {
		fields = append(fields, erpworkflowactionlog.FieldFromStatus)
	}
	if m.to_status != nil {
		fields = append(fields, erpworkflowactionlog.FieldToStatus)
	}
	if m.operator_admin_id != nil {
		fields = append(fields, erpworkflowactionlog.FieldOperatorAdminID)
	}
	if m.remark != nil {
		fields = append(fields, erpworkflowactionlog.FieldRemark)
	}
	if m.created_at != nil {
		fields = append(fields, erpworkflowactionlog.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ERPWorkflowActionLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case erpworkflowactionlog.FieldWorkflowInstanceID:
		return m.WorkflowInstanceID()
	case erpworkflowactionlog.FieldWorkflowTaskID:
		return m.WorkflowTaskID()
	case erpworkflowactionlog.FieldAction:
		return m.Action()
	case erpworkflowactionlog.FieldFromStatus:
		return m.FromStatus()
	case erpworkflowactionlog.FieldToStatus:
		return m.ToStatus()
	case erpworkflowactionlog.FieldOperatorAdminID:
		return m.OperatorAdminID()
	case erpworkflowactionlog.FieldRemark:
		return m.Remark()
	case erpworkflowactionlog.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ERPWorkflowActionLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case erpworkflowactionlog.FieldWorkflowInstanceID:
		return m.OldWorkflowInstanceID(ctx)
	case erpworkflowactionlog.FieldWorkflowTaskID:
		return m.OldWorkflowTaskID(ctx)
	case erpworkflowactionlog.FieldAction:
		return m.OldAction(ctx)
	case erpworkflowactionlog.FieldFromStatus:
		return m.OldFromStatus(ctx)
	case erpworkflowactionlog.FieldToStatus:
		return m.OldToStatus(ctx)
	case erpworkflowactionlog.FieldOperatorAdminID:
		return m.OldOperatorAdminID(ctx)
	case erpworkflowactionlog.FieldRemark:
		return m.OldRemark(ctx)
	case erpworkflowactionlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ERPWorkflowActionLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPWorkflowActionLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case erpworkflowactionlog.FieldWorkflowInstanceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowInstanceID(v)
		return nil
	case erpworkflowactionlog.FieldWorkflowTaskID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowTaskID(v)
		return nil
	case erpworkflowactionlog.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case erpworkflowactionlog.FieldFromStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromStatus(v)
		return nil
	case erpworkflowactionlog.FieldToStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToStatus(v)
		return nil
	case erpworkflowactionlog.FieldOperatorAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperatorAdminID(v)
		return nil
	case erpworkflowactionlog.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case erpworkflowactionlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ERPWorkflowActionLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ERPWorkflowActionLogMutation) AddedFields() []string {
	var fields []string
	if m.addworkflow_instance_id != nil {
		fields = append(fields, erpworkflowactionlog.FieldWorkflowInstanceID)
	}
	if m.addworkflow_task_id != nil {
		fields = append(fields, erpworkflowactionlog.FieldWorkflowTaskID)
	}
	if m.addoperator_admin_id != nil {
		fields = append(fields, erpworkflowactionlog.FieldOperatorAdminID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ERPWorkflowActionLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case erpworkflowactionlog.FieldWorkflowInstanceID:
		return m.AddedWorkflowInstanceID()
	case erpworkflowactionlog.FieldWorkflowTaskID:
		return m.AddedWorkflowTaskID()
	case erpworkflowactionlog.FieldOperatorAdminID:
		return m.AddedOperatorAdminID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPWorkflowActionLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case erpworkflowactionlog.FieldWorkflowInstanceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWorkflowInstanceID(v)
		return nil
	case erpworkflowactionlog.FieldWorkflowTaskID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWorkflowTaskID(v)
		return nil
	case erpworkflowactionlog.FieldOperatorAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperatorAdminID(v)
		return nil
	}
	return fmt.Errorf("unknown ERPWorkflowActionLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ERPWorkflowActionLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(erpworkflowactionlog.FieldWorkflowTaskID) {
		fields = append(fields, erpworkflowactionlog.FieldWorkflowTaskID)
	}
	if m.FieldCleared(erpworkflowactionlog.FieldFromStatus) {
		fields = append(fields, erpworkflowactionlog.FieldFromStatus)
	}
	if m.FieldCleared(erpworkflowactionlog.FieldToStatus) {
		fields = append(fields, erpworkflowactionlog.FieldToStatus)
	}
	if m.FieldCleared(erpworkflowactionlog.FieldOperatorAdminID) {
		fields = append(fields, erpworkflowactionlog.FieldOperatorAdminID)
	}
	if m.FieldCleared(erpworkflowactionlog.FieldRemark) {
		fields = append(fields, erpworkflowactionlog.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ERPWorkflowActionLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ERPWorkflowActionLogMutation) ClearField(name string) error {
	switch name {
	case erpworkflowactionlog.FieldWorkflowTaskID:
		m.ClearWorkflowTaskID()
		return nil
	case erpworkflowactionlog.FieldFromStatus:
		m.ClearFromStatus()
		return nil
	case erpworkflowactionlog.FieldToStatus:
		m.ClearToStatus()
		return nil
	case erpworkflowactionlog.FieldOperatorAdminID:
		m.ClearOperatorAdminID()
		return nil
	case erpworkflowactionlog.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown ERPWorkflowActionLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ERPWorkflowActionLogMutation) ResetField(name string) error {
	switch name {
	case erpworkflowactionlog.FieldWorkflowInstanceID:
		m.ResetWorkflowInstanceID()
		return nil
	case erpworkflowactionlog.FieldWorkflowTaskID:
		m.ResetWorkflowTaskID()
		return nil
	case erpworkflowactionlog.FieldAction:
		m.ResetAction()
		return nil
	case erpworkflowactionlog.FieldFromStatus:
		m.ResetFromStatus()
		return nil
	case erpworkflowactionlog.FieldToStatus:
		m.ResetToStatus()
		return nil
	case erpworkflowactionlog.FieldOperatorAdminID:
		m.ResetOperatorAdminID()
		return nil
	case erpworkflowactionlog.FieldRemark:
		m.ResetRemark()
		return nil
	case erpworkflowactionlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPWorkflowActionLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ERPWorkflowActionLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ERPWorkflowActionLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ERPWorkflowActionLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ERPWorkflowActionLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ERPWorkflowActionLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ERPWorkflowActionLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ERPWorkflowActionLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ERPWorkflowActionLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ERPWorkflowActionLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ERPWorkflowActionLog edge %s", name)
}

// ERPWorkflowInstanceMutation represents an operation that mutates the ERPWorkflowInstance nodes in the graph.
type ERPWorkflowInstanceMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	biz_module          *string
	biz_code            *string
	current_status      *string
	starter_admin_id    *int
	addstarter_admin_id *int
	submitted_at        *time.Time
	finished_at         *time.Time
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*ERPWorkflowInstance, error)
	predicates          []predicate.ERPWorkflowInstance
}

var _ ent.Mutation = (*ERPWorkflowInstanceMutation)(nil)

// erpworkflowinstanceOption allows management of the mutation configuration using functional options.
type erpworkflowinstanceOption func(*ERPWorkflowInstanceMutation)

// newERPWorkflowInstanceMutation creates new mutation for the ERPWorkflowInstance entity.
func newERPWorkflowInstanceMutation(c config, op Op, opts ...erpworkflowinstanceOption) *ERPWorkflowInstanceMutation {
	m := &ERPWorkflowInstanceMutation{
		config:        c,
		op:            op,
		typ:           TypeERPWorkflowInstance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withERPWorkflowInstanceID sets the ID field of the mutation.
func withERPWorkflowInstanceID(id int) erpworkflowinstanceOption {
	return func(m *ERPWorkflowInstanceMutation) {
		var (
			err   error
			once  sync.Once
			value *ERPWorkflowInstance
		)
		m.oldValue = func(ctx context.Context) (*ERPWorkflowInstance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ERPWorkflowInstance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withERPWorkflowInstance sets the old ERPWorkflowInstance of the mutation.
func withERPWorkflowInstance(node *ERPWorkflowInstance) erpworkflowinstanceOption {
	return func(m *ERPWorkflowInstanceMutation) {
		m.oldValue = func(context.Context) (*ERPWorkflowInstance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ERPWorkflowInstanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ERPWorkflowInstanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ERPWorkflowInstanceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ERPWorkflowInstanceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ERPWorkflowInstance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBizModule sets the "biz_module" field.
func (m *ERPWorkflowInstanceMutation) SetBizModule(s string) {
	m.biz_module = &s
}

// BizModule returns the value of the "biz_module" field in the mutation.
func (m *ERPWorkflowInstanceMutation) BizModule() (r string, exists bool) {
	v := m.biz_module
	if v == nil {
		return
	}
	return *v, true
}

// OldBizModule returns the old "biz_module" field's value of the ERPWorkflowInstance entity.
// If the ERPWorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWorkflowInstanceMutation) OldBizModule(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBizModule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBizModule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBizModule: %w", err)
	}
	return oldValue.BizModule, nil
}

// ResetBizModule resets all changes to the "biz_module" field.
func (m *ERPWorkflowInstanceMutation) ResetBizModule() {
	m.biz_module = nil
}

// SetBizCode sets the "biz_code" field.
func (m *ERPWorkflowInstanceMutation) SetBizCode(s string) {
	m.biz_code = &s
}

// BizCode returns the value of the "biz_code" field in the mutation.
func (m *ERPWorkflowInstanceMutation) BizCode() (r string, exists bool) {
	v := m.biz_code
	if v == nil {
		return
	}
	return *v, true
}

// OldBizCode returns the old "biz_code" field's value of the ERPWorkflowInstance entity.
// If the ERPWorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWorkflowInstanceMutation) OldBizCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBizCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBizCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBizCode: %w", err)
	}
	return oldValue.BizCode, nil
}

// ResetBizCode resets all changes to the "biz_code" field.
func (m *ERPWorkflowInstanceMutation) ResetBizCode() {
	m.biz_code = nil
}

// SetCurrentStatus sets the "current_status" field.
func (m *ERPWorkflowInstanceMutation) SetCurrentStatus(s string) {
	m.current_status = &s
}

// CurrentStatus returns the value of the "current_status" field in the mutation.
func (m *ERPWorkflowInstanceMutation) CurrentStatus() (r string, exists bool) {
	v := m.current_status
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentStatus returns the old "current_status" field's value of the ERPWorkflowInstance entity.
// If the ERPWorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWorkflowInstanceMutation) OldCurrentStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentStatus: %w", err)
	}
	return oldValue.CurrentStatus, nil
}

// ResetCurrentStatus resets all changes to the "current_status" field.
func (m *ERPWorkflowInstanceMutation) ResetCurrentStatus() {
	m.current_status = nil
}

// SetStarterAdminID sets the "starter_admin_id" field.
func (m *ERPWorkflowInstanceMutation) SetStarterAdminID(i int) {
	m.starter_admin_id = &i
	m.addstarter_admin_id = nil
}

// StarterAdminID returns the value of the "starter_admin_id" field in the mutation.
func (m *ERPWorkflowInstanceMutation) StarterAdminID() (r int, exists bool) {
	v := m.starter_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStarterAdminID returns the old "starter_admin_id" field's value of the ERPWorkflowInstance entity.
// If the ERPWorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWorkflowInstanceMutation) OldStarterAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStarterAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStarterAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStarterAdminID: %w", err)
	}
	return oldValue.StarterAdminID, nil
}

// AddStarterAdminID adds i to the "starter_admin_id" field.
func (m *ERPWorkflowInstanceMutation) AddStarterAdminID(i int) {
	if m.addstarter_admin_id != nil {
		*m.addstarter_admin_id += i
	} else {
		m.addstarter_admin_id = &i
	}
}

// AddedStarterAdminID returns the value that was added to the "starter_admin_id" field in this mutation.
func (m *ERPWorkflowInstanceMutation) AddedStarterAdminID() (r int, exists bool) {
	v := m.addstarter_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearStarterAdminID clears the value of the "starter_admin_id" field.
func (m *ERPWorkflowInstanceMutation) ClearStarterAdminID() {
	m.starter_admin_id = nil
	m.addstarter_admin_id = nil
	m.clearedFields[erpworkflowinstance.FieldStarterAdminID] = struct{}{}
}

// StarterAdminIDCleared returns if the "starter_admin_id" field was cleared in this mutation.
func (m *ERPWorkflowInstanceMutation) StarterAdminIDCleared() bool {
	_, ok := m.clearedFields[erpworkflowinstance.FieldStarterAdminID]
	return ok
}

// ResetStarterAdminID resets all changes to the "starter_admin_id" field.
func (m *ERPWorkflowInstanceMutation) ResetStarterAdminID() {
	m.starter_admin_id = nil
	m.addstarter_admin_id = nil
	delete(m.clearedFields, erpworkflowinstance.FieldStarterAdminID)
}

// SetSubmittedAt sets the "submitted_at" field.
func (m *ERPWorkflowInstanceMutation) SetSubmittedAt(t time.Time) {
	m.submitted_at = &t
}

// SubmittedAt returns the value of the "submitted_at" field in the mutation.
func (m *ERPWorkflowInstanceMutation) SubmittedAt() (r time.Time, exists bool) {
	v := m.submitted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSubmittedAt returns the old "submitted_at" field's value of the ERPWorkflowInstance entity.
// If the ERPWorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWorkflowInstanceMutation) OldSubmittedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubmittedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubmittedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubmittedAt: %w", err)
	}
	return oldValue.SubmittedAt, nil
}

// ClearSubmittedAt clears the value of the "submitted_at" field.
func (m *ERPWorkflowInstanceMutation) ClearSubmittedAt() {
	m.submitted_at = nil
	m.clearedFields[erpworkflowinstance.FieldSubmittedAt] = struct{}{}
}

// SubmittedAtCleared returns if the "submitted_at" field was cleared in this mutation.
func (m *ERPWorkflowInstanceMutation) SubmittedAtCleared() bool {
	_, ok := m.clearedFields[erpworkflowinstance.FieldSubmittedAt]
	return ok
}

// ResetSubmittedAt resets all changes to the "submitted_at" field.
func (m *ERPWorkflowInstanceMutation) ResetSubmittedAt() {
	m.submitted_at = nil
	delete(m.clearedFields, erpworkflowinstance.FieldSubmittedAt)
}

// SetFinishedAt sets the "finished_at" field.
func (m *ERPWorkflowInstanceMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *ERPWorkflowInstanceMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the ERPWorkflowInstance entity.
// If the ERPWorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWorkflowInstanceMutation) OldFinishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (m *ERPWorkflowInstanceMutation) ClearFinishedAt() {
	m.finished_at = nil
	m.clearedFields[erpworkflowinstance.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the "finished_at" field was cleared in this mutation.
func (m *ERPWorkflowInstanceMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[erpworkflowinstance.FieldFinishedAt]
	return ok
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *ERPWorkflowInstanceMutation) ResetFinishedAt() {
	m.finished_at = nil
	delete(m.clearedFields, erpworkflowinstance.FieldFinishedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *ERPWorkflowInstanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ERPWorkflowInstanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ERPWorkflowInstance entity.
// If the ERPWorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWorkflowInstanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ERPWorkflowInstanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ERPWorkflowInstanceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ERPWorkflowInstanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ERPWorkflowInstance entity.
// If the ERPWorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWorkflowInstanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ERPWorkflowInstanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ERPWorkflowInstanceMutation builder.
func (m *ERPWorkflowInstanceMutation) Where(ps ...predicate.ERPWorkflowInstance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ERPWorkflowInstanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ERPWorkflowInstanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ERPWorkflowInstance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ERPWorkflowInstanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ERPWorkflowInstanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ERPWorkflowInstance).
func (m *ERPWorkflowInstanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ERPWorkflowInstanceMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.biz_module != nil {
		fields = append(fields, erpworkflowinstance.FieldBizModule)
	}
	if m.biz_code != nil {
		fields = append(fields, erpworkflowinstance.FieldBizCode)
	}
	if m.current_status != nil {
		fields = append(fields, erpworkflowinstance.FieldCurrentStatus)
	}
	if m.starter_admin_id != nil {
		fields = append(fields, erpworkflowinstance.FieldStarterAdminID)
	}
	if m.submitted_at != nil {
		fields = append(fields, erpworkflowinstance.FieldSubmittedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, erpworkflowinstance.FieldFinishedAt)
	}
	if m.created_at != nil {
		fields = append(fields, erpworkflowinstance.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, erpworkflowinstance.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ERPWorkflowInstanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case erpworkflowinstance.FieldBizModule:
		return m.BizModule()
	case erpworkflowinstance.FieldBizCode:
		return m.BizCode()
	case erpworkflowinstance.FieldCurrentStatus:
		return m.CurrentStatus()
	case erpworkflowinstance.FieldStarterAdminID:
		return m.StarterAdminID()
	case erpworkflowinstance.FieldSubmittedAt:
		return m.SubmittedAt()
	case erpworkflowinstance.FieldFinishedAt:
		return m.FinishedAt()
	case erpworkflowinstance.FieldCreatedAt:
		return m.CreatedAt()
	case erpworkflowinstance.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ERPWorkflowInstanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case erpworkflowinstance.FieldBizModule:
		return m.OldBizModule(ctx)
	case erpworkflowinstance.FieldBizCode:
		return m.OldBizCode(ctx)
	case erpworkflowinstance.FieldCurrentStatus:
		return m.OldCurrentStatus(ctx)
	case erpworkflowinstance.FieldStarterAdminID:
		return m.OldStarterAdminID(ctx)
	case erpworkflowinstance.FieldSubmittedAt:
		return m.OldSubmittedAt(ctx)
	case erpworkflowinstance.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	case erpworkflowinstance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case erpworkflowinstance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ERPWorkflowInstance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPWorkflowInstanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case erpworkflowinstance.FieldBizModule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBizModule(v)
		return nil
	case erpworkflowinstance.FieldBizCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBizCode(v)
		return nil
	case erpworkflowinstance.FieldCurrentStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentStatus(v)
		return nil
	case erpworkflowinstance.FieldStarterAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStarterAdminID(v)
		return nil
	case erpworkflowinstance.FieldSubmittedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubmittedAt(v)
		return nil
	case erpworkflowinstance.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	case erpworkflowinstance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case erpworkflowinstance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ERPWorkflowInstance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ERPWorkflowInstanceMutation) AddedFields() []string {
	var fields []string
	if m.addstarter_admin_id != nil {
		fields = append(fields, erpworkflowinstance.FieldStarterAdminID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ERPWorkflowInstanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case erpworkflowinstance.FieldStarterAdminID:
		return m.AddedStarterAdminID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPWorkflowInstanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case erpworkflowinstance.FieldStarterAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStarterAdminID(v)
		return nil
	}
	return fmt.Errorf("unknown ERPWorkflowInstance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ERPWorkflowInstanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(erpworkflowinstance.FieldStarterAdminID) {
		fields = append(fields, erpworkflowinstance.FieldStarterAdminID)
	}
	if m.FieldCleared(erpworkflowinstance.FieldSubmittedAt) {
		fields = append(fields, erpworkflowinstance.FieldSubmittedAt)
	}
	if m.FieldCleared(erpworkflowinstance.FieldFinishedAt) {
		fields = append(fields, erpworkflowinstance.FieldFinishedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ERPWorkflowInstanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ERPWorkflowInstanceMutation) ClearField(name string) error {
	switch name {
	case erpworkflowinstance.FieldStarterAdminID:
		m.ClearStarterAdminID()
		return nil
	case erpworkflowinstance.FieldSubmittedAt:
		m.ClearSubmittedAt()
		return nil
	case erpworkflowinstance.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPWorkflowInstance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ERPWorkflowInstanceMutation) ResetField(name string) error {
	switch name {
	case erpworkflowinstance.FieldBizModule:
		m.ResetBizModule()
		return nil
	case erpworkflowinstance.FieldBizCode:
		m.ResetBizCode()
		return nil
	case erpworkflowinstance.FieldCurrentStatus:
		m.ResetCurrentStatus()
		return nil
	case erpworkflowinstance.FieldStarterAdminID:
		m.ResetStarterAdminID()
		return nil
	case erpworkflowinstance.FieldSubmittedAt:
		m.ResetSubmittedAt()
		return nil
	case erpworkflowinstance.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	case erpworkflowinstance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case erpworkflowinstance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPWorkflowInstance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ERPWorkflowInstanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ERPWorkflowInstanceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ERPWorkflowInstanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ERPWorkflowInstanceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ERPWorkflowInstanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ERPWorkflowInstanceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ERPWorkflowInstanceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ERPWorkflowInstance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ERPWorkflowInstanceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ERPWorkflowInstance edge %s", name)
}

// ERPWorkflowTaskMutation represents an operation that mutates the ERPWorkflowTask nodes in the graph.
type ERPWorkflowTaskMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	workflow_instance_id    *int
	addworkflow_instance_id *int
	node_name               *string
	node_order              *int
	addnode_order           *int
	assignee_admin_id       *int
	addassignee_admin_id    *int
	decision                *string
	comment                 *string
	acted_at                *time.Time
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*ERPWorkflowTask, error)
	predicates              []predicate.ERPWorkflowTask
}

var _ ent.Mutation = (*ERPWorkflowTaskMutation)(nil)

// erpworkflowtaskOption allows management of the mutation configuration using functional options.
type erpworkflowtaskOption func(*ERPWorkflowTaskMutation)

// newERPWorkflowTaskMutation creates new mutation for the ERPWorkflowTask entity.
func newERPWorkflowTaskMutation(c config, op Op, opts ...erpworkflowtaskOption) *ERPWorkflowTaskMutation {
	m := &ERPWorkflowTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeERPWorkflowTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withERPWorkflowTaskID sets the ID field of the mutation.
func withERPWorkflowTaskID(id int) erpworkflowtaskOption {
	return func(m *ERPWorkflowTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *ERPWorkflowTask
		)
		m.oldValue = func(ctx context.Context) (*ERPWorkflowTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ERPWorkflowTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withERPWorkflowTask sets the old ERPWorkflowTask of the mutation.
func withERPWorkflowTask(node *ERPWorkflowTask) erpworkflowtaskOption {
	return func(m *ERPWorkflowTaskMutation) {
		m.oldValue = func(context.Context) (*ERPWorkflowTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ERPWorkflowTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ERPWorkflowTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ERPWorkflowTaskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ERPWorkflowTaskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ERPWorkflowTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWorkflowInstanceID sets the "workflow_instance_id" field.
func (m *ERPWorkflowTaskMutation) SetWorkflowInstanceID(i int) {
	m.workflow_instance_id = &i
	m.addworkflow_instance_id = nil
}

// WorkflowInstanceID returns the value of the "workflow_instance_id" field in the mutation.
func (m *ERPWorkflowTaskMutation) WorkflowInstanceID() (r int, exists bool) {
	v := m.workflow_instance_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowInstanceID returns the old "workflow_instance_id" field's value of the ERPWorkflowTask entity.
// If the ERPWorkflowTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWorkflowTaskMutation) OldWorkflowInstanceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowInstanceID: %w", err)
	}
	return oldValue.WorkflowInstanceID, nil
}

// AddWorkflowInstanceID adds i to the "workflow_instance_id" field.
func (m *ERPWorkflowTaskMutation) AddWorkflowInstanceID(i int) {
	if m.addworkflow_instance_id != nil {
		*m.addworkflow_instance_id += i
	} else {
		m.addworkflow_instance_id = &i
	}
}

// AddedWorkflowInstanceID returns the value that was added to the "workflow_instance_id" field in this mutation.
func (m *ERPWorkflowTaskMutation) AddedWorkflowInstanceID() (r int, exists bool) {
	v := m.addworkflow_instance_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetWorkflowInstanceID resets all changes to the "workflow_instance_id" field.
func (m *ERPWorkflowTaskMutation) ResetWorkflowInstanceID() {
	m.workflow_instance_id = nil
	m.addworkflow_instance_id = nil
}

// SetNodeName sets the "node_name" field.
func (m *ERPWorkflowTaskMutation) SetNodeName(s string) {
	m.node_name = &s
}

// NodeName returns the value of the "node_name" field in the mutation.
func (m *ERPWorkflowTaskMutation) NodeName() (r string, exists bool) {
	v := m.node_name
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeName returns the old "node_name" field's value of the ERPWorkflowTask entity.
// If the ERPWorkflowTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWorkflowTaskMutation) OldNodeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeName: %w", err)
	}
	return oldValue.NodeName, nil
}

// ResetNodeName resets all changes to the "node_name" field.
func (m *ERPWorkflowTaskMutation) ResetNodeName() {
	m.node_name = nil
}

// SetNodeOrder sets the "node_order" field.
func (m *ERPWorkflowTaskMutation) SetNodeOrder(i int) {
	m.node_order = &i
	m.addnode_order = nil
}

// NodeOrder returns the value of the "node_order" field in the mutation.
func (m *ERPWorkflowTaskMutation) NodeOrder() (r int, exists bool) {
	v := m.node_order
	if v == nil {
		return
	}
	return *v, true
}

// OldNodeOrder returns the old "node_order" field's value of the ERPWorkflowTask entity.
// If the ERPWorkflowTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWorkflowTaskMutation) OldNodeOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNodeOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNodeOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNodeOrder: %w", err)
	}
	return oldValue.NodeOrder, nil
}

// AddNodeOrder adds i to the "node_order" field.
func (m *ERPWorkflowTaskMutation) AddNodeOrder(i int) {
	if m.addnode_order != nil {
		*m.addnode_order += i
	} else {
		m.addnode_order = &i
	}
}

// AddedNodeOrder returns the value that was added to the "node_order" field in this mutation.
func (m *ERPWorkflowTaskMutation) AddedNodeOrder() (r int, exists bool) {
	v := m.addnode_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetNodeOrder resets all changes to the "node_order" field.
func (m *ERPWorkflowTaskMutation) ResetNodeOrder() {
	m.node_order = nil
	m.addnode_order = nil
}

// SetAssigneeAdminID sets the "assignee_admin_id" field.
func (m *ERPWorkflowTaskMutation) SetAssigneeAdminID(i int) {
	m.assignee_admin_id = &i
	m.addassignee_admin_id = nil
}

// AssigneeAdminID returns the value of the "assignee_admin_id" field in the mutation.
func (m *ERPWorkflowTaskMutation) AssigneeAdminID() (r int, exists bool) {
	v := m.assignee_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAssigneeAdminID returns the old "assignee_admin_id" field's value of the ERPWorkflowTask entity.
// If the ERPWorkflowTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWorkflowTaskMutation) OldAssigneeAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssigneeAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssigneeAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssigneeAdminID: %w", err)
	}
	return oldValue.AssigneeAdminID, nil
}

// AddAssigneeAdminID adds i to the "assignee_admin_id" field.
func (m *ERPWorkflowTaskMutation) AddAssigneeAdminID(i int) {
	if m.addassignee_admin_id != nil {
		*m.addassignee_admin_id += i
	} else {
		m.addassignee_admin_id = &i
	}
}

// AddedAssigneeAdminID returns the value that was added to the "assignee_admin_id" field in this mutation.
func (m *ERPWorkflowTaskMutation) AddedAssigneeAdminID() (r int, exists bool) {
	v := m.addassignee_admin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAssigneeAdminID clears the value of the "assignee_admin_id" field.
func (m *ERPWorkflowTaskMutation) ClearAssigneeAdminID() {
	m.assignee_admin_id = nil
	m.addassignee_admin_id = nil
	m.clearedFields[erpworkflowtask.FieldAssigneeAdminID] = struct{}{}
}

// AssigneeAdminIDCleared returns if the "assignee_admin_id" field was cleared in this mutation.
func (m *ERPWorkflowTaskMutation) AssigneeAdminIDCleared() bool {
	_, ok := m.clearedFields[erpworkflowtask.FieldAssigneeAdminID]
	return ok
}

// ResetAssigneeAdminID resets all changes to the "assignee_admin_id" field.
func (m *ERPWorkflowTaskMutation) ResetAssigneeAdminID() {
	m.assignee_admin_id = nil
	m.addassignee_admin_id = nil
	delete(m.clearedFields, erpworkflowtask.FieldAssigneeAdminID)
}

// SetDecision sets the "decision" field.
func (m *ERPWorkflowTaskMutation) SetDecision(s string) {
	m.decision = &s
}

// Decision returns the value of the "decision" field in the mutation.
func (m *ERPWorkflowTaskMutation) Decision() (r string, exists bool) {
	v := m.decision
	if v == nil {
		return
	}
	return *v, true
}

// OldDecision returns the old "decision" field's value of the ERPWorkflowTask entity.
// If the ERPWorkflowTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWorkflowTaskMutation) OldDecision(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDecision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDecision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDecision: %w", err)
	}
	return oldValue.Decision, nil
}

// ResetDecision resets all changes to the "decision" field.
func (m *ERPWorkflowTaskMutation) ResetDecision() {
	m.decision = nil
}

// SetComment sets the "comment" field.
func (m *ERPWorkflowTaskMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *ERPWorkflowTaskMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the ERPWorkflowTask entity.
// If the ERPWorkflowTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWorkflowTaskMutation) OldComment(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *ERPWorkflowTaskMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[erpworkflowtask.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *ERPWorkflowTaskMutation) CommentCleared() bool {
	_, ok := m.clearedFields[erpworkflowtask.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *ERPWorkflowTaskMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, erpworkflowtask.FieldComment)
}

// SetActedAt sets the "acted_at" field.
func (m *ERPWorkflowTaskMutation) SetActedAt(t time.Time) {
	m.acted_at = &t
}

// ActedAt returns the value of the "acted_at" field in the mutation.
func (m *ERPWorkflowTaskMutation) ActedAt() (r time.Time, exists bool) {
	v := m.acted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldActedAt returns the old "acted_at" field's value of the ERPWorkflowTask entity.
// If the ERPWorkflowTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWorkflowTaskMutation) OldActedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActedAt: %w", err)
	}
	return oldValue.ActedAt, nil
}

// ClearActedAt clears the value of the "acted_at" field.
func (m *ERPWorkflowTaskMutation) ClearActedAt() {
	m.acted_at = nil
	m.clearedFields[erpworkflowtask.FieldActedAt] = struct{}{}
}

// ActedAtCleared returns if the "acted_at" field was cleared in this mutation.
func (m *ERPWorkflowTaskMutation) ActedAtCleared() bool {
	_, ok := m.clearedFields[erpworkflowtask.FieldActedAt]
	return ok
}

// ResetActedAt resets all changes to the "acted_at" field.
func (m *ERPWorkflowTaskMutation) ResetActedAt() {
	m.acted_at = nil
	delete(m.clearedFields, erpworkflowtask.FieldActedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *ERPWorkflowTaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ERPWorkflowTaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ERPWorkflowTask entity.
// If the ERPWorkflowTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWorkflowTaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ERPWorkflowTaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ERPWorkflowTaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ERPWorkflowTaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ERPWorkflowTask entity.
// If the ERPWorkflowTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ERPWorkflowTaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ERPWorkflowTaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ERPWorkflowTaskMutation builder.
func (m *ERPWorkflowTaskMutation) Where(ps ...predicate.ERPWorkflowTask) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ERPWorkflowTaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ERPWorkflowTaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ERPWorkflowTask, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ERPWorkflowTaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ERPWorkflowTaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ERPWorkflowTask).
func (m *ERPWorkflowTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ERPWorkflowTaskMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.workflow_instance_id != nil {
		fields = append(fields, erpworkflowtask.FieldWorkflowInstanceID)
	}
	if m.node_name != nil {
		fields = append(fields, erpworkflowtask.FieldNodeName)
	}
	if m.node_order != nil {
		fields = append(fields, erpworkflowtask.FieldNodeOrder)
	}
	if m.assignee_admin_id != nil {
		fields = append(fields, erpworkflowtask.FieldAssigneeAdminID)
	}
	if m.decision != nil {
		fields = append(fields, erpworkflowtask.FieldDecision)
	}
	if m.comment != nil {
		fields = append(fields, erpworkflowtask.FieldComment)
	}
	if m.acted_at != nil {
		fields = append(fields, erpworkflowtask.FieldActedAt)
	}
	if m.created_at != nil {
		fields = append(fields, erpworkflowtask.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, erpworkflowtask.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ERPWorkflowTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case erpworkflowtask.FieldWorkflowInstanceID:
		return m.WorkflowInstanceID()
	case erpworkflowtask.FieldNodeName:
		return m.NodeName()
	case erpworkflowtask.FieldNodeOrder:
		return m.NodeOrder()
	case erpworkflowtask.FieldAssigneeAdminID:
		return m.AssigneeAdminID()
	case erpworkflowtask.FieldDecision:
		return m.Decision()
	case erpworkflowtask.FieldComment:
		return m.Comment()
	case erpworkflowtask.FieldActedAt:
		return m.ActedAt()
	case erpworkflowtask.FieldCreatedAt:
		return m.CreatedAt()
	case erpworkflowtask.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ERPWorkflowTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case erpworkflowtask.FieldWorkflowInstanceID:
		return m.OldWorkflowInstanceID(ctx)
	case erpworkflowtask.FieldNodeName:
		return m.OldNodeName(ctx)
	case erpworkflowtask.FieldNodeOrder:
		return m.OldNodeOrder(ctx)
	case erpworkflowtask.FieldAssigneeAdminID:
		return m.OldAssigneeAdminID(ctx)
	case erpworkflowtask.FieldDecision:
		return m.OldDecision(ctx)
	case erpworkflowtask.FieldComment:
		return m.OldComment(ctx)
	case erpworkflowtask.FieldActedAt:
		return m.OldActedAt(ctx)
	case erpworkflowtask.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case erpworkflowtask.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ERPWorkflowTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPWorkflowTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case erpworkflowtask.FieldWorkflowInstanceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowInstanceID(v)
		return nil
	case erpworkflowtask.FieldNodeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeName(v)
		return nil
	case erpworkflowtask.FieldNodeOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNodeOrder(v)
		return nil
	case erpworkflowtask.FieldAssigneeAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssigneeAdminID(v)
		return nil
	case erpworkflowtask.FieldDecision:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDecision(v)
		return nil
	case erpworkflowtask.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case erpworkflowtask.FieldActedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActedAt(v)
		return nil
	case erpworkflowtask.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case erpworkflowtask.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ERPWorkflowTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ERPWorkflowTaskMutation) AddedFields() []string {
	var fields []string
	if m.addworkflow_instance_id != nil {
		fields = append(fields, erpworkflowtask.FieldWorkflowInstanceID)
	}
	if m.addnode_order != nil {
		fields = append(fields, erpworkflowtask.FieldNodeOrder)
	}
	if m.addassignee_admin_id != nil {
		fields = append(fields, erpworkflowtask.FieldAssigneeAdminID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ERPWorkflowTaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case erpworkflowtask.FieldWorkflowInstanceID:
		return m.AddedWorkflowInstanceID()
	case erpworkflowtask.FieldNodeOrder:
		return m.AddedNodeOrder()
	case erpworkflowtask.FieldAssigneeAdminID:
		return m.AddedAssigneeAdminID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ERPWorkflowTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case erpworkflowtask.FieldWorkflowInstanceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWorkflowInstanceID(v)
		return nil
	case erpworkflowtask.FieldNodeOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNodeOrder(v)
		return nil
	case erpworkflowtask.FieldAssigneeAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssigneeAdminID(v)
		return nil
	}
	return fmt.Errorf("unknown ERPWorkflowTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ERPWorkflowTaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(erpworkflowtask.FieldAssigneeAdminID) {
		fields = append(fields, erpworkflowtask.FieldAssigneeAdminID)
	}
	if m.FieldCleared(erpworkflowtask.FieldComment) {
		fields = append(fields, erpworkflowtask.FieldComment)
	}
	if m.FieldCleared(erpworkflowtask.FieldActedAt) {
		fields = append(fields, erpworkflowtask.FieldActedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ERPWorkflowTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ERPWorkflowTaskMutation) ClearField(name string) error {
	switch name {
	case erpworkflowtask.FieldAssigneeAdminID:
		m.ClearAssigneeAdminID()
		return nil
	case erpworkflowtask.FieldComment:
		m.ClearComment()
		return nil
	case erpworkflowtask.FieldActedAt:
		m.ClearActedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPWorkflowTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ERPWorkflowTaskMutation) ResetField(name string) error {
	switch name {
	case erpworkflowtask.FieldWorkflowInstanceID:
		m.ResetWorkflowInstanceID()
		return nil
	case erpworkflowtask.FieldNodeName:
		m.ResetNodeName()
		return nil
	case erpworkflowtask.FieldNodeOrder:
		m.ResetNodeOrder()
		return nil
	case erpworkflowtask.FieldAssigneeAdminID:
		m.ResetAssigneeAdminID()
		return nil
	case erpworkflowtask.FieldDecision:
		m.ResetDecision()
		return nil
	case erpworkflowtask.FieldComment:
		m.ResetComment()
		return nil
	case erpworkflowtask.FieldActedAt:
		m.ResetActedAt()
		return nil
	case erpworkflowtask.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case erpworkflowtask.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ERPWorkflowTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ERPWorkflowTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ERPWorkflowTaskMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ERPWorkflowTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ERPWorkflowTaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ERPWorkflowTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ERPWorkflowTaskMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ERPWorkflowTaskMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ERPWorkflowTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ERPWorkflowTaskMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ERPWorkflowTask edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	username      *string
	password_hash *string
	role          *int8
	addrole       *int8
	admin_id      *int
	addadmin_id   *int
	disabled      *bool
	last_login_at *time.Time
	points        *int64
	addpoints     *int64
	expires_at    *time.Time
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(i int8) {
	m.role = &i
	m.addrole = nil
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r int8, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// AddRole adds i to the "role" field.
func (m *UserMutation) AddRole(i int8) {
	if m.addrole != nil {
		*m.addrole += i
	} else {
		m.addrole = &i
	}
}

// AddedRole returns the value that was added to the "role" field in this mutation.
func (m *UserMutation) AddedRole() (r int8, exists bool) {
	v := m.addrole
	if v == nil {
		return
	}
	return *v, true
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
	m.addrole = nil
}

// SetAdminID sets the "admin_id" field.
func (m *UserMutation) SetAdminID(i int) {
	m.admin_id = &i
	m.addadmin_id = nil
}

// AdminID returns the value of the "admin_id" field in the mutation.
func (m *UserMutation) AdminID() (r int, exists bool) {
	v := m.admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminID returns the old "admin_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAdminID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminID: %w", err)
	}
	return oldValue.AdminID, nil
}

// AddAdminID adds i to the "admin_id" field.
func (m *UserMutation) AddAdminID(i int) {
	if m.addadmin_id != nil {
		*m.addadmin_id += i
	} else {
		m.addadmin_id = &i
	}
}

// AddedAdminID returns the value that was added to the "admin_id" field in this mutation.
func (m *UserMutation) AddedAdminID() (r int, exists bool) {
	v := m.addadmin_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAdminID clears the value of the "admin_id" field.
func (m *UserMutation) ClearAdminID() {
	m.admin_id = nil
	m.addadmin_id = nil
	m.clearedFields[user.FieldAdminID] = struct{}{}
}

// AdminIDCleared returns if the "admin_id" field was cleared in this mutation.
func (m *UserMutation) AdminIDCleared() bool {
	_, ok := m.clearedFields[user.FieldAdminID]
	return ok
}

// ResetAdminID resets all changes to the "admin_id" field.
func (m *UserMutation) ResetAdminID() {
	m.admin_id = nil
	m.addadmin_id = nil
	delete(m.clearedFields, user.FieldAdminID)
}

// SetDisabled sets the "disabled" field.
func (m *UserMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *UserMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *UserMutation) ResetDisabled() {
	m.disabled = nil
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *UserMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *UserMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (m *UserMutation) ClearLastLoginAt() {
	m.last_login_at = nil
	m.clearedFields[user.FieldLastLoginAt] = struct{}{}
}

// LastLoginAtCleared returns if the "last_login_at" field was cleared in this mutation.
func (m *UserMutation) LastLoginAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginAt]
	return ok
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *UserMutation) ResetLastLoginAt() {
	m.last_login_at = nil
	delete(m.clearedFields, user.FieldLastLoginAt)
}

// SetPoints sets the "points" field.
func (m *UserMutation) SetPoints(i int64) {
	m.points = &i
	m.addpoints = nil
}

// Points returns the value of the "points" field in the mutation.
func (m *UserMutation) Points() (r int64, exists bool) {
	v := m.points
	if v == nil {
		return
	}
	return *v, true
}

// OldPoints returns the old "points" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPoints(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoints: %w", err)
	}
	return oldValue.Points, nil
}

// AddPoints adds i to the "points" field.
func (m *UserMutation) AddPoints(i int64) {
	if m.addpoints != nil {
		*m.addpoints += i
	} else {
		m.addpoints = &i
	}
}

// AddedPoints returns the value that was added to the "points" field in this mutation.
func (m *UserMutation) AddedPoints() (r int64, exists bool) {
	v := m.addpoints
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoints resets all changes to the "points" field.
func (m *UserMutation) ResetPoints() {
	m.points = nil
	m.addpoints = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *UserMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *UserMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *UserMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[user.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *UserMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[user.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *UserMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, user.FieldExpiresAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.admin_id != nil {
		fields = append(fields, user.FieldAdminID)
	}
	if m.disabled != nil {
		fields = append(fields, user.FieldDisabled)
	}
	if m.last_login_at != nil {
		fields = append(fields, user.FieldLastLoginAt)
	}
	if m.points != nil {
		fields = append(fields, user.FieldPoints)
	}
	if m.expires_at != nil {
		fields = append(fields, user.FieldExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldRole:
		return m.Role()
	case user.FieldAdminID:
		return m.AdminID()
	case user.FieldDisabled:
		return m.Disabled()
	case user.FieldLastLoginAt:
		return m.LastLoginAt()
	case user.FieldPoints:
		return m.Points()
	case user.FieldExpiresAt:
		return m.ExpiresAt()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldAdminID:
		return m.OldAdminID(ctx)
	case user.FieldDisabled:
		return m.OldDisabled(ctx)
	case user.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	case user.FieldPoints:
		return m.OldPoints(ctx)
	case user.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldRole:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminID(v)
		return nil
	case user.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	case user.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	case user.FieldPoints:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoints(v)
		return nil
	case user.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addrole != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.addadmin_id != nil {
		fields = append(fields, user.FieldAdminID)
	}
	if m.addpoints != nil {
		fields = append(fields, user.FieldPoints)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldRole:
		return m.AddedRole()
	case user.FieldAdminID:
		return m.AddedAdminID()
	case user.FieldPoints:
		return m.AddedPoints()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldRole:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRole(v)
		return nil
	case user.FieldAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAdminID(v)
		return nil
	case user.FieldPoints:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoints(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldAdminID) {
		fields = append(fields, user.FieldAdminID)
	}
	if m.FieldCleared(user.FieldLastLoginAt) {
		fields = append(fields, user.FieldLastLoginAt)
	}
	if m.FieldCleared(user.FieldExpiresAt) {
		fields = append(fields, user.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldAdminID:
		m.ClearAdminID()
		return nil
	case user.FieldLastLoginAt:
		m.ClearLastLoginAt()
		return nil
	case user.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldAdminID:
		m.ResetAdminID()
		return nil
	case user.FieldDisabled:
		m.ResetDisabled()
		return nil
	case user.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	case user.FieldPoints:
		m.ResetPoints()
		return nil
	case user.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
